{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introductie","text":"<p>Welkom bij de Experiment Control with Python Course. Deze cursus wordt aangeboden aan studenten van de joint degree Natuur- en Sterrenkunde van de Universiteit van Amsterdam en de Vrije Universiteit Amsterdam, en wordt gegeven door Annelies Vlaar (a.m.vlaar@vu.nl) en David Fokkema (d.b.r.a.fokkema@vu.nl).</p> <p>Het doel van deze cursus is om je kennis te laten maken met het aansturen en uitlezen van een experiment. Bij heel eenvoudige experimenten kun je metingen \u00e9\u00e9n voor \u00e9\u00e9n verrichten en ruwe data noteren in je labjournaal, bijvoorbeeld bij het meten van de trillingstijd van een slinger bij verschillende lengtes. Maar al snel wordt dat ondoenlijk, bijvoorbeeld wanneer je de hele beweging van de slinger wilt volgen met een ultrasoon afstandsdetector. In een gemiddeld lab worden alle experimenten via de computer aangestuurd en uitgelezen. Voor standaard handelingen zoals het bekijken van een sample onder een elektronenmicroscoop of het opnemen van een spectrum van een radioactieve bron kun je de door de fabrikant meegeleverde software gebruiken. Maar vaak is die software \u00f3f heel duur terwijl je maar een klein deel van de functionaliteit nodig hebt, \u00f3f ongeschikt voor jouw doeleinden. En heel vaak voer je g\u00e9\u00e9n standaardexperiment uit, maar ben je een nieuw experiment aan het opzetten. In dat geval is er helemaal geen software voorhanden. Je zult dan zelf aan de slag moeten.</p> <p>We willen je in deze cursus niet alleen maar leren om zelf een applicatie te schrijven voor het uitvoeren van een snelle meting, maar ook hoe je de code netjes schrijft. Als je straks een bachelorproject doet, een masterstage of een promotieonderzoek, dan wil je code schrijven die ook na de afronding van je project of de verdedeging van je proefschrift nog bruikbaar is. Ook zullen andere onderzoekers aan dezelfde code werken. Het is dus belangrijk om te zorgen voor een duidelijke structuur waarmee de code overzichtelijk blijft maar ook makkelijk is aan te passen of uit te breiden.</p> <p>Je gaat in deze cursus aan de slag met een Arduino. De Arduino bevat firmware<sup>1</sup> waarmee het zich gedraagt als een meetinstrument en kan communiceren met de computer volgens een standaardprotocol dat ook ge\u00efmplementeerd wordt door onder andere functiegeneratoren en oscilloscopen.</p>"},{"location":"#werk-van-anderen","title":"Werk van anderen","text":"<p>Over Python wordt veel geschreven en er zijn tal van (professionele) trainingen die je kunt volgen. Over de hele wereld zijn conferenties en er is vermoedelijk geen universiteit meer te vinden waar Python niet wordt gebruikt. Deze cursus is niet in een vacu\u00fcm ontstaan. Voordat deze cursus in studiejaar 2020-2021 voor het eerst gegeven werd is jarenlang de cursus Experimentautomatisering met LabVIEW gegeven aan de Vrije Universiteit Amsterdam door Jan Mulder en Gerrit Kuik. Deze cursus is de spirituele opvolger van de LabVIEW-cursus. Een website (en boek!) met eenzelfde soort insteek is Python for the lab van Aquiles Carattino.<sup>3</sup> Op de website is veel informatie te vinden over hoe je Python gebruikt (slots, singletons, multiprocessing) en met verschillende soorten hardware communiceert (van onder andere National Instruments en Basler). In het boek leer je hoe je een eenvoudig experiment opzet en aanstuurt vanuit Python, heel vergelijkbaar met het eerste deel van deze cursus. Zowel in deze cursus als in het boek is gekozen voor het diode-experiment (project 1 uit het Arduino Projects Book dat meegeleverd wordt met de Arduino Starter Kit). Een groot verschil is dat je in deze cursus leert over versiebeheer, command-line interfaces en project management met Poetry.</p> <p>Voor het eindfeest automatiseren we een zonnecelexperiment. Het idee hiervoor is gebaseerd op het experiment dat we uitvoeren in het eerste jaar. Hoewel hetzelfde eerder gedaan is door o.a. Chenni et al.<sup>4</sup> en Hammoumi et al.<sup>5</sup> met LabVIEW, is de schakeling die in deze cursus gebruikt wordt door ons ontworpen om de noodzaak van een relatief dure stroomsterktesensor te vermijden. Ook wordt de schakeling daardoor fysisch gezien wat interessanter.</p> <p>Deze cursus is oorspronkelijk opgezet door David Fokkema maar in de jaren daarna door Annelies Vlaar aanzienlijk verbeterd. De cursus heeft nu een veel sterkere focus (minder belangrijke zaken zijn verwijderd) en de opbouw is flink aangepakt. In 2024 heeft Annelies Vlaar ook een subsidie toegekend gekregen om de cursus verder te verbeteren door een aantal studentassistenten in te huren. We zijn veel dank verschuldigd aan Olivier Swaak, Derk Niessink, Amin Rouan Serik, Thijs de Zeeuw en Fijke Oei.</p>"},{"location":"#notatie","title":"Notatie","text":"<p>We zullen in deze handleiding vaak Engelse termen gebruiken, ook als Nederlandse termen voorhanden zijn. Bijvoorbeeld: list in plaats van lijst, class in plaats van klasse. Dit doen we omdat deze Engelse termen veel meer ingeburgerd zijn en omdat voor sommige van de Engelse termen geen goede vertalingen zijn. Liever wat consequenter Engelse termen gebruiken dan alles door elkaar!</p> <p>In deze handleiding kom je twee verschillende opdrachten tegen: Pythoncode en systeemopdrachten. Voor Pythoncode geldt dat je in Visual Studio Code een nieuw bestand moet aanmaken met de extensie <code>.py</code> en dat je daarin de code kunt typen. Vervolgens kun je het script runnen en geeft Visual Studio Code de uitvoer terug. In deze handleiding zal dat als volgt worden weergegeven:</p>  python_code.py <pre><code># I am a script. I am in a colored block\n# and the Python code has colored syntax.\n\ndef my_func(x):\n    return x ** 2\n\nprint(my_func(2))\n</code></pre> <pre>\n<code>(ECPC) &gt; python python_code.py\n4\n</code></pre> <p>Linksboven kun je op de -icoon klikken om de output van de code te zien. Rechtsboven in het blok staat een -icoon. Als je daar op klikt dan wordt de hele code gekopieerd naar het klembord en kun je het in Visual Studio Code weer plakken met Ctrl+V.</p> <p>Ook zul je soms systeemopdrachten moeten uitvoeren. Je wilt bijvoorbeeld nieuwe Pythonbibliotheken installeren of je nieuw-gebouwde applicaties testen. Dit doen we vanuit de terminal. De terminal biedt een zogeheten command-line interface voor het systeem. Dit in tegenstelling tot een grafische interface.<sup>2</sup> Met deze notatie laten we zien hoe je <code>my-script.py</code> met python kunt runnen: Terminal<pre><code>python my-script.py\n</code></pre> Zoals je ziet hebben we de prompt (bijvoorbeeld <code>&gt;</code>) weggelaten zodat je makkelijker commando's kunt kopi\u00ebren en plakken. Wanneer we ook de uitvoer van commando's laten zien is het handiger om onderscheid te maken tussen het commando en de uitvoer. Nu geven we wel de prompt weer (<code>(ECPC) &gt;</code>). Door op het -icoon te klikken wordt de uitvoer zichtbaar.</p> <pre><code>(ECPC) &gt; python --version \nPython 3.10.9\n</code></pre> <p>We maken veel gebruik van conda environments. Hierboven zie je de naam van de conda environment tussen ronde haakjes staan, in dit geval heet de conda environment <code>ecpc</code>. In de voorbeeldcode staat standaard de <code>ecpc</code> conda environment, maar welk conda environment je moet gebruiken hangt van de opdracht af.</p>"},{"location":"#opgaves","title":"Opgaves","text":"<p>In de handleiding staan verschillende opgaves. Sommige opgaves zijn bedoeld als oefening en andere opgaves moet je inleveren voor feedback en een beoordeling. Schrijf je code in het Engels, zo ben je voorbereid op het werken in een internationale onderzoeksgroep.</p> <p>Info</p> <p>In sommige programmeercursussen is het de bedoeling dat je een bepaald algoritme zelf schrijft. Je moet bijvoorbeeld een loop schrijven om een reeks berekeningen uit te voeren en mag dan niet gebruik maken van de NumPy-bibliotheek om dat in \u00e9\u00e9n regel te doen. Je kunt je voorstellen dat als je straks in een lab werkt dat je juist gebruik wilt maken van bibliotheken die het leven een stuk gemakkerlijker maken. Trek dus alles uit de kast. Kijk eens in de Python Standard Library,<sup>6</sup> de Python Package Index<sup>7</sup> of Awesome Python<sup>8</sup>.</p> <p>Basisopdracht</p> opdrachtcodecheck <p>Deze opgaves helpen je om het niveau te behalen wat van je verwacht wordt. Ze worden niet beoordeeld. Hierboven zie je drie tabbladen opdracht, code en check. Klik op code om naar het volgende tabblad te gaan.</p> <p>Pseudo-code <pre><code># in de pseudo-code vind je code \n# om je verder op weg te helpen\n</code></pre> Testcode  Testcode.py <pre><code># gebruik (delen van) deze code om je opdracht te testen\n# bekijk de output van deze code\n# ga daarna naar het tabblad \"check\"\n</code></pre> <pre>\n<code>(ECPC) &gt; python Testcode.py\nKrijg je (ongeveer) dezelfde output?\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De checkpunten in deze lijst helpen je om te zien of je op de goede weg bent. </li> <li> Je kunt de checkpunten zelf afvinken. Klik daarvoor op het grijze vinkje links van deze zin.</li> </ul> <p>Projecttraject</p> <ul> <li> Je bouwt voort op oude opgaves.</li> <li> Opgaves waarvoor een groen vinkje staat, heb je al gemaakt...</li> <li> ... of het is de opgave waar je nu mee bezig bent.</li> <li> Opgaves zonder vinkje volgen nog.</li> <li> Zo kun je altijd zien waar je in het projecttraject bent.</li> </ul> <p>Voorbereidende opdrachten</p> <p>Sommige opgaves hebben een icoontje met een huis en een laptop voor de titel. Deze opgaves zijn voorbereidende opdrachten die je voorafgaand aan een sessie maakt. Deze opgaves bereiden je voor op de stof van de betreffende sessie. Vragen over deze opgaves kun je in de les stellen. </p> <p>Inleveropdracht</p> <p>Deze opgaves moet worden ingeleverd voor feedback en een beoordeling. Je herkent ze aan de groene kleur. De opgaves bouwen op elkaar voort. Je levert alle opgaves van een projecttraject als geheel in. Kijk daarom goed bij het projecttraject in het tabblad check welke groene opgaves je gemaakt moet hebben voordat je het inlevert. </p> <p>Vaak heb je kennis en/of vaardigheden nodig die je eerder hebt geleerd. Zie je een  lampje staan? Klik dan bovenin de blauwe balk (rechtsboven, naast de zoekbalk) op het lampje om de spiekbriefjes te openen.</p> <p>Meer leren</p> <p>Dit zijn verdiepende en verbredende opgaves om je te kunnen ontwikkelen tot een goed programmeur en een waardevolle aanwinst voor een onderzoeksgroep. Je kunt er geen extra punten mee verdienen wanneer je deze technieken toepast in je inleveropdrachten, maar het is wel een goede oefening. Doe deze opgaves alleen als je klaar bent met \u00e1lle opgaves van het projecttraject.</p> <p>Een basiskennis van Python is nodig om de opgaves te kunnen maken. In de paragraaf Basiskennis Python vind je opdrachten om je kennis te testen. Het is handig om ook een uitgebreidere Python kennis te hebben, meer informatie vind je in de paragraaf Uitgebreidere Python kennis.</p> <ol> <li> <p>Firmware is software die in hardware is geprogrammeerd. Bijvoorbeeld het computerprogramma dat ervoor zorgt dat je magnetron reageert op de knoppen en je eten verwarmd.\u00a0\u21a9</p> </li> <li> <p>Er bestaan verschillende terminal emulators, meestal afhankelijk van het besturingssysteem \u2014 al heeft Windows zelf al drie verschillende prompts: de command prompt, de powershell prompt en tegenwoordig (voorkeur) de Windows Terminal. Een terminal ziet eruit als een tekstvenster. Hierbinnen verschijnt een prompt. Dit is een klein stukje tekst dat aangeeft waar je je opdrachten kunt intypen. In MacOS en Linux is de prompt vaak een <code>$</code>-teken. In Windows ziet het er vaak uit als <code>C:\\&gt;</code> of <code>PS&gt;</code>. In veel documentatie op internet wordt de <code>$</code>-prompt gebruikt.\u00a0\u21a9</p> </li> <li> <p>Aquiles Carattino. Python for the lab. URL: https://pythonforthelab.com.\u00a0\u21a9</p> </li> <li> <p>Rachid Chenni. Tracing current-voltage curve of solar panel based on labview arduino interfacing. Bili\u015fim Teknolojileri Dergisi, 8:, 09 2015. URL: https://www.researchgate.net/publication/283037607_Tracing_current-voltage_curve_of_solar_panel_Based_on_LabVIEW_Arduino_Interfacing.\u00a0\u21a9</p> </li> <li> <p>A El Hammoumi, S Motahhir, A Chalh, A El Ghzizal, and A Derouich. Real-time virtual instrumentation of arduino and labview based pv panel characteristics. IOP Conference Series: Earth and Environmental Science, 161(1):012019, jun 2018. doi:10.1088/1755-1315/161/1/012019.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. The python standard library. URL: https://docs.python.org/3/library/.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. Python package index. URL: https://pypi.org.\u00a0\u21a9</p> </li> <li> <p>Vinta Chen. Awesome python. URL: https://awesome-python.com.\u00a0\u21a9</p> </li> </ol>"},{"location":"basis-python/","title":"Basiskennis Python","text":"<p>Bij de cursus Inleiding programmeren heb je de basis van het programmeren in Python geleerd. In dit hoofdstuk neem je de hoofdlijnen van deze cursus door met behulp van een aantal opdrachten. </p> <p>Bij Inleiding programmeren mocht je kiezen om je code in het Nederlands of het Engels te schrijven. Omdat wij jou voorbereiden om in een onderzoeksgroep je bachelorproject te gaan doen, waar je hoogstwaarschijnlijk internationale collega's gaat treffen, vragen we jou om bij ECPC alles in het Engels te schrijven. </p>"},{"location":"basis-python/#visual-studio-code","title":"Visual Studio Code","text":"<p>Map aanmaken en openen in Visual Studio Code</p> <ol> <li>Open Visual Studio Code.</li> <li>Ga naar File &gt; Open folder.</li> <li>Navigeer naar een geschikte map.</li> <li>Klik op Nieuwe map en geef de map de naam ECPC.</li> <li>Klik op Map selecteren.</li> </ol>"},{"location":"basis-python/#variabelen-input-functie-en-f-strings","title":"Variabelen, <code>input()</code>-functie en f-strings","text":"<p>Variabelen, <code>input()</code>-functie en f-strings</p> <ol> <li>Maak een bestand <code>diameter-ball.py</code> in de map <code>ECPC</code>. <code>ECPC</code> \u2514\u2500\u2500  <code>diameter-ball.py</code> </li> <li>Schrijf een stuk code waarin je de gebruiker vraagt wat de diameter van de bal is. Maak hierbij gebruik van de <code>input()</code>-functie. </li> <li>Bereken daarna de straal van de bal.</li> <li>Print de diameter en straal van de bal in een zin. Maak hiervoor gebruik van f-strings. Bijvoorbeeld: \"A ball with a diameter of 2.8 m has a radius of 1.4 m.\"</li> <li>Test je script met het getal 2.8.</li> </ol> Uitwerkingen <pre><code>diameter = input(\"Enter the diameter of the ball: \")\ndiameter = float(diameter)\nradius = diameter / 2\nprint(f\"A ball with a diameter of {diameter} m has a radius of {radius} m.\")\n</code></pre>"},{"location":"basis-python/#if-statements-en-operatoren","title":"If-statements en operatoren","text":"<p>if-statements en operatoren</p> <p>Met een if-statement kun je een conditie testen door operatoren te gebruiken. </p> <ol> <li>Schrijf de operatoren op voor:<ul> <li>gelijk aan</li> <li>ongelijk aan</li> <li>groter dan</li> <li>groter of gelijk aan</li> <li>kleiner dan</li> <li>kleiner dan of gelijk aan</li> </ul> </li> <li>Vul in onderstaand script de juiste condities in op de <code>...</code>. Maak gebruik van de variabelen <code>rain</code> en <code>umbrella</code> \u00e9n de operatoren <code>and</code>, <code>not</code> en <code>or</code>. <pre><code>import random\n\nrain = random.choice([True, False])\numbrella = random.choice([True, False])\n\nprint(f\"{rain=}, {umbrella=}\")\n\nif ... :\n    print(\"Lucky you have your umbrella with you since it's raining.\")\n\nif ... :\n    if ... :\n        print(\"You will get wet without an umbrella since it's raining.\")\n    if ... :\n        print(\"You can use your umbrella as a walking stick since it doesn't rain.\")\n\nif ... :\n    print(\"Without an umbrella there is no problem since it's not raining.\")\n</code></pre></li> </ol> Uitwerkingen <pre><code>import random\n\nrain = random.choice([True, False])\numbrella = random.choice([True, False])\n\nprint(f\"{rain=}, {umbrella=}\")\n\nif rain and umbrella:\n    print(\"Lucky you have your umbrella with you since it's raining.\")\n\nif rain or umbrella:\n    if rain and not umbrella:\n        print(\"You will get wet without an umbrella since it's raining.\")\n    if not rain and umbrella:\n        print(\"You can use your umbrella as a walking stick since it doesn't rain.\")\n\nif not rain and not umbrella:\n    print(\"Without an umbrella there is no problem since it's not raining.\")\n</code></pre>"},{"location":"basis-python/#for-loop-while-loop-en-break","title":"For-loop, while-loop en break","text":"<p>Bij het programmeren heb je vaak te maken met foutmeldingen. Bij het debuggen van een loop zijn twee dingen heel handig: <code>print</code> en <code>break</code>.</p> <p>For-loop, while-loop en break</p> <p>Beschouw het volgende stuk code: <pre><code>voltage = 0  # mV\nsteps = 50  # mV\nwhile voltage &lt; 3300:\n    voltage += steps\n</code></pre></p> <ol> <li>Gebruik <code>print</code> om het voltage te printen in de while-loop. Doe dit handig met f-strings, zodat je weet wat je print. Bijvoorbeeld: \"The voltage is set to 0 mV.\"</li> <li>Gebruik daarna <code>break</code> om de loop maar \u00e9\u00e9n keer te doorlopen. </li> <li>Schrijf nu de code om. Vervang de <code>while</code>-loop voor een <code>for</code>-loop. </li> </ol> Uitwerkingen <p> print_and_break.py <pre><code>voltage = 0  # mV\nsteps = 50  # mV\nwhile voltage &lt; 3300:\n    voltage += steps\n    print(f\"The voltage is set to {voltage} mV.\")\n    break\n</code></pre> <pre>\n<code>(ECPC) &gt; python print_and_break.py\nThe voltage is set to 50 mV.\n</code></pre></p> <p> for_loop.py <pre><code>for voltage in range(0, 3300, 50):\n    print(f\"The voltage is set to {voltage} mV.\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python for_loop.py\nThe voltage is set to 0 mV.\nThe voltage is set to 50 mV.\nThe voltage is set to 100 mV.\nThe voltage is set to 150 mV.\n...\n</code></pre></p>"},{"location":"basis-python/#functies","title":"Functies","text":"<p>Functies</p> <ol> <li> <p>Zorg dat in onderstaande code de functie <code>exponentiation</code> gaat werken. <pre><code>def exponentiation():\n    solution =\n    ...\n\n\nnumber_1 = 2\nnumber_2 = 8\n\nanswer = exponentiation(number_1, number_2)\nprint(f\"{number_1}^{number_2} = {answer}\")\n</code></pre></p> </li> <li> <p>In bovenstaande code zijn vier variabelen gedefinieerd: <code>solution</code>, <code>number_1</code>, <code>number_2</code> en <code>answer</code>. Welk van deze variabelen zijn globaal en welke zijn lokaal? Leg uit wat de consequentie is voor het gebruiken van globaal en lokaal gedefinieerde variabelen.</p> </li> </ol> Uitwerkingen <ol> <li> <pre><code>def exponentiation(base, exponent):\n    solution = base**exponent\n    return solution\n\n\nnumber_1 = 2\nnumber_2 = 8\n\nanswer = exponentiation(number_1, number_2)\nprint(f\"{number_1}^{number_2} = {answer}\")\n</code></pre> </li> <li> <p>De globale variabelen zijn <code>number_1</code>, <code>number_2</code> en <code>answer</code> en de lokale variabele is <code>solution</code>. Het gevolg is dat <code>number_1</code>, <code>number_2</code> en <code>answer</code> zowel buiten als binnen de functie <code>exponentiation()</code> gebruikt kunnen worden, terwijl <code>solution</code> alleen maar binnen de functie <code>exponentiation()</code> gebruikt kan worden. </p> </li> </ol>"},{"location":"basis-python/#lijsten","title":"Lijsten","text":"<p>Lijsten</p> <ol> <li>Schrijf een Python script waarin je een lijst definieert met de namen van de maanden.</li> <li>Print de negende maand.</li> <li>Voeg een dertiende maand toe aan de lijst. Controleer daarna of dit gelukt is.</li> </ol> Uitwerkingen <p> lijsten.py <pre><code>months = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\n\nninth_month = months[8]\n\nprint(f\"The ninth month is called {ninth_month}\")\n\nmonths.append(\"tr\u0113decimber\")\n\nprint(months)\n</code></pre> <pre>\n<code>(ECPC) &gt; python lijsten.py\nThe ninth month is called September.\n['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'tr\u0113decimber']\n</code></pre></p>"},{"location":"basis-python/#stijl","title":"Stijl","text":"<p>Bij inleiding programmeren heb je geleerd hoe je code netjes opschrijft, zodat de code leesbaar en begrijpelijk is. Hieronder vind je een samenvatting, die een beetje aangevuld is met ECPC-stijl.</p> <ul> <li>Schrijf code in het Engels.</li> <li>De naam van een variabele houd je kort en duidelijk. Gebruik alleen afkortingen wanneer deze bij veel mensen bekend is. Dus: <code>korte_variabelenaam = 28</code></li> <li>Namen van functies geven duidelijk weer wat de functie doet, deze namen mogen lang zijn. Dus: <code>def functienamen_met_doel():</code></li> <li>Je hoeft code niet met de hand over te schrijven. Leesbaarheid gaat daarom boven beknoptheid. Gebruik meerdere regels code als je meerdere stappen zet, in plaats van een heel lange regel code waar meer dan \u00e9\u00e9n ding gebeurt.</li> <li>Gebruik <code>#commentaar</code>-kopjes om een stukje code samen te vatten, een waarschuwing te geven, uitleg van complexe algoritmen te doen, uitleg van een variabele te geven, voor bronvermelding, enzovoorts. Zet het commentaar altijd boven het stukje code waar het over gaat. </li> <li>Zorg ook voor een nette opmaak. Spring in waar nodig, gebruik witregels en zet spaties rondom operatoren.</li> </ul>"},{"location":"basis-python/#modules","title":"Modules","text":"<p>Ook heb je al geleerd om functies uit andere (Python) modules te importeren. Meer hierover vind je in de paragraaf Modules. Maak uit deze paragraaf de bijbehorende opdrachten om te oefenen met het gebruik van modules.</p>"},{"location":"basis-python/#plotten","title":"Plotten","text":"<p>Grafieken</p> <p>Gebruik <code>matplotlib</code> om een scatterplot te maken van de twee lijsten die hieronder zijn weergegeven. Zet de grootheden en eenheden bij beide assen en sla het figuur op als PNG-bestand. <pre><code>time = [0, 0.5, 1, 1.5, 2, 2.5, 3]  # seconds\ndistance = [0, 15, 50, 100, 200, 300, 400]  # meters\n</code></pre></p> Uitwerkingen <pre><code>import matplotlib.pyplot as plt\n\ntime = [0, 0.5, 1, 1.5, 2, 2.5, 3]  # seconds\ndistance = [0, 15, 50, 100, 200, 300, 400]  # meters\n\nplt.plot(time, distance, \"o\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Distance (m)\")\nplt.savefig(\"plot.png\")\n</code></pre>"},{"location":"basis-python/#bestanden-inlezen","title":"Bestanden inlezen","text":"<p>Tekstbestanden lezen</p> <p>Hieronder vind je een kort verhaal. Kopieer de inhoud van dit verhaal naar een tekstbestand \u2014 een .txt-bestand \u2014 en sla dit bestand op in de map <code>ECPC</code>. Schrijf daarna een script om het tekstbestand te lezen en regel voor regel te printen. <pre><code>\"Do you have a favourite\nsaying?\" asked the boy.\n\"Yes\" said the mole.\n\"What is it?\"\n\"If at first you don't \nsucceed have some cake.\"\n\"I see, does it work?\"\n\"Every time.\"\nFrom: The boy, the mole, the fox and the horse - Charlie Mackesy\n</code></pre></p> Uitwerkingen <p> txt_bestanden_lezen.py <pre><code>with open(\"story.txt\", \"r\") as file:\n    for line in file:\n        print(line)\n</code></pre> <pre>\n<code>(ECPC) &gt; python txt_bestanden_lezen.py\n\"Do you have a favourite\nsaying?\" asked the boy.\n\"Yes\" said the mole.\n\"What is it?\"\n\"If at first you don't \nsucceed have some cake.\"\n\"I see, does it work?\"\n\"Every time.\"\nFrom: The boy, the mole, the fox and the horse - Charlie Mackesy\n</code></pre></p>"},{"location":"basisscript/","title":"Basisscript voor het experiment","text":"<p>Het experiment wat je gaat uitvoeren is het bepalen van de $I,U$-karakteristiek van een LED. Omdat de Arduino alleen getallen tussen 0 en 1023 kan sturen en ontvangen moet je nadenken over de analoog-digitaalconversie voordat je een zinnige $I,U$-karakteristiek kunt maken. </p>"},{"location":"basisscript/#analoog-digitaalconversie-adc","title":"Analoog-digitaalconversie (ADC)","text":"<p>De Arduino kan getallen tussen 0 en 1023 sturen en ontvangen. Wat is precies de betekenis van deze getallen? Daarvoor moeten we dieper ingaan op hoe de Arduino \u2014 en computers in het algemeen \u2014 getallen omzet in een spanning en hoe spanningen door de Arduino worden gemeten.</p> <p>Een analoog signaal is continu in zowel de tijd als de waardes die het signaal aan kan nemen.<sup>1</sup> Een digitaal signaal is echter discreet: op vaste tijdstippen is er een waarde bekend en het signaal kan maar een beperkt aantal verschillende waardes aannemen.<sup>3</sup> </p> <p>Bemonsteren of sampling is het proces waarbij een analoog signaal wordt uitgelezen en wordt omgezet in een digitaal signaal. Zo wordt een audiosignaal al sinds eind jaren '70 van de vorige eeuw gewoonlijk bemonsterd met een frequentie van 44.1 kHz en een resolutie van 16 bits. Dus 44100 keer per seconde wordt er gekeken wat de waarde van het geluidssignaal is en dat wordt opgeslagen als een getal van 16 bits en kan dus $2^{16} = 65536$ verschillende waardes aannemen. Dit is nauwkeuriger dan het menselijk gehoor kan onderscheiden.</p> <p></p> 0 3.3 V 0 15 63 1023 <p></p> <p>ADC resolutie</p> opdrachtcheck <p>De schuifjes hierboven zijn aan elkaar gekoppeld, zij laten de koppeling zien tussen analoge voltages en digitale waardes en visa versa. Het bovenste schuifje laat het analoge voltage zien. Het onderste schuifje is de bijbehorende digitale waarde. </p> <ol> <li>Zet het digitale signaal op een resolutie van 4-bit (16 stapjes). Stel je meet een digitale waarde van 6, wat zijn dan de mogelijke voltages die daarbij horen? Wat is dan de nauwkeurigheid?</li> <li>Zet het digitale signaal op een resolutie van 6-bit (64 stapjes). Stel je meet een digitale waarde van 28, wat zijn dan de mogelijke voltages die daarbij horen? Wat is dan de nauwkeurigheid?</li> <li>Zet het digitale signaal op een resolutie van 10-bit (1024 stapjes). Stel je meet een digitale waarde van 768, wat zijn dan de mogelijke voltages die daarbij horen? Wat is dan de nauwkeurigheid?</li> </ol> <p>Je ziet dat naarmate het aantal bits omhoog gaat de resolutie beter wordt en daarmee ook de nauwkeurigheid. </p> <p>Projecttraject</p> <ul> <li> ADC resolutie</li> <li> ADC conversie</li> </ul> <p>De conversie van een analoog signaal naar een digitaal signaal (en andersom!) is de reden dat de spanningen die je kiest en de metingen die je doet niet alle mogelijke waardes kunnen aannemen, maar stapjes maken.</p> <p></p> <p>De omzetting van een analoog signaal naar een digitaal signaal gebeurt als volgt. De ADC (analog-to-digital converter) in dit voorbeeld ondersteunt 16 niveaus (4-bits) in een bereik van 0 V tot 3.3 V (groen gearceerd). Lagere of hogere spanningen kunnen niet gemeten worden (rood gearceerd). Op gezette tijden wordt een meting gedaan (rode punten), waarbij de uitkomst van de meting het discrete niveau is dat het dichtst bij de analoge waarde ligt. Als het signaal te groot wordt kan de ADC als het ware vastlopen op het hoogste niveau. In de rechterflank is waar te nemen dat als het analoge signaal langzaam verandert, het digitale signaal duidelijk sprongsgewijs verandert. Hoe meer niveau's een ADC heeft en hoe vaker het signaal bemonsterd kan worden, hoe nauwkeuriger het digitale signaal het analoge signaal benadert.</p> <p></p> <p>De digitale metingen die je programma krijgt van de ADC is hierboven weergegeven. De onzekerheid is gelijk aan de halve afstand tot het volgende niveau. In lichtgrijs zie je het oorspronkelijke analoge signaal. De meting benadert het signaal dus maar gedeeltelijk. </p> <p>De Arduino die je gebruikt heeft een bereik van 0 V tot 3.3 V en \u2014 in tegenstelling tot het voorbeeld hierboven \u2014 een resolutie van 10 bits, dus $2^{10} = 1024$ niveaus. Als je een experiment ontwerpt is het van belang te weten dat je nooit kunt meten met een nauwkeurigheid kleiner dan de stapgrootte. Voor het experiment dat je gaat uitvoeren is deze resolutie prima.</p> <p>ADC conversie</p> opdrachtcodecheck <p>Je hebt gezien dat de Arduino werkt met getallen van 0 tot en met 1023 \u00e9n dat de Arduino een bereik heeft van 0 V tot 3.3 V. Je schrijft de formule op om een ADC waarde naar een spanning in Volt om te rekenen en omgekeerd. Je controleert of je formules logische antwoorden geven door de spanning te berekenen die hoort bij een ADC waarde van 700. Ook bereken je de ADC waarde behorende bij 2.28 V. </p> <p>Pseudo-code <pre><code># raw_value to voltage\n# voltage = something with raw_value\n\n# voltage to raw_value\n# raw_value = something with voltage\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Een ADC waarde van 0 geeft een spanning van 0 V en omgekeerd.  </li> <li> Een ADC waarde van 1023 geeft een spanning van 3.3 V en omgekeerd.</li> <li> Een ADC waarde van 700 is ongeveer tweederde van 1023, dus dat moet een spanning geven in de buurt van 2.2 V.</li> <li> Een spanning van 2.28 V is ongeveer 70% van 3.3 V, dus dat moet een ADC waarde geven in de buurt van 720.</li> </ul> <p>Projecttraject:</p> <ul> <li> ADC resolutie</li> <li> ADC conversie</li> </ul> Binair Talstelsel"},{"location":"basisscript/#binair-talstelsel","title":"Binair Talstelsel","text":"<p>Wij schrijven onze getallen op in een decimaal (tientallig) talstelsel. We hebben tien verschillende cijfers (0 t/m 9) en plakken bij grotere getallen de tientallen, honderdtallen, etcetera aan elkaar. Computers werken met binaire getallen \u2014 een tweetallig talstelsel. Dat betekent dat computers het getal 0 en 1 zonder problemen kunnen opslaan, maar bij het getal 2 wordt het al lastig. Zij moeten dan al met tientallen werken en schrijven het getal 2 op als 10. Het getal 3 is dan 11. Voor het getal 4 zijn de cijfers alweer op en moet je overschakelen naar honderdtallen, dus 4 is 100, 5 is 101, enzovoorts. Zie onderstaande tabel voor nog een paar voorbeelden. </p> <p>De cijfers noem je bits en het getal 5 (101 binair) bestaat dus uit 3 bits. Als je maar 3 bits tot je beschikking hebt, kun je $2^3 = 8$ verschillende getallen opslaan, dus 0 t/m 7. Een groepje van 8 bits (256 mogelijkheden) bleek een handige hoeveelheid en kun je op computers individueel opslaan. Zo'n groepje noem je een byte. Bestanden bestaan uit bytes, kilobytes (duizend bytes), megabytes (miljoen bytes) of gigabytes (miljard bytes). Wanneer je een signaal nauwkeurig wilt verwerken met een computer dan is het belangrijk om zoveel mogelijk bits tot je beschikking te hebben. Hoe meer bits, hoe meer verschillende waardes je kunt opslaan en hoe nauwkeuriger je signaal wordt bewaard.</p> <p>Voorbeelden van het binair talstelsel:</p> decimaal getal binair getal 0 0 1 1 2 10 3 11 4 100 5 101 6 110 7 111 8 1000 9 1001 \u2026 \u2026 205 11001101"},{"location":"basisscript/#de-iu-karakteristiek-van-een-led","title":"De $I,U$-karakteristiek van een LED","text":"<p>Je hebt op de middelbare school ongetwijfeld de $I,U$-karakteristiek van een ohmse weerstand onderzocht. Je neemt een gewone weerstand en zet daar een steeds hogere spanning op. Je meet de stroomsterkte en ook die neemt toe \u2014 rechtevenredig zelfs! Door $I$ tegen $U$ uit te zetten in een grafiek en de beste lijn door je metingen te trekken vind je met de richtingsco\u00ebffici\u00ebnt de inverse van de weerstand, $R^{-1}$, zie onderstaand figuur.</p> <p></p> <p>Een LED is een lichtgevende diode \u2014 en een diode gedraagt zich heel anders. Met de schakeling die je hebt gebouwd in de opdracht Schakeling bouwen, kun je de $I,U$-karakteristiek van een LED bepalen. Voor meer informatie over de fysica achter diodes, zie de appendix Diodes.</p> <p>$I,U$-karakteristiek van een LED</p> opdrachtcheck <p></p> <p>Maak een schets van hoe je denkt dat de grafiek van de stroom $I$ tegen de spanning $U$ van een LED eruit zal zien.</p> <p>Projecttraject</p> <ul> <li> $I,U$-karakteristiek van een LED</li> <li> Arduino heeft geen stroommeter</li> <li> Arduino pinnetjes</li> <li> Arduino op breadboard</li> <li> Kanalen van de Arduino</li> </ul> <p>Arduino heeft geen stroommeter</p> opdrachtcheck <p></p> <p>Schrijf op hoe je de spanning $U$ over de LED en de stroom $I$ door de LED berekent in termen van de spanningsmeters $U_1$ en $U_2$ en de bekende weerstand $R$.</p> <p>Projecttraject</p> <ul> <li> $I,U$-karakteristiek van een LED</li> <li> Arduino heeft geen stroommeter</li> <li> Arduino pinnetjes</li> <li> Arduino op breadboard</li> <li> Kanalen van de Arduino</li> </ul> <p>Arduino pinnetjes</p> opdrachtcheck <p></p> <p>Kijk aan de onderkant van de Arduino of je de pinnetjes A0, A1, A2 en GND kan vinden.</p> Klik hier als je geen Arduino<sup>5</sup> bij de hand hebt <p> </p> <p>Projecttraject</p> <ul> <li> $I,U$-karakteristiek van een LED</li> <li> Arduino heeft geen stroommeter</li> <li> Arduino pinnetjes</li> <li> Arduino op breadboard</li> <li> Kanalen van de Arduino</li> </ul> <p>Arduino op breadboard</p> opdrachtcheck <p></p> <p>Vergelijk de schakeling op het breadboard met de theoretische schakeling. Welke lijnen in de theoretische schakeling komen overeen met de vier draadjes (rood, blauw, groen, oranje) op het breadboard?</p> <p>Projecttraject</p> <ul> <li> $I,U$-karakteristiek van een LED</li> <li> Arduino heeft geen stroommeter</li> <li> Arduino pinnetjes</li> <li> Arduino op breadboard</li> <li> Kanalen van de Arduino</li> </ul> <p>Kanalen van de Arduino</p> opdrachtcheck <p></p> <p>Bekijk de documentatie van de firmware en schrijf het commando op om de maximale uitvoerspanning op kanaal 0 te zetten. Schrijf ook de commando's op om de waardes van $U_1$ en $U_2$ uit te lezen.</p> <p>Projecttraject</p> <ul> <li> $I,U$-karakteristiek van een LED</li> <li> Arduino heeft geen stroommeter</li> <li> Arduino pinnetjes</li> <li> Arduino op breadboard</li> <li> Kanalen van de Arduino</li> </ul> <p>Pythondaq: repository</p> opdrachtcheck <p>Omdat je met een belangrijk project aan de slag gaat, namelijk een inleveropdracht, ga je gelijk goed beginnen door een repository aan te maken. </p> <ol> <li>Open Github Desktop en ga naar het dropdownmenu File. Kies hier voor <code>New repository ...</code>. Geef de repository de naam <code>pythondaq</code> en zet de repository in de map <code>ECPC</code>. De mappenstructuur ziet er dan als volgt uit:   ECPC \u251c\u2500\u2500  oefenopdrachten \u251c\u2500\u2500  pythondaq \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 \u2514\u2500\u2500 \u2022\u2022\u2022  </li> <li>Vink <code>Initialize this repository with a README</code> aan.</li> <li>Kies bij <code>Git ignore</code> voor Python.</li> <li>Open de repository <code>pythondaq</code> via GitHub Desktop. Ga hiervoor naar het dropdownmenu Repository en kies voor <code>Open in Visual Studio Code</code>.</li> <li>Nu kun je aan de slag. Vergeet tijdens het werken niet regelmatig te committen!</li> </ol> <p>Checkpunten</p> <ul> <li> De repository <code>pythondaq</code> zit in de map <code>ECPC</code>.</li> <li> In de repository <code>pythondaq</code> bevinden zich de bestanden <code>README.md</code>, <code>.gitattributes</code> en <code>.gitignore</code>.</li> <li> De repository <code>pythondaq</code> is geopend in Visual Studio Code.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <p></p> <p>Pythondaq: start script</p> opdrachtcodecheck <p>      Je maakt een bestand <code>diode_experiment.py</code> aan in de nieuwe repository  <code>pythondaq</code>, waarin je de spanning over de LED laat oplopen van nul tot de maximale waarde. Je moet hiervoor ook weer opnieuw een virtual environment aanmaken (zie opdracht Environment aanmaken). Tijdens het oplopen van de spanning over de LED lees je de verschillende spanningen uit. Je print steeds een regel met: ruwe waarde spanning over LED, voltage over LED, ruwe waarde spanning over weerstand, voltage over weerstand.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u2514\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>diode_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code diode_experiment.py<pre><code># connect to Arduino\n#\n# set output voltage from 0 to max\n#   measure voltages\n#   calculate voltage LED \n#   calculate voltage resistor\n#   print LED: raw_voltage_LED (voltage_LED V) Resistor: raw_voltage_resistor (voltage_resistor V)\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Je hebt een virtual environment aangemaakt en die is goed geactiveerd (er staat <code>(pythondaq)</code> aan het begin van de prompt).</li> <li> Je hebt alle benodigde packages ge\u00efnstalleerd in je virtual environment.</li> <li> Je laat de spanning oplopen van nul tot de maximale waarde.</li> <li> De LED licht vertraagd op en gaat dus steeds feller branden. </li> <li> Commit! </li> <li> De ruwe waardes over de LED en de weerstand zijn zoals verwacht.</li> <li> Commit! </li> <li> De omrekening van ruwe waardes naar voltages levert uitkomsten op die je kunt verwachten.</li> <li> Commit! </li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <p>Je kunt de geprinte meetgegevens kopi\u00ebren en plakken naar een tekstbestand, spreadsheetprogramma, Python notebook of iets dergelijks. Maar dat is wel veel werk, zeker als je metingen wilt herhalen. Op dit moment heb je ook alleen nog maar ruwe metingen. En je gaat nog voorbij aan het feit dat je graag de stroomsterkte $I$ door de LED wilt uitzetten tegen de spanning $U$ over de LED.</p> <p>Info</p> <p>In de volgende opdracht ga je een grafiek maken. Installeer Matplotlib in de virtual environment.  Terminal<pre><code>uv pip install matplotlib\n</code></pre></p> <p>Pythondaq: quick 'n dirty meting</p> opdrachtcodecheck <p>Je code berekent de spanning over en de stroomsterkte door de LED terwijl de spanning over het circuit oploopt van nul tot de maximale waarde. De resultaten worden geprint \u00e9n in een grafiek weergegeven. Aan het einde van alle metingen wordt de LED uitgezet.</p> <p>Pseudo-code diode_experiment.py<pre><code># connect to Arduino\n#\n# set output voltage from 0 to max\n#   measure voltages\n#   calculate voltage LED\n#   calculate current LED\n#   print voltage: voltage_LED V (raw_voltage_LED) current: current_LED A\n#\n# turn LED off\n# plot current_LED vs voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Je laat de spanning oplopen van nul tot de maximale waarde.</li> <li> De spanning $U$ over de LED wordt berekend.</li> <li> De stroom $I$ door de LED wordt berekend. </li> <li> De spanning $U$ en de stroom $I$ worden geprint in de terminal. </li> <li> De waardes zijn fysisch correct.</li> <li> De verschillende waardes voor de spanning worden in een lijst gezet.</li> <li> De verschillende waardes voor de stroom worden in een lijst gezet.</li> <li> De stroomsterkte $I$ wordt tegen de spanning $U$ uitgezet in een grafiek.</li> <li> Je vergelijkt het resultaat met een buurmens. Je bespreekt of de verkregen grafiek fysisch correct is. </li> <li> De LED wordt uitgezet na de meting.</li> <li> Tussendoor heb je gecommit!</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <p>Omdat je never nooit niet je conclusies gaat baseren op een enkele meetserie ga je de meting herhalen en foutenvlaggen toevoegen. Je moet misschien wel weer even hard nadenken over hoe je deze foutenvlaggen bepaald. Pak daarom eerst pen en papier (voordat je verder code gaat toevoegen), stoot je buurmens aan en ga samen nadenken over hoe jullie in dit experiment de onzekerheid kunnen bepalen.</p> <p>Pythondaq: onzekerheid</p> opdrachtcheck <p></p> <p>Bekijk bovenstaande video, eventueel een paar keer. In deze video wordt een meting van de spanning $x_n$ keer herhaald. De groene rechthoek geeft de onzekerheid op een individuele meting weer. Het gemiddelde van alle metingen wordt weergegeven met een roze lijn. De roze rechthoek geeft de onzekerheid op het gemiddelde weer.  </p> <ol> <li>Wat gebeurt er met de onzekerheid op een individuele meting als je de meting vaker herhaalt?</li> <li>Wat gebeurt er met de onzekerheid op het gemiddelde als je een meting vaker herhaalt? </li> <li>Heb je voor jouw experiment straks de onzekerheid op een individuele meting nodig? Of de onzekerheid op het gemiddelde? Hoe bepaal je deze onzekerheid?</li> </ol> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <p>Pythondaq: schildpad of raket?</p> opdrachtcheck <p>In het experiment ga je straks de metingen een aantal keer herhalen. Je kunt dan op twee manieren het gemiddelde van de benodigde grootheden bepalen en de bijbehorende onzekerheden. </p> <ol> <li>Je kunt dit stap voor stap doen, als een schildpad. Bij elke waarde van $U_0$ meet je een aantal keer de waardes van $U_1$ en $U_2$, waarna je een gemiddelde en de bijbehorende onzekerheid berekent. Daarna doe je hetzelfde voor de volgende waarde van $U_0$. </li> <li>Je kunt ook eerst voor het hele bereik van $U_0$ de waardes van $U_1$ en $U_2$ bepalen, als een raket. Dit herhaal je daarna een aantal keer. Pas nadat je \u00e1lle metingen gedaan hebt, ga je een gemiddelde en de bijbehorende onderzekerheid berekenen.</li> </ol> <p>Bespreek met je buurmens de voor- en nadelen van beide manieren. Maak hierin onderscheid tussen het experimentele gebied en het programmeergebied.</p> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <p>Pythondaq: herhaalmetingen</p> opdrachtcodecheck <p>Je gaat nu de code zo aanpassen dat je daadwerkelijk iets kunt zeggen over de onzekerheid op de spanning over de LED en de stroom door de LED. Dit doe je door een meting meerdere keren te herhalen. Je kijkt eerst naar de opbouw van de code en maakt aantekeningen over wat er waar en hoe in de code aangepast moet worden. Daarna kijk je naar je repository <code>pythondaq</code> en controleer je dat de nu-nog-werkende-code gecommit is. Vervolgens ga je stap voor stap \u2014 en commit na commit \u2014 de code aanpassen. Als je klaar bent, run je <code>diode_experiment.py</code> met het aantal herhaalmetingen op 3 en zie je in de grafiek foutenvlaggen op de metingen voor de stroom en de spanning staan. Je kijkt op het beeldscherm van je buurmens en ziet daar ook foutenvlaggen verschijnen. Met een grijs kijken jullie elkaar aan en geven jullie elkaar een high five </p> <p>Pseudo-code diode_experiment.py<pre><code># connect to Arduino\n#\n# set output voltage from 0 to max \n#   set number of repeated measurements\n#       measure voltages\n#       calculate voltage LED\n#       calculate current LED       \n#   calculate average voltage LED and uncertainty\n#   calculate average current LED and uncertainty\n#   print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#\n# turn LED off\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Er worden herhaalmetingen gedaan.</li> <li> De gemiddelde spanning $U_{avg}$ over de LED wordt berekend.</li> <li> De bijbehorende onzekerheid wordt correct bepaald.</li> <li> De gemiddelde stroom $I_{avg}$ door de LED wordt berekend. </li> <li> De bijbehorende onzekerheid wordt correct bepaald. </li> <li> De gemiddelde spanning $U_{avg}$ en de gemiddelde stroom $I_{avg}$ worden met de bijbehorende onzekerheden geprint in de terminal. </li> <li> De gemiddelde stroom $I_{avg}$ wordt tegen de gemiddelde spanning $U_{avg}$ uitgezet in een grafiek.</li> <li> Op de datapunten zijn foutenvlaggen zichtbaar.</li> <li> De foutenvlaggen zijn gekoppeld aan de juiste grootheid.</li> <li> De LED wordt uitgezet na de meting.</li> <li> Tussendoor heb je gecommit!</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul>"},{"location":"basisscript/#bewaren-van-meetgegevens","title":"Bewaren van meetgegevens","text":"<p>Het is fijn dat je script de meetgegevens op het scherm kan printen en er een grafiek van maakt, maar als je echt bezig bent met een onderzoek is een grafiek alleen niet voldoende. Je wilt dat de data bewaard blijft, zodat je die later nog kunt gebruiken voor nieuwe analyses. Ook is het zo dat data steeds vaker beschikbaar moet zijn voor andere wetenschappers die jouw onderzoek willen controleren. Steeds meer wetenschappelijke tijdschriften vragen auteurs niet alleen hun grafieken, maar ook hun onderliggende data beschikbaar te maken en te publiceren. Op die manier is het veel moeilijker om fraude te plegen; iets dat in de wetenschap helaas soms nog voor komt.</p> <p>Er zijn ontzettend veel verschillende bestandsformaten waarin je data kunt bewaren. Er zijn grofweg twee categorie\u00ebn: tekstbestanden en binaire bestanden. De eerste zijn te lezen met ieder willekeurig programma. Sommige zijn heel eenvoudig (bijvoorbeeld CSV), andere kunnen complexe datastructuren en extra informatie opslaan (bijvoorbeeld JSON en XML). Binaire bestanden bevatten alle mogelijke karakters \u2014 niet alleen letters, cijfers, leestekens, maar ook stuurcodes zoals carriage return en de line feed, oorspronkelijk opdrachten voor bijvoorbeeld printers. Ze hebben vaak een strak formaat: zoveel bytes voor dit stukje informatie, zoveel bytes voor dat stukje, enzovoorts. Met binaire karakters hoef je je dus niet te beperken tot letters, cijfers en leestekens en kunnen de bestanden wat kleiner zijn. Ook zorgen de vaste afspraken ervoor dat de lees- en schrijfroutines eenvoudiger kunnen zijn. Getallen worden in het interne geheugen van de computers ook binair opgeslagen dus het is vaak copy/paste vanuit of naar het bestand. Wel leiden kleine fouten vaak tot onbruikbare bestanden. Voor grote databestanden wordt vrijwel altijd gekozen voor een binair formaat, of het nou gaat om audio/video, databases of klimaatmodellen. Het uitwisselen van kleinere bestanden gebeurt echter vaak in een tekstformaat.</p>"},{"location":"basisscript/#comma-separated-values-csv","title":"Comma-separated values (CSV)","text":"<p>Het CSV-bestand is het werkpaard van de wetenschap. Als je data wilt overzetten van het ene naar het andere programma of wanneer je wetenschappelijke gegevens van een website wilt downloaden, dan is het CSV-bestand vaak de beste keuze. Het formaat bestaat uit kolommen met getallen, gescheiden door een komma. De eerste regels kunnen commentaar (bijvoorbeeld uitleg over de kolommen) en de namen van de kolommen bevatten. Een voorbeeld van een CSV-bestand is hieronder gegeven. In dit voorbeeld wordt de afstand $s$ van een vallend voorwerp gedurende 10 s opgeslagen, welke gegeven wordt door $s = \\frac{1}{2} g t^2$. Het CSV-bestand heeft kolommen $t$ en $s$. De getallen hebben een punt als decimaal scheidingsteken en de komma wordt gebruikt om de kolommen te scheiden.</p> <pre><code>t,s\n0.0,0.0\n1.0,4.9\n2.0,19.6\n3.0,44.1\n4.0,78.4\n5.0,122.50000000000001\n6.0,176.4\n7.0,240.10000000000002\n8.0,313.6\n9.0,396.90000000000003\n10.0,490.00000000000006\n</code></pre> <p>Je kunt CSV-bestanden schrijven en lezen met de modules <code>csv</code>, <code>numpy</code> of <code>pandas</code>. De eerste is altijd meegeleverd met Python en is speciaal geschreven voor het bestandsformaat,<sup>10</sup> maar NumPy<sup>11</sup><sup>12</sup> en Pandas<sup>13</sup><sup>14</sup> bevatten veel meer functionaliteiten op het gebied van wiskunde en data-analyse. Als je deze modules toch al gebruikt, hoef je niet te kiezen voor de kale <code>csv</code>-module.</p>"},{"location":"basisscript/#de-functie-zip","title":"De functie <code>zip()</code>","text":"<p>Het viel je misschien op dat in bovenstaand CSV-bestand op iedere regel een waarde voor de tijd en voor de afstand staat. Als je een lijst met tijden en een lijst met afstanden hebt dan bevat de eerste regel het eerste element uit beide lijsten, de tweede regel het tweede element, etcetera. Je kunt een <code>for</code>-loop schrijven die Python's indexnotatie gebruikt om de twee lijsten om te zetten naar een CSV-formaat: <code>t[i]</code>, <code>s[i]</code>. Het kan \u00f3\u00f3k \u2014 makkelijker \u2014 met de <code>zip()</code>-functie. Hieronder vind je een voorbeeld waarin beide methodes gebruikt worden. In het voorbeeld wordt uitgegaan van een lijst <code>A</code> en een lijst <code>B</code><sup>6</sup>.</p> with_zip.pywith_indexing.py <p> with_zip.py <pre><code>A = [1, 2, 3, 4]\nB = [1, 4, 9, 16]\n\nfor a, b in zip(A, B):\n    print(a, b)\n</code></pre> <pre>\n<code>(ECPC) &gt; python with_zip.py\n1 1\n2 4\n3 9\n4 16\n</code></pre></p> <p> with_indexing.py <pre><code>A = [1, 2, 3, 4]\nB = [1, 4, 9, 16]\n\nfor i in range(len(A)):\n    print(A[i], B[i])\n</code></pre> <pre>\n<code>(ECPC) &gt; python with_indexing.py\n1 1\n2 4\n3 9\n4 16\n</code></pre></p> <p>Vergelijk beide methodes goed. In het geval van <code>zip()</code> hoef je niet de lengte van de lijst op te zoeken en krijg je meteen de losse elementen zonder dat je ze zelf uit de lijst hoeft te plukken met indexnotatie.</p> <p>Oefenen met <code>zip()</code></p> opdrachtcodecheck <p>Je hebt een lijst met krachten en een lijst met afstanden, zie het tabblad code. Loop over de lijsten heen en print voor iedere iteratie de kracht $F$, de afstand $s$ en de arbeid $W$. Maak hierbij gebruik van de <code>zip</code>-functie.</p> <p>Pseudo-code <pre><code>F = [1.2, 1.8, 2.4, 2.7, 3.1] # N\ns = [0.3, 0.4, 0.6, 0.8, 1.0] # m \n\n# repeat\n#   print F, s, W\n</code></pre></p> <p>Checkpunten</p> <ul> <li> De <code>for</code>-loop maakt gebruik van <code>zip()</code> om de elementen uit de lijst op te vragen.</li> <li> De variabelen hebben logische namen (en dus niet <code>a</code> en <code>b</code>). </li> <li> De gegeven arbeid is correct berekend.</li> </ul> <p>Projecttraject</p> <ul> <li> Oefenen met zip</li> </ul>"},{"location":"basisscript/#het-gebruik-van-de-csv-module","title":"Het gebruik van de <code>csv</code>-module","text":"<p>Wanneer je de <code>csv</code>-module wilt gebruiken moet je \u00e9\u00e9rst een bestand openen om in te schrijven, daarna een writer object aanmaken en dat object daarna gebruiken om regels te schrijven. Als laatste moet het bestand netjes afgesloten worden, zodat het bestand ook echt naar de schijf weggeschreven wordt. Het openen en sluiten van een bestand kun je Python het beste laten doen met het <code>with</code>-statement:<sup>7</sup></p> <pre><code>with open('metingen.csv', 'w', newline='') as csvfile:\n    # csvfile is nu een bestandsobject\n    ...\n    # na dit blok sluit Python automatisch het bestand\n</code></pre> <p>Bij <code>open()</code> geef je eerst de naam van het bestand, dan <code>'w'</code> om aan te geven dat het bestand writeable moet zijn (gebruik <code>'r'</code> om te lezen) en <code>newline=''</code> om Python niet zelf regeleindes te laten schrijven \u2014 dat doet de <code>csv</code>-module. Op de volgende manier schrijf je dan de CSV-data weg:</p> <p><pre><code>import csv\n\nwith open('metingen.csv', 'w', newline='') as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(['t', 's'])\n    writer.writerow([0.0, 0.0])\n    writer.writerow([1.0, 4.9])\n    writer.writerow([2.0, 19.6])\n    ...\n</code></pre> Je kunt het wegschrijven van de regels natuurlijk vervangen door een <code>for</code>-loop.</p> <p>Pythondaq: CSV</p> opdrachtcodecheck <p>Je breidt je code verder uit. De metingen worden nu ook als CSV-bestand weggeschreven. In de code wordt hiervoor gebruik gemaakt van de <code>zip</code>-functie en de <code>csv</code>-module.</p> <p>Pseudo-code diode_experiment.py<pre><code># connect to Arduino\n#\n# set output voltage from 0 to max\n#   set number of repeated measurements\n#       measure voltages\n#       calculate voltage LED\n#       calculate current LED       \n#   calculate average voltage LED and uncertainty\n#   calculate average current LED and uncertainty\n#   print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#\n# turn LED off\n# create csv-file\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Je script heeft nog steeds dezelfde functionaliteiten als bij de opdrachten Pythondaq: quick 'n dirty meting en Pythondaq: herhaalmetingen. </li> <li> Je loopt over de verschillende lijsten heen met behulp van de <code>zip</code>-functie.</li> <li> Het CSV-bestand bevat alle belangrijke data.</li> <li> De waardes in het CSV-bestand komen overeen met de verwachte waardes.</li> <li> Het CSV-bestand heeft op de eerste regel informatie over de kolommen staan (denk aan: grootheid en eenheid).</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: repository</li> <li> Pythondaq: start script</li> <li> Pythondaq: quick 'n dirty meting</li> <li> Pythondaq: onzekerheid</li> <li> Pythondaq: schildpad of raket?</li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: CSV</li> </ul> <code>Git ignore</code> <p>Het kan wenselijk zijn om niet alle bestanden mee te nemen voor versiebeheer in je repository. Soms wil je een specifiek bestand uitsluiten en soms wil je een bepaald bestandstype uitsluiten. Om GitHub te laten weten welke bestanden niet gecommit hoeven te worden, is er een bestand <code>.gitignore</code>. Let op de punt voor de bestandsnaam: dit betekent dat het om een verborgen bestand gaat en mogelijk zie je het daarom niet in je repository staan.</p> CSV-bestanden uitsluiten van versiebeheer <p>Stel je wilt alle CSV-bestanden uitsluiten van versiebeheer, dan kun je dat als volgt doen:</p> <ol> <li>Ga naar GitHub Desktop.</li> <li>Ga naar het tabblad Changes. </li> <li>Rechtermuisklik op het bestand wat je wilt negeren (ervan uitgaande dat je dit bestand nog niet hebt gecommit).</li> <li>Maak een keuze tussen <code>Ignore file</code> of <code>Ignore all .csv files</code>.</li> <li>Commit.</li> </ol> CSV bestandsnaam <p>Pas de code zodanig aan dat een CSV-bestand nooit wordt overschreven. Je kunt bijvoorbeeld controleren of het bestand al bestaat en aan de bestandsnaam een oplopend getal toevoegen (<code>data-001.csv</code>, <code>data-002.csv</code>, etcetera), net zo lang totdat je uitkomt bij een bestandsnaam die nog niet bestaat. Wees er zeker van dat je programma ook echt geen data overschrijft.</p> HDF5, PyTables <ol> <li> <p>Een vallende bal is een continu proces. De bal heeft op elk willekeurig moment een positie. Je zou de positie kunnen meten op het tijdstip $t$ = 2.0 s, maar ook op $t$ = 2.1, 2.01, 2.001 of 2.0001 s. Ook kun je de positie net zo nauwkeurig bepalen als je wilt.<sup>2</sup> \u21a9</p> </li> <li> <p>Uiteraard afhankelijk van de nauwkeurigheid van je meetinstrument.\u00a0\u21a9</p> </li> <li> <p>De natuur is analoog,<sup>4</sup> maar moderne computers zijn digitaal en dus discreet. Als je een foto op je computer te ver inzoomt zie je blokjes. Je kunt verder inzoomen, maar je gaat niet meer detail zien. De hoeveelheid informatie is beperkt.\u00a0\u21a9</p> </li> <li> <p>Totdat je het domein van de kwantummechanica betreedt, dan blijkt de natuur ook een discrete kant te hebben.\u00a0\u21a9</p> </li> <li> <p>Dit model bevat een 3D model die is gecre\u00eberd door AppliedSBC en is gedeeld onder CC-BY-SA licentie. Het originele model is te vinden via Arduino Nano 33 IoT. Het model is voorzien van een Arduino texture. Dit 3D model heeft een CC-BY-SA licentie.\u00a0\u21a9</p> </li> <li> <p>Je kunt net zoveel lijsten in <code>zip()</code> gooien als je wilt: <code>for a, b, c, d, e in zip(A, B, C, D, E)</code> is bijvoorbeeld geen probleem.\u00a0\u21a9</p> </li> <li> <p>Hier is <code>open()</code> een zogeheten context manager: een functie die je kunt gebruiken met een <code>with</code>-statement en dat bij de start iets doet \u2014 hier een bestand openen \u2014 en bij het eind iets doet \u2014 hier het bestand weer netjes afsluiten. Je kunt zelf ook context managers schrijven, als je wilt.\u00a0\u21a9</p> </li> <li> <p>Hierarchical Data Format Version 5 is in gebruik bij bijvoorbeeld de LOFAR radiotelescoop, het IceCube neutrino-observatorium en de LIGO zwaartekrachtsgolvendetector.\u00a0\u21a9</p> </li> <li> <p>Lees bijvoorbeeld deze korte blogpost over het gebruik van HDF5.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. Csv \u2013 csv file reading and writing. URL: https://docs.python.org/3/library/csv.html.\u00a0\u21a9</p> </li> <li> <p>The NumPy Development Team. Numpy \u2013 the fundamental package for scientific computing with python. URL: https://numpy.org.\u00a0\u21a9</p> </li> <li> <p>Charles R. Harris, K. Jarrod Millman, St'efan J. van der Walt, Ralf Gommers, Pauli Virtanen, David Cournapeau, Eric Wieser, Julian Taylor, Sebastian Berg, Nathaniel J. Smith, Robert Kern, Matti Picus, Stephan Hoyer, Marten H. van Kerkwijk, Matthew Brett, Allan Haldane, Jaime Fern'andez del R'\u0131o, Mark Wiebe, Pearu Peterson, Pierre G'erard-Marchant, Kevin Sheppard, Tyler Reddy, Warren Weckesser, Hameer Abbasi, Christoph Gohlke, and Travis E. Oliphant. Array programming with NumPy. Nature, 585(7825):357\u2013362, September 2020. URL: https://doi.org/10.1038/s41586-020-2649-2, doi:10.1038/s41586-020-2649-2.\u00a0\u21a9</p> </li> <li> <p>The pandas development team. Pandas-dev/pandas: pandas 1.0.5. June 2020. URL: https://doi.org/10.5281/zenodo.3898987, doi:10.5281/zenodo.3898987.\u00a0\u21a9</p> </li> <li> <p>Wes McKinney. Data Structures for Statistical Computing in Python. In St\u00e9fan van der Walt and Jarrod Millman, editors, Proceedings of the 9th Python in Science Conference, 56 \u2013 61. 2010. doi:10.25080/Majora-92bf1922-00a.\u00a0\u21a9</p> </li> <li> <p>The HDF Group. The hdf5 library and file format. URL: https://www.hdfgroup.org/solutions/hdf5/.\u00a0\u21a9</p> </li> <li> <p>Ivan Vilata Francesc Alted and others. PyTables: hierarchical datasets in Python. URL: http://www.pytables.org/.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"basisscript/#hdf5-pytables","title":"HDF5, PyTables","text":"<p>Een populair binair formaat in de wetenschappelijke wereld is HDF5.<sup>8</sup> <sup>15</sup> Je kunt hiermee verschillende datasets bewaren in \u00e9\u00e9n bestand. Je kunt een soort boomstructuur aanbrengen en zo verschillende datasets groeperen. Daarnaast kun je er ook nog extra informatie (metadata) aanhangen, zoals de datum van de meting, een beschrijving van de condities, etcetera. Je kunt een meetserie opslaan als reeks die in \u00e9\u00e9n keer in en uit het bestand wordt geladen, maar ook als tabel. Die laatste biedt de mogelijkheid om \u2014 net als in een database \u2014 data te selecteren en alleen die data in te laden uit het bestand. Op die manier is het mogelijk om met datasets te werken die groter zijn dan het geheugen van je computer.<sup>9</sup> Meer informatie lees je in de tutorial van PyTables.<sup>16</sup></p> <p>PyTables<sup>16</sup> is een Python bibliotheek die het werken met HDF5-bestanden makkelijker maakt. Er zijn uiteraard functies om de bestanden aan te maken en uit te lezen, maar ook om queries uit te voeren. Pandas kan \u2014 via PyTables \u2014 ook werken met HDF5-bestanden. </p> <p>HDF5 tutorial</p> <p>Download de HDF5 tutorial. Open de tutorial in Visual Studio Code en bestudeer de stappen die daar staan beschreven nauwkeurig.</p> <p>PyTables</p> <p>Pas je script aan zodat de meetserie van de LED wordt opgeslagen in een HDF5-bestand. Vraag hulp als je uitleg wilt over wat een <code>UInt16</code> voor een ding is. Gebruik \u00e9\u00e9n bestand en maak daarin een nieuwe dataset voor iedere meetserie. Bewaar ook wat metadata (bijvoorbeeld tijdstip van de meting). Iedere keer dat je je script runt wordt er aan hetzelfde databestand een nieuwe dataset toegevoegd.</p>"},{"location":"benodigdheden/","title":"Lijst van benodigdheden","text":"<p>We hebben voor deze cursus de volgende onderdelen gebruikt:</p> <ul> <li>Arduino Nano 33 IoT</li> <li>Firmware voor in de Arduino: visa_firmware.ino</li> <li>micro-USB kabel</li> <li>400-punt breadboard</li> <li>jumperwires (M/M)</li> <li>1x LED rood</li> <li>1x LED blauw</li> <li>1x weerstand 220\u03a9</li> </ul> <p>Voor eindfeest zonnecel:</p> <ul> <li>1x weerstand 1k\u03a9</li> <li>1x weerstand 4,7\u03a9</li> <li>1x weerstand 1M\u03a9</li> <li>1x weerstand 2M\u03a9</li> <li>1x Seeed Studio 0.5W zonnepaneel</li> <li>1x JST 2-pin connector kabeltje</li> </ul> <p>Voor eindfeest Morse:</p> <ul> <li>1x LDR-weerstand</li> </ul> <p>Voor eindfeest afstandsensor:</p> <ul> <li>Seeed Studio Grove Ultrasonic Ranger</li> </ul>"},{"location":"black/","title":"Black","text":"<p>Code wordt veel vaker gelezen dan geschreven, is een veel geciteerd gezegde onder programmeurs. Je schrijft je code en zit vervolgens uren te puzzelen om een fout te vinden of hoe je de code het beste kunt uitbreiden. Je zoekt op internet naar voorbeeldcode, je helpt een medestudent of vraagt die om hulp. Heel vaak dus lees je niet je eigen code, maar die van iemand anders. Is dat relevant? Ja! Want die code ziet er anders uit. Iedereen programmeert toch op zijn eigen manier. Het scheelt enorm als de code er tenminste grotendeels hetzelfde uitziet. Het kost je dan minder energie om te lezen. Daarom ook dat de artikelen in wetenschappelijke tijdschriften bijvoorbeeld er allemaal hetzelfde uitzien en de auteur niet de vrijheid krijgt om z\u00e9lf lettertypes te kiezen. Net zo goed hebben grote organisaties vaak hun eigen coding style ontwikkeld waar alle werknemers zich zoveel mogelijk aan moeten houden.</p> <p>Python heeft een eigen style guide die je vooral eens door moet lezen.<sup>1</sup> Google heeft ook een hele mooie, met duidelijke voorbeelden.<sup>2</sup></p> <p>Fijn dat je code consistenter wordt, maar het moet nu ook weer niet zo zijn dat je uren kwijt bent met de style guides bestuderen of twijfelen waar je een regel code precies moet afbreken. Wel of niet een enter? Om daar vanaf te zijn zijn er verschillende pakketten die je code automatisch aanpassen aan de standaard. Als je de instelling Editor: Format On Save aan zet (staat standaard uit) dan wordt je code aangepast zodra je je bestand opslaat. Black is zo'n formatter en heeft een `eigen mening'. Als je je daar bij neerlegt hoef je bijna niet meer na te denken over hoe je je code precies vormgeeft. De Black website zegt<sup>3</sup>:</p> <p>   By using Black, you agree to cede control over minutiae of hand-formatting. In return, Black gives you speed, determinism, and freedom from pycodestyle nagging about formatting. You will save time and mental energy for more important matters. </p> <p>Black is tegenwoordig immens populair en in Visual Studio Code kun je hem gebruiken door de Black Formatter-extensie van Microsoft te installeren. De code in deze handleiding is geformat met Black. In Visual Studio Code, ga naar File en dan naar Preferences &gt; Settings &gt; Editor: Format On Save en vink die aan. De eerste keer dat je je bestand opslaat zal hij vragen of hij Black moet gebruiken, daarna wordt je code altijd netjes gemaakt zodra je je Pythonbestand bewaart.</p> <p>De volgende code:</p> <pre><code>s1 = 'Hello'\ns2 = \"World\"\nvalues = [1,2,3,4,5]\n\nf = a * x ** 2 + b * x + c\ng = a*x +b\nh = A*np.sin(2*pi*f*t+phi) + A2*np.sin(2*pi*f2*t+phi2) + A3*np.sin(2*pi*f3*t+phi3)\n</code></pre> <p>wordt door Black omgezet in:</p> <pre><code>s1 = \"Hello\"\ns2 = \"World\"\nvalues = [1, 2, 3, 4, 5]\n\nf = a * x**2 + b * x + c\ng = a * x + b\nh = (\n    A * np.sin(2 * pi * f * t + phi)\n    + A2 * np.sin(2 * pi * f2 * t + phi2)\n    + A3 * np.sin(2 * pi * f3 * t + phi3)\n)\n</code></pre> <ol> <li> <p>Guide van Rossum. Pep 8 \u2013 style guide for python code. URL: https://www.python.org/dev/peps/pep-0008/.\u00a0\u21a9</p> </li> <li> <p>Google. Google python style guide. URL: https://google.github.io/styleguide/pyguide.html.\u00a0\u21a9</p> </li> <li> <p>\u0141ukasz Langa. Black, the uncompromising code formatter. URL: https://black.readthedocs.io/en/stable/.\u00a0\u21a9</p> </li> </ol>"},{"location":"cheatsheets/","title":"Cheatsheets","text":"Conda environment aanmaken <pre><code>conda create --name NAME PACKAGES\n</code></pre> environment activeren <pre><code>conda activate NAME\n</code></pre> pakket installeren <pre><code>(NAME) &gt; conda install PACKAGE\n</code></pre> GitHub Lege repository aanmaken <ol> <li>GitHub Desktop: File &gt; New repository</li> <li>Kies <code>NAME</code> en locatie (let op! de project map mag niet in een andere repository staan!)</li> <li>Vink <code>Initialize this repository with a README</code> aan</li> <li><code>Git ignore</code>: \"Python\"</li> <li>GitHub Desktop: Repository &gt; Open in Visual Studio Code</li> </ol> Van bestaande map repository maken <ol> <li>GitHub Desktop: File &gt; Add repository</li> <li>Kies locatie van <code>projectmap</code> (let op! de project map mag niet in een andere repository staan!)</li> <li>Druk op de blauwe tekst <code>Create repository</code>.</li> <li>Vink <code>Initialize this repository with a README</code> aan.</li> <li>Kies bij <code>Git ignore</code> voor \"Python\".</li> <li>Bevestig met de blauwe knop <code>Create Repository</code>.</li> <li>Ga naar Repository &gt; Open in Visual Studio Code (of druk op Ctrl+Shift+A ) en ga aan de slag.</li> </ol> Poetry Nieuw Poetry project aanmaken <pre><code>poetry new --src NAME\n</code></pre> Poetry toevoegen aan bestaand project <pre><code>poetry init --no-interaction\n</code></pre> Poetry project installeren <pre><code>poetry install\n</code></pre> Dependencies toevoegen <pre><code>poetry add PACKAGE\n</code></pre> Dependencies verwijderen <pre><code>poetry remove PACKAGE\n</code></pre> commando toevoegen <ol> <li>Voeg in je <code>pyproject.toml</code> een extra kopje toe: <pre><code>[tool.poetry.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre></li> </ol>"},{"location":"classes/","title":"Classes","text":"<p>Voor een snelle meting is het script dat je geschreven hebt bij opdracht Pythondaq: quick 'n dirty meting, opdracht Pythondaq: herhaalmetingen en opdracht Pythondaq: CSV prima! Maar als de meetapparatuur ingewikkelder wordt (meer verschillende commando's) of je wilt meer aanpassingen doen, dan is het wel lastig dat je op allerlei plekken de commando's opnieuw moet programmeren \u2014 en eerst moet opzoeken. Als je een nieuw script schrijft moet je opnieuw goed opletten dat je de goede terminator characters gebruikt, etc. Het is wat werk, maar toch heel handig, om je code op te splitsen en een class te schrijven.</p> <p>Een class is eigenlijk een groep functies die je bij elkaar pakt en die met elkaar gegevens kunnen delen. Zodra een programma wat complexer wordt merk je dat het fijn kan zijn om variabelen op te sluiten in ge\u00efsoleerde omgevingen. We gaan eerst kijken hoe we een class gebruiken met behulp van de class <code>Turtle</code>. Met deze class kan je een tekening maken in Python, met behulp van functies geef je aan hoe de pen over het papier moet bewegen.</p>"},{"location":"classes/#aanroepen-van-een-class","title":"Aanroepen van een class","text":"<p>Het aanroepen van een class lijkt veel op het aanroepen van een functie:</p> <pre>\n<code>result = calculate_squares_up_to(5)\n</code></pre> <pre>\n<code>master_oogway = Turtle(\"turtle\") \n</code></pre> <p>Stel je hebt de functie <code>def calculate_squares_up_to(max_number):</code>. Dan roep je die aan met <code>result = calculate_squares_up_to(5)</code>. Hierbij is <code>calculate_squares_up_to</code> de naam van de functie en <code>result</code> de variabele waar de uitkomst heen gaat. Achter de naam van de functie, <code>calculate_squares_up_to</code>, komen tussen ronde haakjes de variabelen te staan die worden meegegeven aan de functie, in dit geval <code>5</code>. Hierdoor wordt het kwadraat tot het getal 5 uitgerekend.</p> <p>Bij het aanroepen van een class doe je iets soortgelijks. In de variabele <code>master_oogway</code> gaat de uitkomst van de class, dat is in dit geval een collectie van functies \u2014 de zogeheten methods van de class \u2014 (en variabelen). De variabele <code>master_oogway</code> noem je een instance van de class <code>Turtle</code>. Achter de naam van de class, <code>Turtle</code>, komen tussen ronde haakjes de variabelen te staan die worden meegegeven aan class, in dit geval <code>\"turtle\"</code>. Hierdoor heeft de pen de vorm van een schildpad in plaats van een pijl.</p> Meerdere instances <p>Net zoals je een functie vaker kunt aanroepen, kan je ook meerdere instances van een class aanmaken. Je kunt meerdere instances hebben van dezelfde class, bijvoorbeeld voor verschillende schildpadden: <pre><code>class Turtle:\n    ...\n\nturtle_1247 = Turtle()\n...\nturtle_1428 = Turtle()\n...\n</code></pre></p> <p>De class <code>Turtle</code> is een verzameling van methods waaronder <code>forward()</code> en <code>left()</code>. Zoals hierboven staat beschreven zijn deze methods als uitkomst van de class meegegeven aan de instance <code>master_oogway</code>. Je kunt daarom de methods aanroepen met de instance <code>master_oogway</code>: <pre><code>master_oogway = Turtle(\"turtle\")\n\nmaster_oogway.forward(50)\nmaster_oogway.left(30)\nmaster_oogway.forward(50)\n</code></pre></p> <p>Hierin is <code>50</code> het aantal stappen en <code>30</code> de hoek in graden die de schildpad tegen de klok in draait. </p> <p>De class <code>Turtle</code></p> opdrachtcodecheck <p>      Je bent inmiddels nieuwsgierig geworden naar de schildpad. De class <code>Turtle</code> zit standaard in Python, daarom kan je deze importeren met <code>from turtle import Turtle</code>. Je opent in GitHub Desktop de repository <code>oefenopdrachten</code> en opent deze repository in Visual Studio Code. Je maakt een bestand  <code>Feynman.py</code> aan. Aangezien er nog geen environment gekoppeld is aan deze repository maak je eerst een virtual environment aan (zie opdracht Environment aanmaken). Teken nu met een schildpad met de instancenaam <code>master_oogway</code> een Feynman diagram.       <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>Feynman.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Scherm met schildpad verdwijnt</p> <p>Na het uitvoeren van het script sluit Python het scherm van de schildpad. Voeg de regel <code>master_oogway.screen.mainloop()</code> toe om het scherm te laten staan en handmatig af te sluiten. </p> <p>Pseudo-code <pre><code>from turtle import Turtle\n\n# create instance of class Turtle\nmaster_oogway = Turtle(\"turtle\")\n\n# use forward() and left() to create a Feynman diagram\n</code></pre> Voorbeeld uitkomst </p> <p>Checkpunten</p> <ul> <li> De class <code>Turtle</code> wordt ge\u00efmporteerd uit de module <code>turtle</code>.</li> <li> De instance is van de class <code>Turtle</code> met hoofdletter T.</li> <li> De naam van de instance is <code>master_oogway</code>.</li> <li> Om de schildpad te laten bewegen roep je de method <code>forward()</code> of <code>left()</code> van de instance aan.</li> </ul> <p>Projecttraject</p> <ul> <li> De class <code>Turtle</code></li> <li> De method <code>__init__(self)</code></li> <li> Een class maken</li> <li> <code>self</code> = instance</li> <li> Opbouw van een class</li> </ul>"},{"location":"classes/#het-maken-van-een-class","title":"Het maken van een class","text":"<p>De class <code>Turtle</code> is behoorlijk complex en het gaat te ver om de class hier helemaal te gaan bespreken. Voor een goed begrip van classes ga je daarom kijken naar een versimpelde weergave van de class <code>Turtle</code>.</p> <p>Een class maak je aan met de regel <code>class Turtle:</code>. <sup>1</sup> Daaronder komt ingesprongen de inhoud van de class. De class bestaat uit methods. De eerste method <code>__init__()</code> is een speciale method (voor meer informatie zie: dunder methods), dit is de initializer waarin alle taken staan die uitgevoerd worden zodra de class gebruikt wordt. </p> <pre><code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n\n    def forward(self, distance):\n        # move turtle by distance\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n</code></pre> <p>De eerste parameter van de <code>__init__()</code>-method en van alle andere methods is <code>self</code>, daarna komen \u2014 indien nodig \u2014 andere parameters die in de method nodig zijn. Verder op in dit hoofdstuk leer je meer over de speciale parameter <code>self</code>.</p> <p>Het aanmaken van een class lijkt in een aantal opzichten op het aanmaken van een functie:</p> <pre>\n<code>def calculate_squares_up_to(max_number):\n    squares = []\n    for number in range(max_number):\n        squares.append(number ** 2)\n    return squares\n\nresult = calculate_squares_up_to(5)\n</code></pre> <pre>\n<code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n\n    def forward(self, distance):\n        # move turtle by distance\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n\nmaster_oogway = Turtle(\"turtle\") \n</code></pre> <p>De method <code>__init__(self)</code></p> opdrachtcheck <p>Achter de naam van de class: <code>Turtle</code>, komen tussen ronde haakjes de variabelen die worden meegegeven aan de  <code>__init__()</code>-method (<code>self</code> niet meegerekend), de parameter <code>shape</code> krijgt dus de variabele <code>\"turtle\"</code> toegewezen.</p> <p>Stel dat de <code>__init__()</code>-method geen extra parameters mee krijgt, zoals in onderstaand geval. Hoe maak je dan een instance aan van de class?  <pre><code>class Turtle:\n    def __init__(self):\n        # initialize class\n\n    def forward(self, distance):\n        # move turtle by distance\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n</code></pre></p> Uitwerkingen <pre><code>master_oogway = Turtle()\n</code></pre> <p>Projecttraject</p> <ul> <li> De class <code>Turtle</code></li> <li> De method <code>__init__(self)</code></li> <li> Een class maken</li> <li> <code>self</code> = instance</li> <li> Opbouw van een class</li> </ul> <p>Een class maken</p> opdrachtcodecheck <p>      Je gaat de versimpelde weergave van de <code>Turtle</code> class gebruiken om een werkende class te maken die weliswaar geen schildpad laat lopen maar wel tekst print!          Maak een bestand  <code>fake-turtle.py</code> waarin je zelf een class <code>Turtle</code> maakt. Zodra de class <code>Turtle</code> gebruikt wordt, print je tekst die aangeeft welke vorm de pen heeft. Wanneer de methods <code>forward</code> en <code>left</code> worden aangeroepen print je een tekst die aangeeft hoeveel stappen de turtle zet of hoeveel graden de turtle draait.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>fake-turtle.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>Feynman.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code>class Turtle:\n    def __init__(self, shape):\n        # print the shape of the turtle\n\n    def forward(self, distance):\n        # print the distance that the turtle moves\n\n    def left(self, angle):\n        # print the angle that the turtle turns counterclockwise\n</code></pre> Testcode  fake_turtle.py <pre><code>master_oogway = Turtle(\"turtle\")\n\nmaster_oogway.forward(50)\nmaster_oogway.left(30)\nmaster_oogway.forward(50)\n</code></pre> <pre>\n<code>(ECPC) &gt; python fake_turtle.py\ntransform shape to... turtle\nmove with 50 steps\nturn turtle counterclockwise by 30 degrees\nmove with 50 steps\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Wanneer je een instance aanmaakt van de class <code>Turtle</code> moet je een parameter meegeven.</li> <li> Wanneer je een instance aanmaakt van de class <code>Turtle</code> wordt in de terminal geprint welke vorm de turtle heeft.</li> <li> Wanneer je de method <code>forward()</code> aanroept, moet je een parameter meegeven.</li> <li> Wanneer je de method <code>forward()</code> aanroept, wordt in de terminal geprint hoeveel stappen de turtle zet.</li> <li> Wanneer je de method <code>left()</code> aanroept, moet je een parameter meegeven.</li> <li> Wanneer je de method <code>left()</code> aanroept, wordt in de terminal geprint hoeveel graden de turtle draait.</li> </ul> <p>Projecttraject</p> <ul> <li> De class <code>Turtle</code></li> <li> De method <code>__init__(self)</code></li> <li> Een class maken</li> <li> <code>self</code> = instance</li> <li> Opbouw van een class</li> </ul>"},{"location":"classes/#de-speciale-parameter-self","title":"De speciale parameter <code>self</code>","text":"<p>Een class method is vrijwel gelijk aan een normale functie, behalve dat een class method als eerste de parameter <code>self</code> verwacht. Aan deze parameter wordt de eigen instance van de class meegegeven wanneer je de method aanroept. Laten we kijken naar wat die instance van de class eigenlijk is. De instance van een class is de collectie van methods (en variabelen). </p> <pre>\n<code>def calculate_squares_up_to(max_number):\n    squares = []\n    for number in range(max_number):\n        squares.append(number ** 2)\n    return squares\n\nresult = calculate_squares_up_to(5)\n</code></pre> <pre>\n<code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n\n    def forward(self, distance):\n        # move turtle by distance\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n\nmaster_oogway = Turtle(\"turtle\") \n</code></pre> <p>Als je de functie <code>calculate_squares_up_to(max_number)</code> aanroept met <code>result = calculate_squares_up_to(5)</code>, dan komt hetgeen dat teruggegeven wordt, <code>squares</code>, in de variabele <code>result</code> terecht. Bij een class is er geen <code>return</code>-statement maar komt de hele inhoud van de class, dus alle methods (en variabelen), in de instance <code>master_oogway</code> terecht.</p> <p>Gelukkig hoef je de instance niet steeds zelf mee te geven aan een method. Wanneer je een method aanroept wordt impliciet de instance als eerste parameter meegegeven.  Maar waarom zou je die instance meegeven aan een method als je die aanroept? Omdat de instance alle methods en variabele bevat, kan je de informatie die daarin is opgeslagen in elke method gebruiken. </p> <p>Stel je maakt een nieuwe method <code>do_kungfu_move</code> waarin je <code>forward()</code> en <code>left()</code> willen gebruiken:</p> <pre><code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n\n    def forward(self, distance):\n        # move turtle by distance\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n\n    def do_kungfu_move(self):\n        # do kungfu move\n        self.forward(130)\n        self.left(350)\n        self.forward(60)\n</code></pre> <p>Als je de method <code>do_kungfu_move</code> aanroept met <code>master_oogway.do_kungfu_move()</code>, dan geeft python automatisch de instance <code>master_oogway</code> mee aan de method. De parameter <code>self</code> is dus nu gelijk aan de instance <code>master_oogway</code>, daarmee doet <code>self.forward(130)</code> hetzelfde als <code>master_oogway.forward(130)</code>. </p> <p><code>self</code> = instance</p> opdrachtcodecheck <p>Het begrip <code>self</code> is een vaag begrip, maar je kunt met print-statements zien wat <code>self</code> is. Voeg aan <code>fake_turtle.py</code> de method <code>do_kungfu_move()</code> toe. En voeg aan de method ook een print-statement toe om de variabele <code>self</code> te printen. Gebruik hiervoor: <code>print(f\"{self=}\")</code>. Gebruik de instance <code>master_oogway</code> om de method <code>do_kungfu_move</code> aan te roepen. De variabele <code>self</code> is, als het goed is, gelijk aan de instance <code>master_oogway</code>. Om dit te controleren voeg je ook een print-statement toe om <code>master_oogway</code> te printen: <code>print(f\"{master_oogway=}\")</code>.  Je hebt nu twee keer een object geprint. Dat ziet er misschien wat gek uit, maar je kunt er wel nuttige informatie uithalen. Aan het eind zie je getallen met letters staan, dat is het geheugenadres waar het object is opgeslagen. Als je het geheugenadres van de instance <code>master_oogway</code> vergelijkt met die van de variabele <code>self</code> dan zie je dat deze hetzelfde zijn. Dat betekent dat de objecten ook dezelfde objecten zijn, <code>self</code> is dus gelijk aan <code>master_oogway</code>!  <code>self</code> is de instance zelf. Met andere woorden: als je een andere instance gebruikt, dan verandert <code>self</code> mee. Om dit te testen maak je een instance <code>toby</code> aan, de tweede instance. Roep de method <code>do_kungfu_move</code> aan met <code>toby</code>. Je ziet dat het geheugenadres van de variabele <code>self</code> nu anders is dan de vorige <code>self</code>. Je controleert of het geheugenadres overeenkomt met het geheugenadres van de instance <code>toby</code>.</p> <p>Pseudo-code <pre><code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n        ...\n\n    def forward(self, distance):\n        # move turtle by distance\n        ...\n\n    def left(self, angle):\n        # turn turtle counterclockwise\n        # by angle in degrees\n        ...\n\n    def do_kungfu_move(self):\n        # do kungfu move\n        self.forward(130)\n        self.left(350)\n        self.forward(60)\n        # print self\n        print(f\"{self=}\")\n</code></pre> Testcode  fake_turtle.py <pre><code>master_oogway = Turtle(\"turtle\")\nprint(f\"{master_oogway=}\")\nmaster_oogway.do_kungfu_move()\n\ntoby = Turtle(\"turlte\")\nprint(f\"{toby=}\")\ntoby.do_kungfu_move()\n</code></pre> <pre>\n<code>(ECPC) &gt; python fake_turtle.py\nmaster_oogway=&lt;__main__.Turtle object at 0x10530b890&gt;\nself=&lt;__main__.Turtle object at 0x10530b890&gt;\ntoby=&lt;__main__.Turtle object at 0x103377980&gt;\nself=&lt;__main__.Turtle object at 0x103377980&gt;\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Het geheugenadres van <code>master_oogway</code> is gelijk aan het geheugenadres van <code>self</code>.</li> <li> <code>master_oogway</code> is niet gelijk aan <code>self</code> als de method met een andere instance wordt aangeroepen.</li> </ul> <p>Projecttraject</p> <ul> <li> De class <code>Turtle</code></li> <li> De method <code>__init__(self)</code></li> <li> Een class maken</li> <li> <code>self</code> = instance</li> <li> Opbouw van een class</li> </ul>"},{"location":"classes/#instance-attribute","title":"Instance attribute","text":"<p>De instance van een class bevat niet alleen alle methods, maar kan ook variabelen bevatten. In het voorbeeld hieronder voegen we de variabele <code>quote</code> toe in de <code>__init__</code>-method en daarmee ook aan de instance. Dit wordt een instance attribute genoemd.</p> <p><pre><code>class Turtle:\n    def __init__(self, shape):\n        # transform turtle into shape\n        self.quote = \"Yesterday is history, Tomorrow is a mystery, but Today is a gift. That is why it is called the present\"\n\n    ...\n</code></pre> De instance attribute <code>quote</code> is nu onderdeel van de instance. We kunnen die oproepen binnen elke method met <code>self.quote</code> maar ook buiten de class:</p>  turtles.py <pre><code>...\nmaster_oogway = Turtle(\"turtle\")\n\nprint(master_oogway.quote)\n</code></pre> <pre>\n<code>(ECPC) &gt; python turtles.py\n\"Yesterday is history, Tomorrow is a mystery, but Today is a gift. That is why it is called the present\"\n</code></pre> <p>Opbouw van een class</p> opdrachtcheck <p>Bekijk onderstaande code. Wat doet deze code precies? Verplaats daarna de onderdelen naar de juiste plek in de code. Twijfel je of je nog weet wat een module is kijk dan voor meer informatie in de paragraaf modules.</p> <p></p> <p>Projecttraject</p> <ul> <li> De class <code>Turtle</code></li> <li> De method <code>__init__(self)</code></li> <li> Een class maken</li> <li> <code>self</code> = instance</li> <li> Opbouw van een class</li> </ul> Classes importeren <p>Wat is nu het praktisch nut van classes en methods gebruiken in plaats van functies? Want in plaats van <pre><code>forward(master_oogway, distance=50)\n</code></pre> heb je nu <pre><code>master_oogway.forward(distance=50)\n</code></pre> en dat is even lang. Het grote voordeel ontstaat pas wanneer de class ingewikkelder wordt en meer data gaat bewaren. Ook kun je de class in een ander pythonbestand (bijvoorbeeld <code>animals.py</code>) zetten en alle functionaliteit in \u00e9\u00e9n keer importeren met: <pre><code>from animals import Turtle\n\nmaster_oogway = Turtle()\n...\n</code></pre> Op deze manier kun je code ook makkelijker delen en verspreiden. Zodra je een class definieert zal Visual Studio Code tijdens het programmeren je code automatisch aanvullen. Zodra je typt <code>master_oogway.f</code> hoef je alleen maar op Tab te drukken en Visual Studio Code vult de rest aan.</p> <p>Class <code>Particle</code></p> opdrachtcodecheck <p></p> <p>      Je hebt een class <code>Particle</code> gemaakt in een niew bestand  <code>particle.py</code>. Als je een instance aanmaakt van de class <code>Particle</code> kun je de naam van het deeltje meegeven en de spin (bijvoorbeeld: 0.5). De instance attributes van deze class zijn 'name' en 'spin'. Er is ook een method <code>is_up_or_down()</code> om terug op te vragen wat de spin van het deeltje op dat moment is (spin omhoog/positief of spin omlaag/negatief). Door de method <code>flip()</code> op te roepen wordt de spin van het deeltje omgekeerd.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>particle.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code># class Particle:\n#   def __init__(self, name, spin):\n#       make instance attribute from name\n#       make instance attribute from spin\n#\n#   def is_up_or_down():\n#       print up when spin is positive\n#       print down when spin is negative\n#       ...\n#\n#   def flip():\n#       make spin positive if spin is negative\n#       make spin negative if spin is positive\n#       ...\n</code></pre> Testcode particle.py <pre><code>proton = Particle('mooi proton', 0.5)\nproton.is_up_or_down()\nproton.flip()\nproton.is_up_or_down()\nprint(f\"{proton.spin=}\")\nprint(f\"{proton.name=}\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python particle.py\nup\ndown\nproton.spin=-0.5\nproton.name='mooi proton'\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Naam en spin worden aan instance meegegeven.</li> <li> Naam en spin zijn instance attributes en kunnen zowel binnen een method als buiten de class opgeroepen worden.</li> <li> Method <code>is_up_or_down()</code> print 'up' als de spin positief is en 'down' als het negatief is.</li> <li> Method <code>flip()</code> maakt de spin positief als de spin negatief is, en negatief als de spin positief is.</li> </ul> <p>Projecttraject</p> <ul> <li> Class <code>Particle</code></li> </ul> <p>Class <code>ProjectileMotion</code></p> opdrachtcodecheck <p>      Je gaat een waterraket een aantal keer wegschieten met steeds een andere beginsnelheid en lanceerhoek. Je hebt een instance aangemaakt van de class <code>ProjectileMotion</code>. De beginsnelheid en de lanceerhoek bewaar je steeds met de method <code>add_launch_parameters()</code>. Om in een keer alle beginsnelheden op te vragen gebruik je de method <code>get_initial_velocities()</code>. Om alle lanceerhoeken op te vragen gebruik je de method <code>get_launch_angles()</code>. Op basis van de gegevens (en door de luchtweerstand te verwaarlozen) bepaal je de vluchtduur en het bereik van de raket. Je kunt de vluchtduur van alle vluchten opvragen met de method <code>get_time_of_flights()</code> en het bereik van alle vluchten met <code>get_flight_ranges()</code>. Zie het tabblad check voor de nodige vergelijkingen.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500  <code>projectile-motion</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>water-rocket.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code># class ProjectileMotion\n#    ...\n#    __init__\n#       ...\n#    add_launch_parameters\n#       ...\n#    get_initial_velocities\n#       ...\n#    get_launch_angles\n#       ...\n#    get_time_of_flights\n#       ...\n#    get_flight_ranges\n#       ...\n</code></pre> Testcode water_rocket.py <pre><code>speedy = ProjectileMotion()\nspeedy.add_launch_parameters(v=28, angle=68)\nspeedy.add_launch_parameters(v=11, angle=15)\n\nv = speedy.get_initial_velocities()\nangles = speedy.get_launch_angles()\nx = speedy.get_flight_ranges()\nt = speedy.get_time_of_flights()\n\nprint(f\"{v=}\")\nprint(f\"{angles=}\")\nprint(f\"{x=}\")\nprint(f\"{t=}\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python water_rocket.py\nv=[28, 11]\nangles=[68, 15]\nx=[55.51602063607072, 6.167176350662587]\nt=[5.292792645845066, 0.5804300705663054]\n</code></pre></p> <p>Checkpunten</p> <ul> <li> De code bevindt zich in een GitHub-repository .</li> <li> De method <code>add_launch_parameters</code> verwacht een beginsnelheid in meter per seconde en een lanceerhoek in graden.</li> <li> De method <code>get_initial_velocities</code> geeft een lijst terug met alle beginsnelheden van de ingevoerde parameters.</li> <li> De method <code>get_launch_angles</code> geeft een lijst terug met alle lanceerhoeken van de ingevoerde parameters.</li> <li> De time-of-flight wordt berekend met 2 * v_y / g.</li> <li> De beginsnelheid in de y-richting wordt berekend met v_y = v * sin(lanceerhoek).</li> <li> Het bereik wordt berekend met time_of_flight * v_x.</li> <li> De beginsnelheid in de x-richting wordt berekend met v_x = v * cos(lanceerhoek).</li> <li> De lanceerhoek wordt in radialen meegegeven aan de trigonometrische functies.</li> <li> De method <code>get_time_of_flights</code> geeft een lijst terug met de vluchtduur in seconden corresponderend met de ingevoerde parameters. </li> <li> De method <code>get_flight_ranges</code> geeft een lijst terug met het bereik in meters corresponderend met de ingevoerde parameters.</li> </ul> <p>Projecttraject</p> <ul> <li> Class <code>ProjectileMotion</code></li> </ul> <p>Raise exception</p> <p>Het is niet logisch om een lanceerhoek boven een bepaalde waarde in te voeren of om een negatieve beginsnelheid mee te geven. Zorg dat in die gevallen een error afgegeven wordt. Meer informatie hierover vind je in de paragraaf Exceptions.</p> Subclass <ol> <li> <p>Wanneer je de Google Style Guide<sup>2</sup> volgt schrijf je de naam van de class in CapWords of CamelCase.\u00a0\u21a9</p> </li> <li> <p>Google. Google python style guide. URL: https://google.github.io/styleguide/pyguide.html.\u00a0\u21a9</p> </li> </ol>"},{"location":"classes/#subclasses","title":"Subclasses","text":"<p>Je kunt behalve een class ook een subclass aanmaken. De class <code>Turtle</code> heeft hele handige methods maar je kunt een specifiekere class <code>GiantTortoise</code> maken.</p> <pre><code>class GiantTortoise(Turtle):\n    def __init__(self):\n        super().__init__()\n        self.shape(\"turtle\")\n        self.color(\"dark green\")\n        self.turtlesize(5)\n        self.speed(1)\n\n    def move(self, distance):\n        steps = range(0, distance, 5)\n        i = 1\n        for step in steps:\n            self.tiltangle(i * 5)\n            self.forward(step)\n            time.sleep(1)\n            i = i * -1\n</code></pre> <p>Door de parentclass <code>Turtle</code> tussen ronde haakjes mee te geven aan de nieuwe subclass <code>GiantTortoise</code> krijgt de subclass alle functionaliteit mee van de parentclass, waaronder alle methods zoals <code>forward()</code>. Als je in de <code>__init__()</code>-method van de subclass methods of attributes wilt gebruiken van de parentclass, moet je ervoor zorgen dat de parentclass is ge\u00efnitialiseerd . Dit doe je met <code>super().__init__()</code>. Hierbij verwijst <code>super()</code> naar de parentclass en met <code>__init__()</code> voer je de <code>__init__()</code>-method van de parentclass uit. Nadat je in de <code>__init__()</code>-method van de subclass de eigenschappen van de reuzenschildpad hebt gedefinieerd, kun je extra functionaliteit gaan toevoegen, bijvoorbeeld de manier van bewegen met de method <code>move()</code>. </p> <p><code>super().__init__()</code></p> <ol> <li>Maak een bestand aan waarin je de subclass <code>GiantTortoise</code> aanmaakt.</li> <li>Zorg dat de volgende voorbeeldcode werkt: <pre><code>t = GiantTortoise()\nt.move(50)\n</code></pre></li> <li>Wat gebeurt er als je <code>super().__init__()</code> weglaat?</li> </ol> <p>Hawksbill turtle</p> <ol> <li>Maak een subclass aan voor de Hawksbill turtle.</li> <li>De Hawksbill turtle is een zeeschildpad. Maak de omgeving van de schildpad standaard blauw met <code>self.screen.bgcolor(\"cyan\")</code>.</li> <li>Schrijf een method <code>swim()</code> die de schildpad over het scherm laat bewegen. </li> </ol>"},{"location":"cli/","title":"Command-line interface","text":""},{"location":"cli/#gebruikersomgevingen","title":"Gebruikersomgevingen","text":"<p>Vanaf de jaren '60 van de vorige eeuw werden computers interactief. Het was mogelijk om via een terminal commando's aan de computer te geven en te wachten op een antwoord. In tegenstelling tot moderne gebruikersomgevingen waren deze volledig op tekst gebaseerd. Hoewel moderne besturingssystemen \u2014 of het nu computers, tablets of mobiele telefoons betreft \u2014 volledig grafisch zijn ingericht, is de tekstuele interface nooit verdwenen. Opdrachten geven door te typen is gewoon best wel handig en snel. Ook is het veel eenvoudiger om applicaties te ontwikkelen zonder grafische interface.</p> <p>Op ieder besturingssysteem \u2014 Linux, MacOS, Windows \u2014 is een shell, terminal of command prompt te vinden. Als je die opstart kun je op de zogeheten command line opdrachten intypen. Veelal zijn dit commando's om het bestandssysteem te navigeren en programma's op te starten.</p> <p>Wanneer je in Visual Studio Code een Python script start dan opent het een terminal onderin het scherm.</p>"},{"location":"cli/#commandos","title":"Commando's","text":"<p>Je hebt tot nu toe al heel wat commando's in de terminal getypt. Laten we een paar voorbeelden bestuderen: Terminal<pre><code>PS&gt; python script.py\n</code></pre> Als eerste vertel je welke applicatie je wilt gaan starten; in dit geval: <code>python</code>. Daarna geef je met het argument <code>script.py</code> aan welk Pythonscript je wilt uitvoeren. Vaak kun je ook opties meegeven zoals in:</p> <pre><code>(ECPC) &gt; python -V \nPython 3.10.13\n</code></pre> <p>Hiermee vraag je Python om het versienummer weer te geven. Soms kunnen opties zelf weer een argument meekrijgen. Bijvoorbeeld: Terminal<pre><code>PS&gt; python -m antigravity\n</code></pre> Met deze regel geef je Python de optie <code>-m</code> en die importeert een module (hier <code>antigravity</code>) en voert die uit. Probeer maar eens zelf wat er gebeurt als je dat commando uitvoert.</p> <p>Als applicaties veel verschillende functionaliteit hebben dan krijg je regelmatig te maken met een lange regel met een combinatie van argumenten en opties: Terminal<pre><code>PS&gt; conda create --name pythondaq --channel conda-forge python pyvisa-py\n</code></pre> Uitgesplitst in argumenten en opties, met vierkante haken [] om aan te geven welke onderdelen bij elkaar horen, is dat:</p> <p>conda create [--name pythondaq] [-channel conda-forge] [python pyvisa-py]</p> <p>Poetry argumenten</p> <ol> <li>Naast <code>conda create</code> heb je ook met andere argumenten gewerkt zoals <code>activate</code> en <code>install</code>. Welke argumenten ken je al van de applicatie <code>poetry</code>?</li> <li>Vraag de lijst met argumenten (commando's) op van Poetry met <code>poetry list</code>, hoeveel kende je nog niet?</li> </ol> <p>Conda opties en argumenten</p> <ol> <li>Open een <code>Anaconda Prompt</code></li> <li>Maak gebruik van de optie -h om de helpfunctie van conda op te vragen. (<code>conda -h</code>)</li> <li>Zoek de optie op om de conda versie weer te geven (<code>conda -V</code>)</li> <li>Maak gebruik van de optie -h om de helpfunctie van het commando activate op te vragen (<code>conda activate -h</code>)</li> <li>Welke argumenten moet je meegeven (positional arguments?) en welke opties mag je meegeven (optional arguments?) (argument: env_name_or_prefix, opties: --help, --stack, --no-stack)</li> </ol>"},{"location":"cli/#click","title":"Click","text":"<p>Als we gebruik willen maken van commando's in onze eigen applicatie moeten we weten wat de gebruiker in de terminal typt. Dit is mogelijk met <code>sys.argv</code>.<sup>1</sup> Waarbij alles wat we in de terminal typen aan input wordt meegegeven:</p>  cli.py <pre><code>import sys\n\nprint(sys.argv)\n</code></pre> <pre>\n<code>(ECPC) &gt; python cli.py test 123\n['cli.py', 'test', '123']\n</code></pre> <p>Met if-statements kunnen we acties verbinden aan bepaalde argumenten: cli.py<pre><code>import sys\n\nargs = sys.argv\nprint(args)\n\nif args[1] == \"test\":\n    print(f\"This is a test: {args[2]}\")\nelse:\n    print(f\"CommandNotFoundError: No command '{args[1]}'.\")\n</code></pre></p> <p>Als je meerdere opties en argumenten meegeeft dan wordt het veel werk om die in je script uit elkaar te plukken en ze goed te interpreteren. Om dat makkelijker te maken zijn er verschillende bibliotheken beschikbaar \u2014 waaronder een paar in de standard library van Python. Een hele handige \u2014 die n\u00edet in de standard library van Pythhon zit maar w\u00e9l meegeleverd is met de base environment van Anaconda \u2014 is Click.<sup>5</sup></p> <p>Info</p> <p>Click maakt gebruik van decorators (<code>@decorator</code>). Om decorators te gebruiken, hoef je niet per se te weten hoe ze werken. Als je meer wilt weten over de werking ervan kijk dan de calmcode tutorial of lees de Primer on Python Decorators.</p> <p>Als kort voorbeeld \u2014 ge\u00efnspireerd op de documentatie van Click \u2014 nemen we het volgende script: hello.py<pre><code>def hello():\n    print(\"Hello physicist!\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre></p> <p>Dit script print de uitdrukking \"Hello physicist!\". We gaan dit aanpassen en maken het mogelijk om de naam en het aantal begroetingen te kiezen. Hiervoor gebruiken we Click. Allereerst moeten we <code>click</code> importeren en aangeven dat we de <code>hello()</code>-functie willen gebruiken als commando:</p> hello.py<pre><code>import click\n\n@click.command()\ndef hello():\n    print(\"Hello physicist!\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <p>Dit levert ons nog niet zoveel op, maar op de achtergrond is click wel degelijk aan het werk. De <code>@click.command()</code> houdt in de gaten wat er in de command line wordt ingetypt. Zo kunnen we de helpfunctie aanroepen door <code>--help</code> achter de naam van het script te zetten.</p> Terminal<pre><code>python hello.py --help\n</code></pre> <p>Help functie</p> opdrachtcodecheck <p>      Je neemt het script <code>hello.py</code> over. Je vraagt de helpfunctie van het script op. Je ziet een helptekst verschijnen. Je vraagt je af wat er gebeurt als je <code>@click.command()</code> weg haalt en dan de helpfunctie opvraagt. Je krijgt gewoon de output van de functie <code>hello()</code> een geen help tekst.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>hello.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u251c\u2500\u2500  <code>pythondaq</code>     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code hello.py<pre><code>import click\n\n# make function Click command\n# function\n    # print hello physicist!\n\n# when run this script:\n    # run function\n</code></pre> Testcode <pre><code>(ECPC) &gt; python hello.py --help \nUsage: hello.py [OPTIONS]      \nOptions:\n    --help  Show this message and exit.\n\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Je vraagt de helpfunctie op door <code>--help</code> achter de bestandsnaam te zetten in de terminal.</li> <li> Er verschijnt een standaard helptekst.</li> <li> Zonder <code>@click.command()</code> verschijnt er geen helptekst, maar de output van de functie.</li> </ul> <p>Projecttraject:</p> <ul> <li> Help functie</li> <li> Argumenten toevoegen</li> <li> Test hello</li> <li> Helptekst toevoegen</li> <li> Pauze optie</li> <li> Vlag</li> </ul> <p>In de code hieronder geven we met de regel <code>@click.argument(\"name\")</code> aan dat we van de gebruiker een argument verwachten. Zorg dat het argument ook gebruikt wordt in de functie <code>hello</code>:</p> hello.py<pre><code>import click\n\n@click.command()\n@click.argument(\"name\")\ndef hello(name):\n    print(f\"Hello {name}!\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <p>Argument toevoegen</p> opdrachtcodecheck <p>Je runt het bestand <code>hello.py</code> en geeft achter de bestandsnaam de naam <code>Alice</code> mee. Er verschijnt <code>Hello Alice!</code> als output in de terminal.</p> <p>Pseudo-code hello.py<pre><code>import click\n\n# make function Click command\n# make argument name\n# function, parameter name\n    # print hello &lt;name&gt;!\n\n# when run this script:\n    # run function\n</code></pre> Testcode <pre><code>(ECPC) &gt; python hello.py \nUsage: hello.py [OPTIONS] NAME\nTry 'hello.py --help' for help.\nError: Missing argument 'NAME'.\n\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het draaien van <code>hello.py</code> zonder een argument: <code>python hello.py</code> geeft een foutmelding.</li> <li> Het draaien van <code>hello.py</code> met een argument: <code>python hello.py Alice</code> werkt zoals verwacht.</li> </ul> <p>Projecttraject:</p> <ul> <li> Help functie</li> <li> Argumenten toevoegen</li> <li> Test hello</li> <li> Helptekst toevoegen</li> <li> Pauze optie</li> <li> Vlag</li> </ul> <p>Warning</p> <p>Let er op dat je bij <code>@click.argument</code> de naam meegeeft die overeenkomt met de namen van de parameters van je functie. In ons geval hebben we een argument <code>\"name\"</code>. Dit moet overeenkomen met de functiedefinitie <code>def hello(name)</code>.</p> <p>Argumenten zijn altijd verplicht en moeten in een vaste volgorde staan. Bij opties is dat anders. Je geeft met mintekens aan dat je een optie meegeeft. Veel opties hebben een lange naam en een afkorting (bijvoorbeeld <code>--count</code> en <code>-c</code>). Opties kunnen zelf weer een argument hebben (bijvoorbeeld <code>--count 3</code>). Het is handig om een standaardwaarde te defini\u00ebren. In dat geval mag de gebruiker de optie weglaten. We voegen een for-loop<sup>2</sup> toe om de begroeting te herhalen.</p> hello.py<pre><code>import click\n\n@click.command()\n@click.argument(\"name\")\n@click.option(\n    \"-c\",\n    \"--count\",\n    default=1,\n)\ndef hello(name, count):\n    for _ in range(count):\n        print(f\"Hello {name}!\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <p>5 keer hello</p> opdrachtcodecheck <p>Je runt het bestand <code>hello.py</code> en geeft achter de bestandsnaam de naam van je assistent mee en geeft aan dat je deze 5 keer wilt printen. Er verschijnt vijf keer <code>Hello &lt;assistent&gt;!</code> als output in de terminal.</p> <p>Pseudo-code hello.py<pre><code>import click\n\n# make function Click command\n# make argument name\n# make option count with default value 1\n# function, parameter name and count\n    # repeat count times\n        # print hello &lt;name&gt;!\n\n# when run this script:\n    # run function\n</code></pre> Testcode <pre><code>(ECPC) &gt; python hello.py David -c 5 \nHello David!\nHello David!\nHello David!\nHello David!\nHello David!\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Je kan de naam van je assistent 5 keer printen met \u00e9\u00e9n commando</li> <li> Je kan het aantal keer printen opgeven met <code>-c</code>.</li> <li> Je kan het aantal keer printen ook opgeven met <code>--count</code>.</li> <li> Wanneer de optie <code>count</code> wordt weggelaten wordt de naam 1 keer geprint.</li> <li> <p> Wanneer er geen argument wordt meegegeven met <code>count</code> volgt een foutmelding:</p> <p><pre><code>(ECPC) &gt; python hello.py David -c \nError: Option '-c' requires an argument.\n</code></pre></p> </li> </ul> <p>Projecttraject:</p> <ul> <li> Help functie</li> <li> Argumenten toevoegen</li> <li> Test hello</li> <li> Helptekst toevoegen</li> <li> Pauze optie</li> <li> Vlag        </li> </ul> <p>Warning</p> <p>Let er op dat je bij <code>@click.option</code> de afkorting met 1 minteken meegeeft en de lange naam met 2 mintekens. De lange naam moet overeenkomen met de paramater van je functie. In ons geval hebben we een optie <code>\"--count\"</code> \u2014 de lange naam telt. Dit moet overeenkomen met de functiedefinitie <code>def hello(name, count)</code>.</p> <p>Het is handig om een korte helptekst toe te voegen. Dit gaat als volgt:</p> hello.py<pre><code>import click\n\n@click.command()\n@click.argument(\"name\")\n@click.option(\n    \"-c\",\n    \"--count\",\n    default=1,\n    help=\"Number of times to print greeting.\",\n    show_default=True,  # show default in help\n)\ndef hello(name,count):\n    for _ in range(count):\n        print(f\"Hello {name}!\")\n\nif __name__ == \"__main__\":\n    hello()  \n</code></pre> <p>Helptekst toevoegen</p> <p>Voeg de helptekst toe en vraag de helptekst op zoals in de opdracht Help functie.</p> <p>Als je dit script gebruikt ziet dat er zo uit:</p> <pre><code>(ECPC) &gt; python hello.py --help \nUsage: hello.py [OPTIONS] NAME\n\nOptions:\n  -c, --count INTEGER  Number of times to print greeting.  [default: 1]\n  --help               Show this message and exit.\n  \n\n(ECPC) &gt; python hello.py Alice \nHello Alice!\n\n(ECPC) &gt; python hello.py Alice -c 2 \nHello Alice!\nHello Alice!\n\n(ECPC) &gt; python hello.py Alice --count 3 \nHello Alice!\nHello Alice!\nHello Alice!\n</code></pre> <p>Pauze optie</p> opdrachtcodecheck <p>Je runt het bestand <code>hello.py</code> en geeft achter de bestandsnaam de naam van je assistent mee en geeft aan dat je deze 5 keer wilt printen met een pauze van 2 seconde ertussen. Het duurt 8 seconden voordat er vijf keer <code>Hello &lt;assistent&gt;!</code> als output in de terminal staat. Als je geen pauze-optie meegeeft wordt er ook geen pauze gehouden. </p> <p>Info</p> <p>Je kan hiervoor gebruik maken van de module time die standaard met Python meekomt<sup>3</sup>. Met de functie <code>sleep()</code> kun je de executie van de volgende regel in het script met een aantal seconden uitstellen.</p> <pre><code>import time\n# wait 28 second\ntime.sleep(28)\n</code></pre> <p>Pseudo-code hello.py<pre><code>import click\n\n# make function Click command\n# make argument name\n# make option count with default value 1\n# make option pause\n# function, parameter name and count\n    # repeat count times\n        # print hello &lt;name&gt;!\n        # pause\n\n# when run this script:\n    # run function\n</code></pre> Testcode <pre><code>(ECPC) &gt; python hello.py David -c 5 \nHello David!\nHello David!\nHello David!\nHello David!\nHello David!\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Als de pauze optie niet wordt meegegeven, dan wordt er g\u00e9\u00e9n pauze ingelast</li> <li> Bij het meegeven van de pauze optie, wacht het programma zo lang als verwacht</li> </ul> <p>Projecttraject:</p> <ul> <li> Help functie</li> <li> Argumenten toevoegen</li> <li> Test hello</li> <li> Helptekst toevoegen</li> <li> Pauze optie</li> <li> Vlag</li> </ul> <p>Opties zonder argument werken als vlag \u2014 een soort aan/uitknop.<sup>4</sup></p> <p>Vlag</p> <p>Gebruik een optie als vlag om de gebruiker te laten kiezen tussen het wel (tea) of niet (no tea) aanbieden van een kopje thee. Zorg dat er standaard tea wordt aangeboden.</p> <p>boolean flags</p> <p>Lees meer over boolean flags in de Click documentatie.</p> <p>Argumenten en opties</p> opdrachtcodecheck <p>Je opent met Github Desktop de <code>just_count</code> in Visual Studio Code. Je hebt ooit een environment voor deze repository aangemaakt maar je hebt geen idee of die in de tussentijd niet per ongeluk stuk is gegaan. Daarom maak je een nieuwe environment <code>just_count</code> met daarin Python  en gebruik je Poetry om het pakket <code>just_count</code> in de nieuwe omgeving te installeren . Je test of je de applicatie nog kunt aanroepen met het commando <code>square</code>.</p> <p>Je activeert het juiste conda environment en past de code aan zodat met het commando <code>square 6</code> het kwadraat van 6 in de terminal wordt geprint.</p> <p>Info</p> <p>Click maakt van alle argumenten een string, tenzij je een default waarde of een type definieert. Gebruik <code>type=int</code>, <code>type=float</code> enzovoorts om aan te geven wat voor type object het argument moet worden</p> Meer functies <ol> <li>Pas de applicatie aan zodat je kan kiezen tussen het kwadraat of de wortel van het getal. </li> </ol> <p>Pseudo-code count_count.py<pre><code>import square\n\n# Add functionality to select a number via click and print its square\ndef main():\n    print(f\"The square of 5 is {square.square(5)}\")\n\nif __name__ == '__main__':\n    main()\n</code></pre> Testcode <pre><code>(ECPC) &gt; square 6 \nThe square of 6 is 36\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Je hebt <code>poetry install</code> in een schone environment (met alleen Python) gedaan.</li> <li> Je hebt de juiste omgeving geactiveerd.</li> <li> Na het commando <code>square</code> kan je een getal meegeven en krijg je het verwachte antwoord terug.</li> </ul> <p>Projecttraject</p> <ul> <li> Main functie toevoegen</li> <li> commando toevoegen</li> <li> Commando testen</li> <li> Argumenten en opties</li> </ul>"},{"location":"cli/#click-subcommandos","title":"Click subcommando's","text":"<p>Tot nu toe konden we maar \u00e9\u00e9n functie uitvoeren in onze applicatie. Maar het is ook mogelijk om subcommando's aan te maken zodat je met \u00e9\u00e9n programma meerdere taken kunt uitvoeren. Denk bijvoorbeeld aan <code>conda</code>. Je installeert packages met <code>conda install</code>, verwijdert ze met <code>conda remove</code>, maakt een environment met <code>conda create</code> en activeert het met <code>conda activate</code>.</p> <p>Subcommando's bedenken</p> <p> Je gaat de <code>pythondaq</code> applicatie straks verder uitbreiden zodat er veel meer mogelijk is dan nu. Wat zou je willen dat de applicatie allemaal kan? Welke subcommando's wil je gaan aanmaken? Overleg met elkaar om goede idee\u00ebn uit te wisselen.</p> <p>Een eenvoudig voorbeeldscript waarin de conda commando's <code>install</code> en <code>remove</code> worden nagebootst leggen we hieronder uit. Eerst de code:</p> <p>fake_conda.py<pre><code>import click\n\n@click.group()\ndef cmd_group():\n    pass\n\n@cmd_group.command()\n@click.argument(\"package\")\n@click.option(\n    \"-c\",\n    \"--channel\",\n    default=\"defaults\",\n    help=\"Additional channel to search for packages.\",\n    show_default=True,  # show default in help\n)\ndef install(package, channel):\n    print(f\"Installing {package} from {channel}...\")\n\n@cmd_group.command()\n@click.argument(\"package\")\ndef remove(package):\n    print(f\"Removing {package}...\")\n\nif __name__ == \"__main__\":\n    cmd_group()\n</code></pre> In (de laatste) regel 18 roepen we de hoofdfunctie aan die we enigszins willekeurig <code>cmd_group()</code> genoemd hebben en die we bovenaan defini\u00ebren. In tegenstelling tot het <code>hello.py</code>-script doet deze functie helemaal niets (<code>pass</code>). We vertellen aan click dat we een groep van commando's aan gaan maken met de <code>@click.group()</code>-decorator in regel 3. Vervolgens gaan we commando's binnen deze groep hangen door niet de decorator <code>@click.command()</code> te gebruiken, maar <code>@cmd_group.command()</code> \u2014 zie regels 7 en 12. De namen van de commando's die worden aangemaakt zijn de namen van de functies. Dus regel 7 en 9 maken samen het commando <code>install</code>. Verder werkt alles hetzelfde. Dus een argument toevoegen \u2014 zoals in regel 8 \u2014 is gewoon met <code>@click.argument()</code>. Hier hoef je geen <code>cmd_group</code> te gebruiken.</p> <p>Fake conda</p> opdrachtcodecheck <p>      Nu je hebt geleerd om met Click subcommando's te maken wil je deze uittesten in combinatie met het commando wat je met Poetry kan aanmaken om een functie uit een script uit te voeren. Je maakt in de map <code>ECPC</code> een nieuw Poetry project aan voor <code>fake_conda</code>  en zet daarin de code uit het bestand <code>fake_conda.py</code>. Je maakt een nieuw conda environment <code>fake_conda</code> met daarin de benodigde packages . Je installeert het Poetry project in de nieuwe conda environment . Je past de <code>pyproject.toml</code> aan zodat je met het commando <code>fake_conda install scipy</code> zogenaamd <code>scipy</code> kunt installeren .       <code>ECPC</code>     \u251c\u2500\u2500  <code>fake_conda</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>src/fake_conda</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>fake_conda.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>pyproject.toml</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>commando</p> <p>Als je een commando met Poetry toevoegt dan heeft dat de opbouw <code>naam_commando = \"package.module:naam_functie\"</code>, welke functie moet uitgevoerd worden als je het commando aanroept?</p> <p>Pseudo-code pyproject.toml<pre><code>[tool.poetry.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre> Testcode <pre><code>(ECPC) &gt; fake_conda install scipy \nInstalling scipy from defaults....\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het Poetry project is in het nieuwe conda environement ge\u00efnstalleerd. </li> <li> Na het wijzigen van de <code>pyproject.toml</code> is het Poetry project opnieuw ge\u00efnstalleerd.</li> <li> In de <code>pyproject.toml</code> verwijst <code>[tool.poetry.scripts]</code> naar een functie zodat <code>install</code> en <code>remove</code> subcommando's zijn.</li> <li> Het commando <code>fake_conda install scipy</code> print de tekst <code>Installing scipy...</code> als output in de terminal. </li> </ul> <p>Projecttraject</p> <ul> <li> Fake conda</li> </ul> <p>Smallangle (meer leren)</p> <p>Met deze opdracht kun je testen hoe goed je het Python-jargon onder de knie hebt. Je zult het woord smallangle z\u00f3 vaak tegenkomen dat het je duizelt \u2014 maar jij weet precies over welk onderdeel we het hebben.</p> <ol> <li>Maak een nieuw poetry project (met een <code>src</code> indeling) aan met de naam <code>smallangle</code> .</li> <li>Let op de Octocat  voor <code>smallangle</code>, het moet dus een repository zijn (of worden). </li> <li>Maak een nieuw environment die <code>smallangle</code> heet met daarin alleen Python .</li> <li>Zet in het package <code>smallangle</code> een module <code>smallangle.py</code>.</li> <li>Plak de onderstaande code in <code>smallangle.py</code>:     <pre><code>import numpy as np\nfrom numpy import pi\nimport pandas as pd\n\n\ndef sin(number):\n    x = np.linspace(0, 2 * pi, number)\n    df = pd.DataFrame({\"x\": x, \"sin (x)\": np.sin(x)})\n    print(df)\n\n\ndef tan(number):\n    x = np.linspace(0, 2 * pi, number)\n    df = pd.DataFrame({\"x\": x, \"tan (x)\": np.tan(x)})\n    print(df)\n\n\nif __name__ == \"__main__\":\n    sin(10)\n</code></pre></li> <li>Ga door naar de opdracht smallangle aanpassen. Je mag de opdracht smallangle installeren overslaan \u2014 dat werk heb je nu zelf al gedaan.</li> </ol> <p>smallangle installeren</p> opdrachtcodecheck <p>      Je cloned het Poetry project <code>smallangle</code> van <code>AnneliesVlaar/smallangle</code> door de repository in GitHub desktop te openen. Daarna open je het project in Visual Studio Code. Na het installeren van het poetry project  in een nieuwe conda environment  run je het bestand <code>smallangle.py</code> en krijg je een lijst van 10 punten tussen 0 en 2 $\\pi$ en de sinus van deze punten.       <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>      \u2514\u2500\u2500  <code>smallangle</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Testcode  smallangle.py <pre><code>import numpy as np\nfrom numpy import pi\nimport pandas as pd\n\ndef sin(number):\n    x = np.linspace(0, 2 * pi, number)\n    df = pd.DataFrame({\"x\": x, \"sin (x)\": np.sin(x)})\n    print(df)\n\ndef tan(number):\n    x = np.linspace(0, 2 * pi, number)\n    df = pd.DataFrame({\"x\": x, \"tan (x)\": np.tan(x)})\n    print(df)\n\nif __name__ == \"__main__\":\n    sin(10)\n</code></pre> <pre>\n<code>(ECPC) &gt; python smallangle.py\n          x       sin (x)\n0  0.000000  0.000000e+00\n1  0.698132  6.427876e-01\n2  1.396263  9.848078e-01\n3  2.094395  8.660254e-01\n4  2.792527  3.420201e-01\n5  3.490659 -3.420201e-01\n6  4.188790 -8.660254e-01\n7  4.886922 -9.848078e-01\n8  5.585054 -6.427876e-01\n9  6.283185 -2.449294e-16\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het project is ge\u00efnstalleerd in een nieuwe conda environment.</li> <li> Na het installeren van het pakket geeft de code de verwachte output.</li> </ul> <p>Projecttraject:</p> <ul> <li> smallangle installeren</li> <li> smallangle aanpassen</li> <li> smallangle docstrings</li> </ul> <p>smallangle aanpassen</p> opdrachtcodecheck <p>Je kunt met het commando <code>smallangle</code> en de subcommando's <code>sin</code> en <code>tan</code> een lijst genereren van getallen tussen de 0 en 2 $\\pi$ en de bijbehorende sinus dan wel tangens van deze getallen. Met de optie <code>-n</code> kan je het aantal stappen (het aantal $x$-waardes tussen 0 en $2\\pi$) kiezen. Als je de optie <code>-n</code> weglaat werkt de applicatie met een standaardwaarde.</p> <p>TypeError: 'int' object is not iterable</p> <p>Probeer je de code te draaien maar krijg je een foutmelding zoals deze: Terminal<pre><code>Traceback (most recent call last):\nFile \"c:\\smallangle\\src\\smallangle\\smallangle.py\", line 28, in &lt;module&gt;\n    sin(10)\nFile \"C:\\click\\core.py\", line 1157, in __call__     \n    return self.main(*args, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^\nFile \"C:\\click\\core.py\", line 1067, in main\n    args = list(args)\n        ^^^^^^^^^^\nTypeError: 'int' object is not iterable\n</code></pre></p> <p>Dan komt dat doordat je <code>sin(10)</code> probeert uit te voeren, terwijl de functie al verClickt is. De functie verwacht een argument vanuit de terminal en geen integer vanuit het pythonscript. Pas je script aan zodat <code>if __name__ == \"__main__\":</code> naar de juiste functie verwijst en Click aanroept; niet <code>sin(10)</code>.</p> <p><pre><code>(ECPC) &gt; smallangle sin -n 9 \n          x       sin (x)\n0  0.000000  0.000000e+00\n1  0.785398  7.071068e-01\n2  1.570796  1.000000e+00\n3  2.356194  7.071068e-01\n4  3.141593  1.224647e-16\n5  3.926991 -7.071068e-01\n6  4.712389 -1.000000e+00\n7  5.497787 -7.071068e-01\n8  6.283185 -2.449294e-16\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De gebruiker kan met subcommando's kiezen tussen <code>sin</code> en <code>tan</code>.</li> <li> De gebruiker kan het aantal stappen kiezen met een optie.</li> <li> De gebruiker kan de optie ook weglaten.</li> </ul> <p>Projecttraject:</p> <ul> <li> smallangle installeren</li> <li> smallangle aanpassen</li> <li> smallangle docstrings</li> </ul> Smallangle (uitdaging) <p>Met het commando <code>approx</code> en een argument $\\epsilon$ moet het script de grootste hoek geven waarvoor nog geldt dat $\\lvert x - \\sin(x) \\rvert \\leq \\epsilon$, ofwel de grootste hoek waarvoor de kleine-hoekbenadering nog geldt met de opgegeven nauwkeurigheid. Doe dit op drie cijfers nauwkeurig (loop over .000, .001 en .002, etc. totdat de vergelijking niet meer geldt). N.B. besteed geen tijd aan het analytisch oplossen van de vergelijking. Een voorbeeld van de uitvoer: <pre><code>(ECPC) &gt; smallangle approx .1 \nFor an accuracy of 0.1, the small-angle approximation holds\nup to x = 0.854.\n</code></pre></p>"},{"location":"cli/#docstrings-en-click-help","title":"Docstrings en Click <code>--help</code>","text":"<p>Docstrings werken ook heel handig samen met Click want ze worden gebruikt als we de helpfunctie aanroepen. </p> <p>Info</p> <p>We gebruiken bij click-functies niet de standaard structuur voor docstrings. Click breekt de docstrings standaard af waardoor het algauw een onogelijke brij aan informatie wordt. We kiezen daarom voor een samenvatting in een zin met daarin de PARAMETERS (argumenten) in hoofdletters en eventueel een korte toelichting daarop. </p> Uitgebreide documentatie en Click <p>In de documentatie van Click vind je meer informatie over het afbreken van zinnen (en het voorkomen daarvan). Ook vind je daar een manier om een uitgebreide docstring te schrijven zonder dat het een bende wordt.</p> <p>We voegen docstrings toe aan fake-conda:</p> <p>fakeconda.py<pre><code>import click\n\n\n@click.group()\ndef cmd_group():\n    \"\"\"\n    Fake the installation and removal of packages in fake conda environments.\n    \"\"\"\n    pass\n\n\n@cmd_group.command()\n@click.argument(\"package\")\n@click.option(\n    \"-c\",\n    \"--channel\",\n    default=\"defaults\",\n    help=\"Additional channel to search for packages.\",\n    show_default=True,  # show default in help\n)\ndef install(package, channel):\n    \"\"\"Install a conda PACKAGE.\n\n    PACKAGE is the name of the package.\n    \"\"\"\n    print(f\"Installing {package} from {channel}...\")\n\n\n@cmd_group.command()\n@click.argument(\"package\")\ndef remove(package):\n    \"\"\"Remove a conda PACKAGE.\n\n    PACKAGE is the name of the package.\n    \"\"\"\n    print(f\"Removing {package}...\")\n\nif __name__ == \"__main__\":\n    cmd_group()\n</code></pre> Als we vervolgens de help functie aanroepen zien we de eerste regel van de docstrings verschijnen voor alle subcommando's:</p> <pre><code>(ECPC) &gt; fake_conda --help \nUsage: fake_conda [OPTIONS] COMMAND [ARGS]...\n\nFake the installation and removal of packages in fake conda environments.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  install  Install a conda PACKAGE.\n  remove   Remove a conda PACKAGE.\n</code></pre> <p>Daarna kun je uitleg vragen voor de subcommando's waarbij je de hele docstring te zien krijgt:</p> <pre><code>(ECPC) &gt; fake_conda install --help \nUsage: fake_conda install [OPTIONS] PACKAGE\n\n  Install a conda PACKAGE.\n\n  PACKAGE is the name of the package.\n\nOptions:\n  -c, --channel TEXT  Additional channel to search for packages.  [default:\n                      defaults]\n  --help              Show this message and exit.\n</code></pre> <p>Smallangle docstrings</p> opdrachtcodecheck <p>Je gebruikt het commando <code>smallangle --help</code> en leest de helptekst van de opdracht smallangle. De helptekst bevat zinvolle informatie die je in staat stelt om te begrijpen wat je met de applicatie kan doen. Je ziet dat er twee subcommando's zijn en bekijkt de helptekst van deze commando's met <code>smallangle sin --help</code> en daarna <code>smallangle tan --help</code>. Beide helpteksten stellen je in staat op de applicatie te begrijpen en te bedienen. Tevreden test je de applicatie verder uit.</p> <p>Pseudo-code <pre><code>\"\"\"Summary containing ARGUMENTs.\n\nARGUMENT description of the argument.\n\"\"\"\n</code></pre> Testcode <pre><code>(ECPC) &gt; smallangle --help \nUsage: smallangle [OPTIONS] COMMAND [ARGS] ...\n    Options: \n        --help Show this message and exit.\n    Commands:\n        Subcommand Summary containing ARGUMENTs.\n\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> <code>smallangle --help</code> geeft zinvolle informatie</li> <li> <code>smallangle sin --help</code> geeft zinvolle informatie</li> <li> <code>smallangle tan --help</code> geeft zinvolle informatie</li> </ul> <p>Projecttraject</p> <ul> <li> smallangle installeren</li> <li> smallangle aanpassen</li> <li> smallangle docstrings</li> </ul>"},{"location":"cli/#command-line-interface-voor-ons-experiment","title":"Command-line interface voor ons experiment","text":"<p>In hoofdstuk Model-View-Controller heb je <code>pythondaq</code> uitgesplitst in model, view en controller. Wanneer we een command-line interface gaan bouwen dan is dat de softwarelaag tussen de gebruiker en de rest van de code. De command-line interface is dus een view. Het is helemaal niet gek om meerdere views te hebben, bijvoorbeeld een eenvoudig script zoals <code>run_experiment.py</code>, een command-line interface en een grafische interface. Hier gaan we ons richten op een command-line interface. We gaan een nieuw bestand <code>cli.py</code> aanmaken en dat langzaam opbouwen.</p> <p>Pythondaq: commando's</p> opdrachtcodecheck <p>      Om de command-line interface voor pythondaq te maken ga je in een nieuw bestand <code>src/pythondaq/cli.py</code> een opzetje maken waar je stap voor stap functionaliteit aan toevoegt. De oude <code>run_experiment.py</code> maakte eerst een lijst van aangesloten apparaten en daarna werd een scan uitgevoerd. Daarom zet je in <code>cli.py</code> de subcommando's <code>list</code> en <code>scan</code>. En zorg je dat ze voor nu alleen een stukje tekst printen.          De gebruiker test de test-subcommmando's met de volgende handelingen. De gebruiker typt in de terminal het commando <code>diode</code> met daarachter het subcommando <code>list</code> en ziet een tekst verschijnen: <code>Work in progress, list devices</code>. De gebruiker test vervolgens het subcommando <code>scan</code> en ziet de tekst <code>Work in progress, scan LED</code> verschijnen.      <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>src/pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>arduino_device.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>diode_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>run_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>cli.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p></p> <p>Warning</p> <p>Omdat de naam van een subcommando gelijk is aan de functienaam kan dat voor problemen zorgen wanneer je gereserveerde namen van python wilt gebruiken zoals: <code>import</code>, <code>return</code>, <code>lambda</code>. Of wanneer je de naam van het subcommando graag hetzelfde wilt hebben als een ander pythonfunctie zoals <code>sin</code> of <code>list</code>. Een oplossing is om de functienaam aan te passen en de subcommando naam expliciet aan click mee te geven bij <code>command</code>: <pre><code>@cmd_group.command(\"import\")\n@click.argument(\"package\")\ndef import_package(package):\n    print(f\"import {package}...\")\n</code></pre> We hebben nu een commando <code>import</code> aangemaakt \u2014 niet een commando <code>import_package</code>.</p> <p>Pseudo-code cli.py<pre><code># subcommando list\n    # print Work in progress, list devices\n# subcommando scan\n    # print Work in progress, scan LED\n</code></pre> Testcode <pre><code>(ECPC) &gt; diode list \nWork in progress, list devices \n</code></pre></p> <p><pre><code>(ECPC) &gt; diode scan \nWork in progress, scan LED\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De applicatie is aan te roepen met <code>diode</code>.</li> <li> Het subcommando <code>list</code> print een stukje tekst.</li> <li> Het subcommando <code>scan</code> print een ander stukje tekst.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek        </li> <li> Pythondaq: <code>--help</code></li> </ul>"},{"location":"cli/#het-uitvoeren-van-een-meetserie","title":"Het uitvoeren van een meetserie","text":"<p>We gaan ons eerst richten op het uitvoeren van een volledige meetserie en het tonen van de resultaten daarvan aan de gebruiker.</p> <p>Info</p> <p>Bij het opgeven van argumenten en opties voor de spanning kan het belangrijk zijn om te controleren of de spanning \u00fcberhaupt wel een getal is tussen 0 en 3.3 V. Je kunt dit doen door de <code>type</code>-parameter in <code>@click.argument()</code> en <code>@click.option()</code>. Je kunt een Pythontype opgeven (bijvoorbeeld: <code>type=int</code> of <code>type=float</code>) en Click heeft speciale types zoals <code>type=click.FloatRange(0, 3.3)</code> voor een kommagetal tussen 0 en 3.3. Bekijk alle speciale types in de Click documentatie. Als je hiervan gebruik maakt hoef je niet zelf te controleren of de parameters kloppen. Click doet dat voor je.</p> <p>Pythondaq: <code>scan</code></p> opdrachtcodecheck <p>Pas het subcommando <code>scan</code> aan.  De gebruiker test het subcommando <code>scan</code> met de volgende handelingen. De gebruiker typt het commando <code>diode scan</code> in de terminal. Aan de hand van de helptekst weet de gebruiker dat het met argumenten of opties mogelijk is om het spanningsbereik (in Volt) aan te passen. Er wordt een meting gestart die binnen het spanningsbereik blijft. De gebruiker ziet dat de stroomsterkte d\u00f3\u00f3r en de spanning \u00f3ver de LED in de terminal worden geprint. De gebruiker start een nieuwe meting en geeft ditmaal met de optie <code>--output FILENAME</code> een naam voor een CSV-bestand mee. Dit keer worden de metingen ook opgeslagen als CSV-bestand onder de meegegeven bestandsnaam.</p> <p>Pseudo-code <pre><code># subcommando scan with range in Volt and output CSV\n    # start scan with range\n    # print current and voltage\n    # if output:\n        # create csv\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het programma print een lijst van metingen van de stroomsterkte d\u00f3\u00f3r en de spanning \u00f3ver de LED.</li> <li> De gebruiker moet het spanningsbereik (in volt) zelf kunnen opgeven met argumenten of opties.</li> <li> De gebruiker kan de metingen opslaan in een CSV-bestand met een optie <code>--output FILENAME</code>.</li> <li> De meting wordt alleen opgeslagen als de optie wordt meegegeven.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek        </li> <li> Pythondaq: <code>--help</code></li> </ul> <p>Pythondaq: herhaalmetingen</p> opdrachtcodecheck <p>Pas het subcommando <code>scan</code> aan zodat je met een optie het aantal herhaalmetingen kan kiezen.  De gebruiker test de optie om het aantal herhaalmetingen te kiezen met de volgende handelingen. Met het subcommando <code>scan</code> voert de gebruiker een meting uit in het bereik 2.8V tot 3.3V. Met een optie zet de gebruiker het aantal herhaalmetingen op 5. De gebruiker ziet dat het resultaat van de metingen met onzekerheden worden geprint in de terminal. De gebruiker bekijkt de grootte van de onzekerheden en voert nogmaals een scan uit maar dan met 10 metingen en daarna met 20 metingen. De gebruiker ziet dat de onzekerheden afnemen wanneer het aantal metingen toeneem.t</p> <p>Pseudo-code <pre><code># subcommando scan with range in Volt, output CSV and repeat measurements\n    # start scan with range and repeat measurements\n    # print current, voltage and errors\n    # if output:\n        # create csv\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De gebruiker kan het aantal herhaalmetingen met een optie kiezen.</li> <li> De herhaalmetingen worden gebruikt om de beste schatting en onzekerheid te berekenen van de stroomsterkte en de spanning.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek        </li> <li> Pythondaq: <code>--help</code></li> </ul> Pythondaq: stapgrootte <p>Soms wil je snel een meting uitvoeren over het hele bereik, dan is het handig om minder punten te meten dan 1023 punten. Breid de applicatie uit zodat de gebruiker de stapgrootte kan aanpassen. </p>"},{"location":"cli/#het-meetinstrument-kiezen","title":"Het meetinstrument kiezen","text":"<p>We kunnen de Arduino benaderen als we de naam weten die de VISA driver er aan heeft toegekend. Helaas kan \u2014 ook afhankelijk van het besturingssysteem \u2014 die naam veranderen als we de Arduino in een andere poort van onze computer steken of soms zelfs als we een andere Arduino op dezelfde poort koppelen. Met het commando <code>list</code> laten we alle apparaten zien die gevonden worden door de VISA drivers.</p> <p>Pythondaq: <code>list</code></p> opdrachtcodecheck <p>Pas het subcommando <code>list</code> aan.  De gebruiker test het subcommando <code>list</code> met de volgende handelingen. De gebruiker typt het commando <code>diode list</code> in de terminal. Daarna verschijnt in de terminal een lijst van aangesloten instrumenten.</p> <p><pre><code>(ECPC) &gt; diode list \n('ASRL28::INSTR','ASRL5::INSTR')\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De gebruiker kan met <code>diode list</code> de lijst met aangesloten devices opvragen.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek        </li> <li> Pythondaq: <code>--help</code></li> </ul> <p>Pythondaq: <code>info</code></p> opdrachtcodecheck <p>Voeg een subcommando <code>info</code> toe.  De gebruiker test het subcommando <code>info</code> met de volgende handelingen. Eerst heeft de gebruiker met het commando <code>diode list</code> een lijst van aangesloten devices opgevraagd. De gebruiker wil weten wat de identificatiestring is van het apparaat dat aan een bepaalde poortnaam hangt. De gebruiker geeft daarom de poortnaam mee als argument aan het subcommando <code>info</code> waarna de identificatiestring van het instrument in de terminal wordt geprint. </p> <p>identificatiestring</p> <p>De identificatiestring van onze Arduino was <code>Arduino VISA firmware v1.1.0</code>. Je moet natuurlijk niet letterlijk deze string copy/pasten, maar de identificatie opvragen van het instrument. Welk firmwarecommando moest je daarvoor ook alweer gebruiken?</p> <p>Pseudo-code <pre><code># subcommando info with device\n    # print identificationstring of device\n</code></pre> Testcode <pre><code>(ECPC) &gt; diode info ASRL28::INSTR \nArduino VISA firmware v1.1.0\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De identificatiestring is met <code>diode info DEVICE</code> op te vragen.</li> <li> De string is niet direct gecopypaste, maar wordt daadwerkelijk opgevraagd.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek        </li> <li> Pythondaq: <code>--help</code></li> </ul> <p>Pythondaq: choose device</p> opdrachtcodecheck <p>Pas het subcommando <code>scan</code> aan zodat je kan aangeven met welke Arduino je een meting wilt uitvoeren.   De gebruiker test het subcommando <code>scan</code> met de volgende handelingen. De gebruiker typt het commando <code>diode scan</code> in de terminal en vergeet daarbij een poortnaam mee te geven. De gebruiker ziet een foutmelding verschijnen want een poortnaam opgeven is verplicht.  De gebruiker vraagt met het subcommando <code>list</code> een lijst van aangesloten instrumenten op. Met het subcommando <code>info</code> is de gebruiker er achtergekomen wat de naam is van de poort waar de Arduino aanhangt. Vervolgens geeft de gebruiker deze poortnaam mee bij het subcommando <code>scan</code> om een meting op de (juiste) Arduino uit te laten voeren.  Tot slot leent de gebruiker een Arduino van een buurmens. De gebruiker sluit de tweede Arduino aan op de computer. Met <code>list</code> en <code>info</code> kijkt de gebruiker wat de poortnaam is van de tweede Arduino. Met het subcommando <code>scan</code> voert de gebruiker een meting uit en ziet dat het lampje van de tweede Arduino gaat branden en niet het lampje van de eerste Arduino. </p> <p><pre><code>(ECPC) &gt; diode scan \nerrorUsage: diode [OPTIONS] DEVICE\nTry 'diode --help' for help.\nError: Missing argument 'DEVICE'.\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De gebruiker moet een poortnaam meegeven.</li> <li> De gekozen device wordt ook daadwerkelijk gebruikt in het model en de controller.</li> <li> Als g\u00e9\u00e9n poortnaam wordt opgegeven, krijgt de gebruiker een foutmelding.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek</li> <li> Pythondaq: <code>--help</code></li> </ul> <p>Pythondaq: Grafiek</p> opdrachtcheck <p>Pas het subcommando <code>scan</code> aan zodat je met een boolean flag kan aangeven of er wel of niet een grafiek wordt getoond.  De gebruiker test het subcommando <code>scan</code> met de volgende handelingen. De gebruiker start een meting en geeft ook de optie <code>--graph</code> na afloop ziet de gebruiker een grafiek met daarin de metingen. Daarna start de gebruiker opnieuwe een meting en geeft dit keer de optie <code>--no-graph</code> mee, na afloopt van de meting ziet de gebruiker geen grafiek verschijnen. Tot slot start de gebruiker een meting en geeft daarbij geen van beide opties (`--graph/--no-graph) wederom ziet de gebruiker na afloop van de meting geen grafiek verschijnen.</p> <p>Checkpunten:</p> <ul> <li> De grafiek wordt alleen getoond wanneer <code>--graph</code> wordt meegegeven.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek</li> <li> Pythondaq: <code>--help</code></li> </ul> <p>Pythondaq: <code>--help</code></p> opdrachtcodecheck <p>Voeg helpteksten toe.  De gebruiker test de applicatie <code>diode</code> met de volgende handelingen. De gebruiker typt <code>diode --help</code> en bekijkt de helptekst. De gebruiker ziet dat er subcommando's zijn. Met <code>subcommando --help</code> test de gebruiker de helpteksten een voor een uit. Ook bekijkt de gebruiker de helpteksten over de argumenten en otpies. De helpteksten stellen de gebruiker in staat om de applicatie te begrijpen en te bedienen.</p> <p>Pseudo-code <pre><code>\"\"\"Summary containing ARGUMENTs.\n\nARGUMENT description of the argument.\n\"\"\"\n</code></pre> Testcode <pre><code>(ECPC) &gt; diode --help \nUsage: diode [OPTIONS] COMMAND [ARGS] ...\n    Options: \n        --help Show this message and exit.\n    Commands:\n        Subcommand Summary containing ARGUMENTs.\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De informatie in de helpteksten is voldoende om de applicatie te begrijpen en te bedienen.</li> <li> <code>diode --help</code> vertelt duidelijk welke subcommando's aanwezig zijn en wat ze doen.</li> <li> Bij alle subcommando's, is het duidelijk welke opties en argumenten er zijn, wat de standaardwaarden zijn en wat ze doen.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: commando's</li> <li> Pythondaq: <code>scan</code></li> <li> Pythondaq: herhaalmetingen</li> <li> Pythondaq: <code>list</code></li> <li> Pythondaq: <code>info</code></li> <li> Pythondaq: choose device</li> <li> Pythondaq: Grafiek</li> <li> Pythondaq: <code>--help</code></li> </ul> Pythondaq: <code>list --search</code> <p>Breid het commando <code>list</code> uit met een optie <code>--search</code> waarmee je niet een lijst van alle instrumenten krijgt, maar alleen de instrumenten die de zoekterm bevatten. Dus bijvoorbeeld: <pre><code>(ECPC) &gt; diode list \nThe following devices are connected to your computer:                                                                           \nASRL/dev/cu.SOC::INSTR\nASRL/dev/cu.MALS::INSTR\nASRL/dev/cu.AirPodsvanDavid-Wireles-1::INSTR\nASRL/dev/cu.Bluetooth-Incoming-Port::INSTR\nASRL/dev/cu.usbmodem143401::INSTR \n\n(ECPC) &gt; diode list -s usbmodem \nThe following devices match your search string:                                                                     \nASRL/dev/cu.usbmodem143401::INSTR \n</code></pre></p> <p>De lijst met instrumenten kan er op Windows heel anders uitzien. Sterker nog, op Windows is de lijst meestal vrij saai. Maar leen eens heel even een Arduino van iemand anders en je ziet dat er dan twee poorten in de lijst verschijnen.</p> <p>Pas \u2014 na het uitbreiden van <code>list</code> \u2014 de commando's <code>scan</code> en <code>info</code> aan zodat het niet nodig is om de volledige devicenaam mee te geven, maar alleen een zoekterm.</p> <p>Op dit punt hebben we de functionaliteit van ons snelle script van het vorige hoofdstuk bereikt. Dit was veel meer werk, maar het is veel flexibeler. Als je wilt meten met een andere Arduino, een ander bereik, of een andere stapgrootte dan type je gewoon een iets ander commando in de terminal. Je hoeft geen scripts meer aan te passen. Als je na een tijdje niet meer precies weet hoe het ook alweer werkte allemaal kun je dat snel weer oppakken door <code>--help</code> aan te roepen.</p> <p>Alle subcommando's implementeren</p> <p>Kijk nog eens terug naar het lijstje subcommando's die je in opdracht Subcommando's bedenken hebt opgeschreven. Heb je alles ge\u00efmplementeerd? Wat zou je willen dat je nog meer kan instellen? Als er tijd over is, kijk dan of dit lukt.</p> Rich Data-analyse <ol> <li> <p>argv staat voor: argument vector, een lijst met argumenten\u00a0\u21a9</p> </li> <li> <p>Merk op in de code hieronder: <code>_</code> is de weggooivariabele in Python. Het gaat ons erom dat de loop een aantal keer doorlopen wordt en we hoeven niets te doen met de loop index.\u00a0\u21a9</p> </li> <li> <p>Zie ook: The Python Standard Library \u21a9</p> </li> <li> <p>Zie voor meer informatie over flags de Click documentatie.\u00a0\u21a9</p> </li> <li> <p>Pallets. Click. URL: https://click.palletsprojects.com/.\u00a0\u21a9</p> </li> <li> <p>Will McGugan. Rich. URL: https://github.com/willmcgugan/rich.\u00a0\u21a9</p> </li> <li> <p>Will McGugan. Rich documentation. URL: https://rich.readthedocs.io/en/latest/.\u00a0\u21a9</p> </li> </ol>"},{"location":"cli/#een-interface-met-stijl","title":"Een interface met stijl","text":"<p>Ook command-line interfaces gaan met hun tijd mee. Vroeger waren ze per definitie zwart/wit en statisch, maar tegenwoordig worden interfaces vaak opgeleukt met kleur, emoji's en bewegende progressbars. Rich<sup>6</sup> is een project dat in recordtijd heel populair is geworden. Het bestaat pas sinds november 2019 en heeft precies twee jaar later meer dan 31000 verzameld. Dat is veel \u2014 en de populariteit is sindsdien nog verder toegenomen.</p> <p>Rich is ontzettend uitgebreid en heeft heel veel mogelijkheden. Voor ons project kan het handig zijn om een progressbar te gebruiken of met Rich een tabel weer te geven. De documentatie<sup>7</sup> van Rich is best goed, maar kan lastig zijn om een mooi overzicht te krijgen. Een serie van korte video tutorials kun je vinden bij calmcode. Iedere video duurt maar \u00e9\u00e9n tot twee minuten en laat mooi de mogelijkheden zien. Voor de functies die je wilt gebruiken kun je dan meer informatie opzoeken in de documentatie van Rich zelf.</p> <p>Rich</p> <p>Verrijk je interface met Rich. Doe dit naar eigen wens en inzicht.</p>"},{"location":"cli/#data-analyse","title":"Data-analyse","text":"<p>Door de $I,U$-karakteristiek van de (lichtgevende) diode te analyseren is het mogelijk om de constante van Boltzmann te bepalen. De stoomsterkte door een diode wordt gegeven door de Shockley diodevergelijking. Zie ook hoofdstuk diode.</p> <p>Lukt het, om binnen de te bepalen onzekerheid, overeenkomst te vinden met de literatuurwaarde? Een LED is helaas geen ideale diode dus dit kan lastig zijn.</p> <p>Model fitten</p> <pre><code>Fit het model van Shockley aan je $I,U$-karakteristiek. Welke parameters kun je bepalen? Overleg met je begeleider!\n</code></pre>"},{"location":"communicatie/","title":"Communicatie met een meetinstrument","text":"<p>Het hart van ieder experiment wordt gevormd door de metingen die worden uitgevoerd. Meetinstrumenten vervullen daarom een belangrijke rol bij het automatiseren van een experiment. De eerste stap die je zult zetten tijdens het ontwikkelen van een applicatie is het communiceren met het meetinstrument. We hebben gekozen voor een Arduino Nano 33 IoT,<sup>10</sup> een zeer compact stukje elektronica rondom een ARM-microcontroller. Naast het uitvoeren van analoge spanningsmetingen kan dit model ook analoge spanningen afgeven dat voor het experiment heel nuttig gaat blijken te zijn. We hebben \u2014 speciaal voor deze cursus \u2014 een stukje firmware<sup>1</sup> ontwikkeld.<sup>11</sup></p>"},{"location":"communicatie/#microcontrollers","title":"Microcontrollers","text":"<p>Computers \u2014 zoals de meesten van ons die kennen \u2014 zijn zeer krachtig en ontworpen om zo flexibel mogelijk te zijn. Ze draaien games, e-mail of rekenen klimaatmodellen door. Ze komen in veel vormen: desktops, laptops, tablets en telefoons. Ze bevatten veel losse componenten: snelle processor (CPU), veel geheugen (RAM), veel permanente opslag (SSD), complexe interfaces (HDMI, USB) en een besturingssysteem waarmee je verschillende programma's kunt opstarten en de computer kunt beheren. Computers zijn behoorlijk prijzig.</p> <p>Een microcontroller daarentegen is veel eenvoudiger. Ze zijn ontworpen voor een beperkte en specifieke taak. Ze hebben veel verschijningsvormen \u2014 de meeste onherkenbaar. Je vindt microcontrollers in de vaatwasser, de magnetron, een draadloos toetsenbord en auto's (letterlijk tientallen verspreid over de hele auto). Ze hebben dan een beperkte taak: ze reageren op de knopjes op je dashboard om het klimaat te regelen of een raam te openen en ze sturen de kleppen in een verbrandingsmotor aan. Microcontrollers bevatten CPU, RAM en SSD vaak in \u00e9\u00e9n chip en hebben beperkte interfaces (vaak letterlijk losse pinnetjes die je moet verbinden). De CPU is relatief gezien traag en de hoeveelheid geheugen klein. Voor de beperkte taak is dat niet erg. Een besturingssysteem is niet nodig: als je hem aanzet draait hij meteen het enige programma dat ooit ingeladen is (dit heet dan firmware). Microcontrollers zijn goedkoop en daarom ook uitermate geschikt voor hobbyprojecten.</p> <p>Een Arduino is zo'n microcontroller. Vaak wordt een Arduino vergeleken met een Raspberry Pi \u2014 een andere goedkope computer. Maar een Raspberry Pi is \u00e9cht een computer (en daarmee ook complex). Daarmee is een Raspberry Pi veel veelzijdiger, maar ook duurder en is het complexer om een eenvoudig programma te draaien. Apparatuur zoals frequentiegeneratoren en oscilloscopen hebben vaak een microcontroller ingebouwd, maar soms ook een microcomputer analoog aan een Raspberry Pi. Dat maakt voor ons weinig verschil zolang we maar weten hoe we het instrument kunnen aansturen.</p>"},{"location":"communicatie/#communicatieprotocol","title":"Communicatieprotocol","text":"<p>Hoe praat je eigenlijk met hardware? Voor fabrikanten zijn er een paar opties:</p> <ol> <li>Je maakt gebruik van een al bestaand protocol (een bestaande standaard) en je schrijft vervolgens documentatie specifiek voor jouw instrument (bijvoorbeeld de VISA-standaard<sup>12</sup>, onder andere gebruikt door Tektronix digitale oscilloscopen<sup>13</sup>).</li> <li>Je schrijft een proprietary<sup>2</sup> protocol en een bijbehorende bibliotheek die softwareontwikkelaars moeten gebruiken.<sup>3</sup> Voorbeelden zijn instrumenten van National Instruments<sup>14</sup> of de PicoScope digitale oscilloscopen<sup>4</sup> <sup>15</sup>.</li> </ol> <p>De VISA-standaard is veelgebruikt, maar helaas komen proprietary protocollen veel voor. Dat is jammer, want in het laatste geval moet je het doen met de software die geleverd wordt door de fabrikant. Als die jouw besturingssysteem of jouw favoriete programmeertaal niet ondersteunt, heb je simpelweg pech.</p> <p>Wij gaan gebruik maken van de VISA-standaard. VISA staat voor Virtual Instrument Software Architecture en is h\u00e9\u00e9l breed en definieert ook protocollen om te communiceren via allerlei verouderde computerpoorten en kabels. Hieronder zie je een voorbeeld van verschillende poorten zoals RS232 en GPIB aan de achterkant van een Tektronix TDS210 oscilloscoop. De VISA-standaard communiceert gelukkig ook via internet en USB, waarvan wij gebruik zullen maken.</p> <p> Bron: Wikimedia Commons.</p> <p>Onderdeel van VISA is de SCPI standaard <sup>16</sup>, wat staat voor Standard Commands for Programmable Instruments. Dit onderdeel definieert een bepaald formaat voor commando's die we naar ons instrument zullen sturen. De lijst met commando's die door de firmware van onze Arduino worden ondersteund is gegeven in de appendix.</p>"},{"location":"communicatie/#eerste-stappen","title":"Eerste stappen","text":"<p>Waarschuwing</p> <p>Let op dat je de weerstand van 220 \u03a9  gebruikt! Een te grote weerstand zorgt ervoor dat je nauwelijks iets kunt meten, maar een te kleine weerstand zorgt ervoor dat de stroomsterkte door de Arduino te groot wordt. In dat geval zul je de Arduino onherstelbaar beschadigen. De kleurcodes voor weerstanden vind je in de appendix.</p> <p>Schakeling bouwen</p> opdrachtbouwtekeningcheck <p>Je maakt een schakeling om de spanning over en de stroom door een LED te meten. Hiervoor maak je gebruik van een Arduino en een breadboard. Om de stroomsterkte te beperken zet je de LED in serie met een weerstand van 220 \u03a9. Je sluit twee spanningsmeters aan. Spanningsmeter 1 staat over de LED en de weerstand samen. Spanningsmeter 2 staat alleen over de weerstand.</p> <p>Theoretische schakeling</p> <p>Het circuit zoals je dat zou bouwen met twee losse voltmeters is hieronder weergegeven. De subscripts 0, 1 en 2 bij $U_0$, $U_1$ en $U_2$ verwijzen naar de kanalen waarmee de Arduino spanningen kan sturen of uitlezen. Deze kanalen worden in de volgende opgaves belangrijk.</p> <p> </p> <p>Praktische schakeling</p> <p>In het 3D-model<sup>5</sup> hieronder is een Arduino Nano 33 IoT op een 400-punt breadboard geschakeld met een LED en een weerstand van 220 \u03a9. In een breadboard zijn in iedere rij alle kolommen A t/m E met elkaar verbonden (zo ook kolommen F t/m J). Draadjes en/of componenten die naast elkaar zijn geprikt zijn dus met elkaar verbonden. De Arduino is geprikt in kolom D t/m H en van rij 1 t/m 15. De pin van de Arduino in rij 4 is verbonden middels het rode draadje met het pootje van de LED (de kleur van de draden is niet belangrijk, kies daarom altijd draden met een handige lengte). De platte zijde in de onderste ring van de LED wordt richting aarde geschakeld. Het ander pootje van de LED is verbonden met de weerstand. De kleurcodes voor weerstanden vind je in de appendix. Van de weerstand loopt een draadje naar de aarde van de Arduino (rij 12, kolom H). Met dit deel van de schakeling kan de Arduino een variabele spanning zetten over de LED en de weerstand. </p> <p>De pin van de Arduino in rij 5 is verbonden met de LED en meet de spanning over de LED en de weerstand. De pin van de Arduino in rij 6 is verbonden met de weerstand en meet alleen de spanning over weerstand.</p> <p> </p> <p>Besturing 3D-model</p> <p>Door de linkermuisknop ingedrukt te houden en te slepen kan je het 3D-model draaien. Met de rechtermuisknop kan je het model verplaatsen en door te scrollen kan je in- en uitzoomen.</p> <p>Checkpunten</p> <ul> <li> Je hebt een weerstand van 220 \u03a9 gebruikt.</li> <li> De platte kant in de dikkere ring onderaan de plastic behuizing van de LED staat richting de aarde geschakeld. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED.</li> <li> De andere kant van de LED is met een draadje verbonden met rij 4.</li> <li> Er loopt een draadje van rij 5 naar de LED.</li> <li> Er loopt een draadje van rij 6 naar de weerstand.</li> <li> Er loopt een draadje van de andere kant van de weerstand naar rij 12 (naar het pinnetje met bovenop een wit vlakje).</li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> <p>Info</p> <p>Om met Python via het VISA-protocol te kunnen communiceren met apparaten heb je specifieke packages nodig. Die gaan we later installeren in een virtual environment. Voor meer informatie over virtual environments zie de Appendix Virtual Environments. Tijdens testen is het vaak niet nodig om packages te installeren, maar je moet dan wel steeds opnieuw intypen wat je nodig hebt. Dat kun je misschien het beste copy/pasten vanuit het <code>code</code>-tabblad die in de opdracht staat. Voordat je de volgende opdracht kunt doen, zorg dat je uv ge\u00efnstalleerd hebt. Voor Windowscomputers, open een Terminal en type in (zonder het <code>&gt;</code>-symbool): Terminal<pre><code>&gt; winget install -e astral-sh.uv\n</code></pre> Belangrijk: uv werkt nu alleen in nieuw geopende terminals. Sluit de terminal die je open hebt staan dus af.</p> <p>PyVISA in terminal</p> opdrachtcodecheck <p>Je sluit de Arduino met een USB-kabel aan op de computer. In een <code>Terminal</code> open je een <code>pyvisa-shell</code> met een python backend. Om erachter te komen hoe de <code>pyvisa-shell</code> werkt type je het commando <code>help</code>. Je ziet een reeks aan commando's en bekijkt de helptekst van de commando's waarmee je denkt de <code>pyvisa-shell</code> te kunnen afsluiten. Wanneer je dit commando hebt gevonden sluit je daarmee de <code>pyvisa-shell</code> af. </p> <p>Pseudo-code Terminal<pre><code># open pyvisa-shell with python backend\n# check help of pyvisa-shell\n# check help of exit command\n# shut down the pyvisa-shell\n</code></pre> Testcode <pre><code>&gt; uvx --from pyvisa --with pyvisa-py --with pyserial pyvisa-shell --backend py \n\nWelcome to the VISA shell. Type help or ? to list commands.  \n(visa)\n\n</code></pre></p> <p><pre><code>(visa) help \n\nDocumented commands (type help <code>&lt;topic&gt;</code>):\n========================================\nEOF  attr  close  exit  help  list  open  query  read  termchar  timeout  write\n\n</code></pre> </p> <p>Checkpunten</p> <ul> <li> Na het openen van een <code>pyvisa-shell</code> staat er op een nieuwe regel <code>(visa)</code>.</li> <li> Als je <code>help</code> intypt verschijnt er een heel rijtje met commando's.</li> <li> Als je <code>help exit</code> intypt krijg je de hulpvaardige tekst: <code>Exit the shell session.</code></li> <li> Als je de <code>pyvisa-shell</code> met een commando afsluit staat daarna de naam (visa) niet meer op de laatste regel.</li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> <p>Info</p> <p>We gebruiken <code>uvx</code> om Python packages te draaien zonder ze te installeren. We starten <code>pyvisa-shell</code>, die afkomstig is uit het package <code>pyvisa</code> (<code>--from pyvisa</code>). We maken hier gebruik van de optie <code>--backend py</code>, wat staat voor gebruik backend: python. Het kan namelijk dat er naast <code>pyvisa-py</code> ook andere backends, of drivers, ge\u00efnstalleerd staan op het systeem die de VISA-communicatie kunnen verzorgen. Als je bijvoorbeeld LabVIEW ge\u00efnstalleerd hebt, dan heb je de drivers van National Instruments. De verschillende backends geven de aangesloten apparaten andere namen. Ook ondersteunen niet alle drivers alle type apparaten en moet je ze apart downloaden en installeren. Daarom maken we liever gebruik van de beschikbare Python drivers. We moeten dan wel meegeven dat we dat package ook nodig hebben (<code>--with pyvisa-py</code>) en omdat de Arduino is aangesloten op een seri\u00eble kabel<sup>6</sup> hebben we ook de PySerial package nodig (<code>--with pyserial</code>). Voluit wordt dan dus: <pre><code>uvx --from pyvisa --with pyvisa-py --with pyserial pyvisa-shell --backend py\n</code></pre> Dat dit aardig vervelend kan worden met intypen is waarschijnlijk wel duidelijk. Daarom gaan we op een later moment gebruik maken van virtual environments.</p> <p>PyVISA commando's <code>list</code> en <code>open</code></p> opdrachtcodecheck <p>Je bekijkt het lijstje met aangesloten apparaten door in de <code>pyvisa-shell</code> het commando <code>list</code> te typen. Je haalt de USB-kabel waarmee de Arduino aan de computer is aangesloten uit de computer en vraagt nogmaals de lijst met aangesloten apparaten op. Nu weet je welke poort de Arduino is. Je bekijkt daarna de helptekst van het commando <code>open</code>, waarna je de communicatie met de Arduino opent.</p> <p>Pseudo-code Terminal<pre><code># open pyvisa-shell with python backend\n# check list of connected devices\n# check help of open command\n# open Arduino\n</code></pre> Testcode <pre><code>(visa) list \n( 0) ASRL3::INSTR\n( 1) ASRL5::INSTR\n( 2) ASRL28::INSTR\n</code></pre></p> <p><pre><code>(visa) help open \nOpen resource by number, resource name or alias: open 3\n</code></pre> </p> <p>Checkpunten</p> <ul> <li> Na het commando <code>list</code> verschijnt er een lijst met een of meerdere apparaten.</li> <li> Als de Arduino niet op de computer is aangesloten is er een apparaat uit het lijstje verdwenen. </li> <li> Als je de Arduino opent verschijnt de tekst: </li> </ul> <pre><code>ASRL?::INSTR has been opened.\nYou can talk to the device using \"write\", \"read\" or \"query\".\nThe default end of message is added to each message.\n</code></pre> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> <p>PyVISA commando <code>query</code></p> opdrachtcodecheck <p>Je stuurt een commando naar de Arduino met <code>query COMMANDO</code>. In de documentatie van de firmware heb je het commando opgezocht om de identificatiestring uit te lezen. Nadat je dit commando naar de Arduino stuurt krijg je een error. Je leest rustig verder in het hoofdstuk om erachter te komen hoe je dit moet oplossen.</p> <p>Pseudo-code Terminal<pre><code># send query to get identification string \n</code></pre> Testcode <pre><code>(open) query gappie \nResponse: ERROR: UNKNOWN COMMAND gappie\n</code></pre> </p> <p>Checkpunten</p> <ul> <li> Je hebt het woord <code>query</code> goed geschreven en met kleine letters.</li> <li> Na het commando <code>query</code> volgt een spatie.</li> <li> Na de spatie staat het volledige commando om de identificatiestring uit te lezen, in hoofdletters (dus met <code>*</code> en <code>?</code>, want deze horen er ook bij!).</li> <li> Als je het commando verstuurt, verschijnt er de error: <pre><code>Response: ERROR: UNKNOWN COMMAND .....\n</code></pre></li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> <p>Een error, niet helemaal wat je had gehoopt! Als je goed kijkt in de documentatie van de firmware dan zie je dat er bepaalde terminator characters (regeleindes) nodig zijn. Dit zijn karakters die gebruikt worden om het einde van een commando te markeren. Het is, zogezegd, een enter aan het eind van een zin. Dit mag je heel letterlijk nemen. Oude printers voor computeruitvoer gebruikten een carriage return (CR) om de wagen met papier (typemachine) of de printerkop weer aan het begin van een regel te plaatsen en een line feed (LF) om het papier een regel verder te schuiven. Nog steeds is het zo dat in tekstbestanden deze karakters gebruikt worden om een nieuwe regel aan te geven. </p> <p>Carriage return line feed: typewriter demonstration</p> <p></p> <p>Jammer maar helaas, verschillende besturingssystemen hebben verschillende conventies. Windows gebruikt nog steeds allebei: een combinatie van carriage return + line feed (CRLF). Maar MacOS/Linux/Unix gebruiken enkel een line feed (LF), want hoeveel meer heb je nodig? Af en toe is dat lastig, vooral wanneer er elektronica in het spel is want dan willen de regeleindes voor schrijven en lezen nog wel eens verschillend zijn.<sup>7</sup></p> <p>Terminator characters demo</p> opdrachtcheck <p>Je vraagt je misschien af wat het betekent dat er bij het schrijven en lezen regeleindes gebruikt worden. Daarom open je de Termination Character Demo door een Terminal te starten en in te typen: <pre><code>uvx termchar-demo\n</code></pre> Je gaat naar de Basic tab, daar zie je twee inputvelden voor de client (dat ben jij) en de server (dat is de Arduino).</p> <p>Je schrijft een commando <code>measure_voltage</code> naar de Arduino (druk op Write). In het Input veld van de Arduino verschijnt jouw commando maar het staat nog niet in de Application Log, het is dus nog niet door de Arduino verwerkt. Want de Read Termination Characters van de Arduino zijn <code>\\n</code>(LF), die gaat dus pas lezen als die tekens zijn verstuurd. Je verstuurt <code>\\n</code> en ziet dat het commando wordt verwerkt en jij een antwoord krijgt. </p> <p>Steeds <code>\\n</code> handmatig versturen is onhandig daarom voer je bij de Client als Write Termination Characters <code>\\n</code> in. Je verstuurt nog een commando <code>measure_current</code>, drukt op Write en ziet dat het bericht direct door de Arduino wordt verwerkt en een antwoord terugstuurt. </p> <p>In het Input veld van de Client staan twee antwoorden van de Arduino, als je nu op Read drukt blijven de termination characters in de antwoorden staan en moet je ze handmatig uit elkaar gaan halen. Dat is niet handig, daarom vul je bij de Read Termination Characters van de Client <code>\\r\\n</code>(CRLF) in. Daarna druk je op Read en merk je dat de twee antwoorden apart uitgelezen worden, super handig!</p> <p>Checkpunten</p> <ul> <li> De Client Write Termination Characters is ingesteld op <code>\\n</code>.</li> <li> De Client Read Termination Characters is ingesteld op <code>\\r\\n</code>.</li> <li> Bij het versturen van een bericht naar de server wordt deze verwerkt en krijgt de client een antwoord terug.</li> <li> Bij het lezen van het antwoord door de client komen geen termination characters in de Application Log te staan.</li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> Terminator characters demo: input buffer en timeout <p>Ga opnieuw naar de Termination Character Demo en lees de laatste stappen van de Introduction tab. Open de Advanced tab en voer de stappen uit. </p> <p> Je gaat nu de regeleindes instellen in PyVISA:</p> <p>PyVISA regeleindes</p> opdrachtcodecheck <p>Je gaat weer terug naar de Terminal, en opent een pyvisa-shell. Je gebruikt het commando <code>termchar</code> om de regeleindes in te stellen. Om erachter te komen hoe je deze moet instellen vraag je de helptekst op met <code>help termchar</code>. Je vraagt eerst de huidige instellingen van de regeleindes op en ziet dat deze niet goed staan. Daarna stel je de read in op CRLF en de write op LF. Je bekijkt nog een keer de instellingen om te controleren of de regeleindes nu wel goed staan. Je gaat terug naar de opdracht PyVISA commando <code>query</code> en krijgt een response in plaats van een error. </p> <p>\\r\\n en CRLF</p> <p>Bij de Termination characters demo maakte je gebruik van <code>\\r\\n</code>, dat is de programmeertaal equivalent van <code>CRLF</code>.</p> <p>Pseudo-code Terminal<pre><code># get help of termchar command\n# check current termchar settings\n# adjust termchar settings in read = CRLF and write = LF\n# check new termchar settings\n# send query to get identification string\n</code></pre> Testcode <pre><code>(open) help termchar \nGet or set termination character for resource in use.\n<code>&lt;termchar&gt;</code> can be one of: CR, LF, CRLF, NUL or None.\nNone is used to disable termination character\nGet termination character:\n    termchar\nSet termination character read or read+write:\n    termchar <code>&lt;termchar&gt;</code> [<code>&lt;termchar&gt;</code>]\n</code></pre></p> <p>Checkpunten</p> <ul> <li> De regeleindes zijn ingesteld met het commando <code>termchar</code>. Na dit commando volgt een spatie. Daarachter volgen de karakters voor de read termchar, opnieuw gevolgd door een spatie met daarachter de karakters voor de write termchar. </li> <li> De read regeleinde staat ingesteld op CRLF.</li> <li> De write regeleind staat ingesteld op LF.</li> <li> Als je met het commando <code>termchar</code> de instellingen van de regeleindes opvraagt, staat er: <pre><code>Termchar read: CRLF write: LF\nuse CR, LF, CRLF, NUL or None to set termchar\n</code></pre></li> <li> Als je het commando <code>query</code> verstuurt om de identificatiestring uit te lezen, verschijnt er: <pre><code>Response: Arduino VISA firmware v1.1.0\n</code></pre></li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul> <p>Onzichtbare regeleindes</p> <p>Omdat de Arduino nu weet wanneer het commando voorbij is (door de LF aan het eind van de zin), krijg je antwoord! Dat antwoord heeft dan juist weer een CRLF aan het einde, dus <code>pyvisa-shell</code> weet wanneer het kan stoppen met luisteren en print het antwoord op het scherm. De karakters CRLF en LF zelf blijven onzichtbaar voor ons.</p> <p>PyVISA LED laten branden</p> opdrachtcodecheck <p>Je zoekt in de documentatie van de firmware op hoe je een spanning op het uitvoerkanaal zet. Je leest dat er een maximale waarde is voor de spanning en zet deze waarde op het uitvoerkanaal. Je ziet dat de LED brandt en er verschijnt een glimlach op je gezicht. </p> <p>Je bent benieuwd naar wat er gebeurt als je over de maximale spanning heen gaat en zet de maximale waarde + 1 op het uitvoerkanaal. Je denkt na over een verklaring voor wat je ziet gebeuren. </p> <p>Je weet dat een LED een drempelspanning nodig heeft om te branden. Je vult een paar waardes in tussen de minimale en maximale waarde om erachter te komen wat deze drempelspanning is. </p> <p>Pseudo-code Terminal<pre><code># set maximum voltage\n# set maximum voltage + 1\n# set threshold voltage\n</code></pre> Testcode  Zie documentatie van de firmware.  </p> <p>Checkpunten</p> <ul> <li> Je stuurt een commando naar de Arduino met behulp van het commando <code>query</code>.</li> <li> Je hebt woord <code>query</code> goed geschreven en met kleine letters.</li> <li> Je hebt het commando om een spanning op het uitvoerkanaal te zetten geschreven met hoofdletters.</li> <li> Je zet een spanning op uitvoerkanaal <code>0</code>.</li> <li> Achter het kanaalnummer staat een spatie.</li> <li> Na de spatie staat een geheel getal tussen 0 en 1023.</li> <li> Als je de waarde 828 naar uitvoerkanaal 0 stuurt gaat de LED branden.</li> </ul> <p>Projecttraject</p> <ul> <li> Schakeling bouwen</li> <li> PyVISA in terminal</li> <li> PyVISA commando's <code>list</code> en <code>open</code></li> <li> PyVISA commando <code>query</code></li> <li> Terminator characters demo</li> <li> PyVISA regeleindes</li> <li> PyVISA LED laten branden</li> </ul>"},{"location":"communicatie/#een-eenvoudig-script","title":"Een eenvoudig script","text":"<p>Je hebt via de shell contact gelegd met de hardware. Nu wordt het tijd om, met de documentatie<sup>17</sup> in de aanslag, hetzelfde vanuit Python te doen. Als je met een nieuw project begint is het helemaal geen gek idee om een kort script te schrijven waarin je wat dingen uitprobeert. Als alles lijkt te werken kun je het netjes gaan maken en gaan uitbreiden. We beginnen hier met een eenvoudig script en zullen dat daarna gaan verfijnen.</p> <p>We lopen het voorbeeldscript eerst regel voor regel door en geven het volledige script aan het eind. Je hoeft nu dus alleen maar te lezen en nog geen code uit te voeren. Allereerst importeer je de <code>pyvisa</code>-bibliotheek met: <pre><code>import pyvisa\n</code></pre> Binnen PyVISA wordt alles geregeld met behulp van een Resource Manager. Die krijg je met: <pre><code>rm = pyvisa.ResourceManager(\"@py\")\n</code></pre> Die kun je bijvoorbeeld gebruiken om een lijst van alle beschikbare poorten te krijgen: <pre><code>ports = rm.list_resources()\n\n# Bijvoorbeeld: (\"ASRL28::INSTR\",)\n</code></pre> Om nu daadwerkelijk verbinding te gaan maken met de Arduino moet je die openen. Daarvoor geef je de poortnaam op en vertel je meteen wat de instellingen moeten zijn voor de regeleindes bij het lezen (CRLF, <code>\"\\r\\n\"</code>) en bij het schrijven (LF, <code>\"\\n\"</code>): <pre><code>device = rm.open_resource(\n    \"ASRL28::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\n</code></pre> Tenslotte stuur je een query naar de Arduino: <pre><code>device.query(\"*IDN?\")\n</code></pre> Het volledige script \u2014 met een paar <code>print</code>-statements \u2014 ziet er dan als volgt uit (bekijk de code, druk op de runknop linksboven de code, maar type het nog niet in):</p>  test_arduino.py <pre><code>import pyvisa\n\nrm = pyvisa.ResourceManager(\"@py\")\nports = rm.list_resources()\nprint(ports)\n\ndevice = rm.open_resource(\n    \"ASRL28::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\nidentification = device.query(\"*IDN?\")\nprint(identification)\n</code></pre> <pre>\n<code>(ECPC) &gt; python test_arduino.py\n('ASRL28::INSTR',)\nArduino VISA firmware v1.1.0\n</code></pre> <p>De output van het script is afhankelijk van het systeem en het aantal apparaten dat verbonden is.</p> <p>Vergelijk script met <code>pyvisa-shell</code></p> opdrachtcheck <p>Met bovenstaande code heb je precies hetzelfde gedaan in Python als in de <code>pyvisa-shell</code>. Vergelijk de verschillende stappen hieronder met elkaar door met de muis over de tekst heen te gaan.</p> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <pre>\n<code>PS&gt; pyvisa-shell --backend py\n\nWelcome to the VISA shell. Type help or ? to list commands.\n\n(visa) list\n( 0) ASRL3::INSTR\n( 1) ASRL5::INSTR\n( 2) ASRL28::INSTR\n(visa) open 2\nASRL28::INSTR has been opened.\nYou can talk to the device using \"write\", \"read\" or \"query\".\nThe default end of message is added to each message.\n(open) termchar CRLF LF\nDone\n(open) query *IDN?\nResponse: Arduino VISA firmware v1.1.0\n</code></pre> <pre>\n<code>import pyvisa\n\nrm = pyvisa.ResourceManager(\"@py\")\nports = rm.list_resources()\nprint(ports)\n\ndevice = rm.open_resource(\n    \"ASRL28::INSTR\", \n    read_termination=\"\\r\\n\", \n    write_termination=\"\\n\"\n)\nidentification = device.query(\"*IDN?\")\nprint(identification)</code></pre> <p>Pythonscript aanmaken</p> opdracht <p>      Je gaat de gegeven Pythoncode testen. Hiervoor open je in Visual Studio Code de map <code>ECPC</code> en maak je een bestand <code>test_arduino.py</code> aan. Je kopieert de gegeven Pythoncode in dit bestand. Je ziet dat Visual Studio Code rechtsonder aangeeft dat je nog geen virtual environment hebt geselecteerd (de bruinige waarschuwing Select Interpreter). We moeten dus nog een environment aanmaken.      <code>ECPC</code>     \u251c\u2500\u2500<code>test_arduino.py</code>     \u2514\u2500\u2500\u2022\u2022\u2022 </p> <p>Environment aanmaken</p> opdrachtcheck <p>Open een Terminal in je Visual Studio Code-omgeving (Menu &gt; Terminal &gt; New Terminal). Maak de virtual environment aan met: Terminal<pre><code>uv venv -p 3.13\n</code></pre> Met <code>-p 3.13</code> geven we aan: gebruik Pythonversie 3.13 (released in 2024). Je mag dat weglaten en dan kiest uv op basis van Pythonversies die je al ge\u00efnstalleerd hebt staan, maar als je een te oude versie gebruikt werken sommige dingen misschien niet.</p> <p>Om een virtual environment daadwerkelijk te gebruiken kun je die activeren. Dat kun je doen door in de pop-up \"We've noticed that...\" te kiezen voor \"Yes\", of door rechtsonderin op Select Interpreter te klikken en dan te kiezen voor de omgeving (Python 3.13.x (ECPC) <code>.\\.venv\\Scripts\\python.exe</code>). Je moet de terminal dan sluiten (type <code>exit</code> of klik op het prullenbakje) en een nieuwe terminal openen. Als het terminal goed geactiveerd is staat er nu <code>(ECPC)</code> aan het begin van de prompt (opdrachtregel waar je je commando's intypt).</p> <p>Info</p> <p>Als je op Windows werkt, kun je bij het openen van een nieuwe terminal de volgende foutmelding krijgen: <pre><code>PS C:\\Users\\David\\Documents\\ECPC&gt; &amp; C:/Users/David/Documents/ECPC/.venv/Scripts/Activate.ps1\n&amp; : File C:\\Users\\David\\Documents\\ECPC\\.venv\\Scripts\\Activate.ps1 cannot be loaded \nbecause running scripts is disabled on this system. For more information, see \nabout_Execution_Policies at https:/go.microsoft.com/fwlink/?LinkID=135170.\nAt line:1 char:3\n+ &amp; C:/Users/David/Documents/ECPC/.venv/Scripts/Activate.ps1\n+   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : SecurityError: (:) [], PSSecurityException\n    + FullyQualifiedErrorId : UnauthorizedAccess\n</code></pre> Los dit op door na de foutmelding het volgende in te typen in je terminal: <pre><code>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned\n</code></pre> Open daarna nogmaals een nieuwe terminal. Nu moet je w\u00e9l <code>(ECPC)</code> aan het begin van de prompt zien staan.</p> <p>Installeer de benodigde packages met: Terminal<pre><code>uv pip install pyvisa pyvisa-py pyserial\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Je hebt een virtual environment aangemaakt.</li> <li> De environment bevat de packages <code>pyvisa</code>, <code>pyvisa-py</code> en <code>pyserial</code>. </li> <li> De environment is geactiveerd (er staat <code>(ECPC)</code> aan het begin van de prompt).</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <p>PyVISA in Pythonscript</p> opdrachtcodecheck <p>      Je gaat de gegeven Pythoncode testen. Je selecteert het environment dat je bij opdracht Environment aanmaken hebt gemaakt. Je slaat het bestand op en runt het bestand.      <code>ECPC</code>     \u251c\u2500\u2500<code>test_arduino.py</code>     \u2514\u2500\u2500\u2022\u2022\u2022 </p> <p>could not open port 'COM28': FileNotFoundError</p> <p>Krijg je een <code>FileNotFoundError</code>? Dan kan het zijn dat het script een poort probeert te openen die bij jou een andere naam heeft. Probeer met het lijstje instrumenten te raden welke poort de Arduino is en pas het script aan totdat het werkt.<sup>8</sup></p> <p>could not open port 'COM3': PermissionError</p> <p>Krijg je een <code>PermissionError</code>? Dan heb je vast nog een terminal openstaan waarin <code>pyvisa-shell</code> actief is. Sluit deze eerste af.</p> <p>Pseudo-code <pre><code># import pyvisa package\n# create resource manager\n# get list resources\n# open device\n# send query to get identification string\n</code></pre> Testcode  test_arduino.py <pre><code>...\n\nprint(ports)\nprint(identification)\n</code></pre> <pre>\n<code>(ECPC) &gt; python test_arduino.py\n('ASRL28::INSTR',)\nArduino VISA firmware v1.1.0\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Je hebt het juiste environment geselecteerd (zie ook paragraaf Virtual environments).</li> <li> Je opent de poort met de naam van jouw Arduino (in het geval dat jouw Arduino niet 'ASRL28::INSTR' heet). </li> <li> Je hebt alle terminals (ook de <code>Terminal</code> buiten Visual Studio Code) gesloten waarin communicatie met de Arduino openstond. </li> <li> Je krijgt een lijst met poorten en de identificatiestring terug als je het script runt.</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <p>LED laten branden</p> opdrachtcodecheck <p>      Om straks de $I,U$-karakteristiek van een LED te kunnen bepalen, ga je nu eerst een reeks spanningen naar de LED sturen. Hierdoor gaat de LED branden. Je maakt hiervoor een bestand <code>test_LED.py</code> aan in de map <code>ECPC</code>. Je schrijft eerst een regel code waarmee je een commando naar de Arduino stuurt waardoor de LED gaat branden. Daarna schrijf je de code om zodat de spanning oploopt van de minimale waarde tot aan de maximale waarde.      <code>ECPC</code>     \u251c\u2500\u2500<code>test_arduino.py</code>     \u251c\u2500\u2500<code>test_LED.py</code>     \u2514\u2500\u2500\u2022\u2022\u2022 </p> <p>f-strings</p> <p>Het sturen van commando's naar de Arduino waar een variabele spanning in staat gaat gemakkelijk met f-strings. Voor meer informatie zie de paragraaf f-strings.</p> <p>Pseudo-code <pre><code># import pyvisa package\n# create resource manager\n# get list resources\n# open device\n# send query to get identifaction string\n#\n# for value in min to max\n#   send query to set output channel to value\n</code></pre> Testcode  test_LED.py <pre><code>...\nfinal_value = device.query(\"OUT:CH0?\")\nprint(final_value)\n</code></pre> <pre>\n<code>(ECPC) &gt; python test_LED.py\n1023\n</code></pre> </p> <p>Checkpunten</p> <ul> <li> Je hebt het juiste environment geselecteerd (zie ook paragraaf Virtual environments).</li> <li> Je opent de poort met de naam van jouw Arduino (in het geval dat jouw Arduino niet 'ASRL28::INSTR' heet). </li> <li> Je hebt alle terminals (ook de <code>Terminal</code> buiten Visual Studio Code) gesloten waarin communicatie met de Arduino openstond. </li> <li> Je krijgt een lijst met poorten en de identificatiestring terug als je het script runt.</li> <li> Je laat de spanning oplopen van de minimale tot de maximale waarde. </li> <li> Als je goed kijkt zie je de LED vertraagd oplichten.</li> <li> Als je de waarde op kanaal 0 opvraagt aan het eind van de reeks met <code>OUT:CH0?</code> krijg je <code>1023</code> terug.</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <p>flashingLED</p> opdrachtcodecheck <p>      Om bekend te raken met de code maak je een nieuw bestand <code>flashingLED.py</code> aan in de map <code>ECPC</code>. Hierin schrijf je code om de LED in een regelmatig tempo te laten knipperen.      <code>ECPC</code>     \u251c\u2500\u2500<code>test_arduino.py</code>     \u251c\u2500\u2500<code>test_LED.py</code>     \u251c\u2500\u2500<code>flashingLED.py</code>     \u2514\u2500\u2500\u2022\u2022\u2022 </p> <p>Info</p> <p>Je kan hiervoor gebruik maken van de module time die standaard met Python meekomt.<sup>9</sup> Met de functie <code>sleep()</code> kun je de executie van de volgende regel in het script met een aantal seconden uitstellen.</p> <pre><code>import time\n# wait 28 second\ntime.sleep(28)\n</code></pre> <p>Pseudo-code <pre><code># import pyvisa package\n# create resource manager\n# get list resources\n# open device\n# send query to get identification string\n#\n# repeat:\n#   send query set output channel to max\n#   wait\n#   send query set output channel to min\n#   wait\n</code></pre> Testvoorbeeld</p> <p></p> <p>Checkpunten</p> <ul> <li> De LED staat een tijd aan en een tijd uit.</li> <li> Het aan- en uitgaan van de LED herhaald zich enkele keren.</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <p>Meer knipperritmes</p> <p>Breid het bestand <code>flashingLED.py</code> uit met meer knipperritmes. Bijvoorbeeld:</p> <ul> <li>Maak een SOS light \u2014 een lamp die in morsecode het signaal SOS uitzendt.</li> <li>Maak een breathing light \u2014 een lamp die langzaam aan- en uitgaat gevolgd door een pauze in het tempo dat iemand in- en uitademt.</li> <li>Maak een heartbeat light \u2014 een lamp die twee keer kort na elkaar flitst gevolgd door een pauze in het tempo van een hartslag.</li> <li>Bedenk je eigen knipperritme.</li> </ul> <ol> <li> <p>Firmware is software die in hardware is geprogrammeerd. Bijvoorbeeld het computerprogramma dat ervoor zorgt dat je magnetron reageert op de knoppen en je eten verwarmd.\u00a0\u21a9</p> </li> <li> <p>Proprietary betekent dat een bedrijf of een individu exclusief de rechten heeft over het protocol of de software en anderen geen toegang geeft tot de details.\u00a0\u21a9</p> </li> <li> <p>Niet zelden zijn dergelijke bibliotheken maar op een paar besturingssystemen beschikbaar als driver. Wordt een driver alleen op Windows ondersteund en gebruik jij MacOS in plaats van Windows? Dan kun je je dure meetinstrument dus niet gebruiken totdat je overstapt.\u00a0\u21a9</p> </li> <li> <p>Die overigens op vrijwel alle platforms en voor veel programmeertalen bibliotheken leveren.\u00a0\u21a9</p> </li> <li> <p>Dit model bevat twee 3D modellen die zijn gecre\u00eberd door Lara Sophie Sch\u00fctt en AppliedSBC en zijn gedeeld onder respectievelijk een CC-BY en CC-BY-SA licentie. De originele modellen zijn te vinden via [CC0] Set of Electronic Components en Arduino Nano 33 IoT. De modellen zijn samengevoegd en voorzien van een Arduino texture een aangepaste LED texture en draden. Dit 3D model heeft een CC-BY-SA licentie.\u00a0\u21a9</p> </li> <li> <p>USB staat voor Universal Serial Bus, oftewel een universele standaard voor seri\u00eble communicatie. Dat mag je vergeten.\u00a0\u21a9</p> </li> <li> <p>De regeleindes voor de Arduino firmware zijn verschillend voor lezen en schrijven. Dit heeft een oninteressante reden: bij het ontvangen van commando's is het makkelijk om alles te lezen totdat je \u00e9\u00e9n bepaald karakter (LF) tegenkomt. Bij het schrijven gebruikt de standaard <code>println</code>-functie een Windows-stijl regeleinde (CRLF).\u00a0\u21a9</p> </li> <li> <p>Tip: als je de Arduino loshaalt en weer aansluit is het de nieuwe regel in het lijstje.\u00a0\u21a9</p> </li> <li> <p>Zie ook: The Python Standard Library \u21a9</p> </li> <li> <p>Arduino AG. Arduino nano 33 iot. URL: https://store.arduino.cc/arduino-nano-33-iot.\u00a0\u21a9</p> </li> <li> <p>David B.R.A. Fokkema. Arduino visa firmware. 2020. URL: https://github.com/davidfokkema/arduino-visa-firmware.\u00a0\u21a9</p> </li> <li> <p>IVI Foundation. Vpp-4.3: the visa library. 2018. URL: https://www.ivifoundation.org/downloads/Architecture Specifications/IVIspecstopost10-22-2018/vpp43_2018-10-19.pdf.\u00a0\u21a9</p> </li> <li> <p>Tektronix, Inc. URL: https://www.tek.com/.\u00a0\u21a9</p> </li> <li> <p>National Instruments Corp. URL: https://www.ni.com/.\u00a0\u21a9</p> </li> <li> <p>Pico Technology Limited. URL: https://www.picotech.com/.\u00a0\u21a9</p> </li> <li> <p>SCPI Consortium. Standard commands for programmable instruments (scpi). 1999. URL: https://www.ivifoundation.org/docs/scpi-99.pdf.\u00a0\u21a9</p> </li> <li> <p>PyVISA Authors. Pyvisa: control your instruments with python. URL: https://pyvisa.readthedocs.io/en/latest/.\u00a0\u21a9</p> </li> </ol>"},{"location":"diodes/","title":"De diode: een p-n-overgang","text":"<p>In het introductie-experiment meten we de $I,U$-karakteristiek van een LED, een lichtgevende diode. In dit hoofdstuk gaan we iets dieper in op het aspect diode.</p> <p>Uiteindelijk is een diode een eenrichtingsweg voor stroom. Dat wil zeggen: er kan maar in \u00e9\u00e9n richting stroom door de diode lopen. De diode heeft een lage weerstand, maar als de polariteit wordt omgedraaid dan is de weerstand plots zeer groot en loopt er nauwelijks stroom. Diodes kunnen bijvoorbeeld gebruikt worden als gelijkrichter waarbij een wisselspanning met een stelsel diodes wordt omgezet in een gelijkspanning. Ook zijn er dus diodes die licht geven. Het fysisch principe achter een diode zorgt ervoor dat er, in sommige gevallen, zeer energiezuinig licht geproduceerd kan worden.</p>"},{"location":"diodes/#halfgeleiders","title":"Halfgeleiders","text":"<p>Metalen zijn geleiders. Ze hebben in de buitenste schil \u00e9\u00e9n of enkele valentie-elektronen die vrij kunnen bewegen in het kristalrooster. Een potentiaalverschil (veroorzaakt door bijvoorbeeld een batterij) zorgt voor een stroom van elektronen. Bij een isolator zitten alle elektronen vast in het rooster. Bij een halfgeleider is dat eigenlijk ook zo \u2014 de valentie-elektronen zijn nodig voor de bindingen tussen de atomen \u2014 maar door trillingen in het rooster is het relatief eenvoudig om af en toe een elektron-gat-paar te cre\u00ebren: een elektron ontsnapt en kan door het kristalrooster bewegen, maar de achtergebleven atomen missen nu een bindingselektron (het gat). Naburige elektronen kunnen heel eenvoudig in dit gat springen, maar laten dan weer een gat achter. Op deze manier kunnen gaten ook vrij door het rooster reizen. Een gat heeft effectief een positieve lading.</p>"},{"location":"diodes/#p-type-en-n-type-halfgeleiders","title":"p-type en n-type halfgeleiders","text":"<p>Halfgeleiders kunnen gedoteerd worden met andere stoffen. Feitelijk worden onzuiverheden in het kristalrooster ingebracht. Als je elementen uit de stikstofgroep (vijf valentie-elektronen) toevoegt aan de halfgeleider silicium (vier valentie-elektronen) dan worden de vreemde atomen in het kristalrooster gedwongen tot het aangaan van vier covalente bindingen met naburige siliciumatomen. Hierdoor blijft een elektron over. Dit elektron kan vrij door het rooster bewegen en op deze manier zijn er dus veel extra vrije elektronen aan het materiaal toegevoegd. Dit is een n-type halfgeleider omdat de ladingsdragers negatief geladen zijn.</p> <p>Op eenzelfde manier kunnen elementen uit de boorgroep (drie valentie-elektronen) worden toegevoegd aan silicium. Het is alleen niet mogelijk om vier covalente bindingen aan te gaan en er ontstaat plaatselijk een gat, een positieve ladingsdrager. Dit wordt dus een p-type halfgeleider genoemd. Hoewel gaten zich vrij door het rooster kunnen bewegen gaat dit wel trager dan bij elektronen.</p> <p>Merk op dat hoewel n-type en p-type halfgeleiders beschikken over respectievelijk negatieve en positieve ladingsdragers ze als geheel neutraal zijn. De onzuiverheden in het rooster blijven wel achter als ion als er geen vrije ladingsdrager in de buurt is. Immers, stikstof is neutraal met vijf valentie-elektronen dus als het vijfde elektron vrij door het rooster is gaan bewegen blijft een positief ion achter. Een booratoom blijft achter als een negatief ion als het gat vertrokken is (en een extra elektron de binding heeft opgevuld).</p>"},{"location":"diodes/#p-n-overgangen","title":"p-n-overgangen","text":"<p>Wanneer een p-type en een n-type halfgeleider elektrisch contact maken<sup>1</sup> dan kunnen de elektronen en de gaten elkaar in het midden tegenkomen. Immers, door diffusie verplaatsen de elektronen en gaten zich willekeurig door het materiaal.</p> <p></p> <p>Elektronen (zwart) en gaten (wit) zijn de vrije ladingsdragers in respectievelijk n-type en p-type halfgeleiders. Wanneer beide typen elektrisch contact maken kunnen elektronen en gaten de grenslaag oversteken en recombineren.</p> <p>Het extra elektron kan een tekort aanvullen en alle naburige atomen kunnen zo vier covalente bindingen aangaan. Het elektron en het gat heffen elkaar dus op recombinatie. Dit is energetisch voordelig, maar er ontstaat in het midden een sperlaag<sup>2</sup> waar geen vrije ladingsdragers meer aanwezig zijn. Dit betekent echter wel dat de onzuiverheden (ionen!) ervoor zorgen dat het materiaal niet langer neutraal is, maar elektrisch geladen. Waar de elektronen verdwenen zijn blijven positieve ionen achter en omgekeerd voor de gaten. Er ontstaat zo een elektrisch veld dat de elektronen en gaten tegenhoudt. Buiten de sperlaag is er geen elektrisch veld, net als bij een condensator.<sup>3</sup> Elektronen en gaten kunnen niet langer de sperlaag oversteken.</p> <p></p> <p>Na recombinatie van elektronen (zwart) en gaten (wit) ontstaat er een sperlaag waar geen vrije ladingsdragers meer aanwezig zijn. De gedoteerde atomen vormen ionen in het rooster en er onstaat een postief geladen gebied en een negatief geladen gebied. Buiten de sperlaag is geen veld aanwezig, net als bij een condensator. Het resulterende elektrisch veld remt eerst en stopt uiteindelijk de diffusie van de elektronen en gaten. Er ontstaat een evenwicht waarbij vrije ladingsdragers de grenslaag niet meer kunnen oversteken.</p>"},{"location":"diodes/#sperrichting","title":"Sperrichting","text":"<p>Wanneer een diode wordt verbonden met een elektrisch circuit is de richting van het potentiaalverschil van belang. Wanneer het p-type halfgeleider verbonden wordt met de negatieve pool en het n-type met de positieve pool dan ontstaat er een elektrisch veld in de zelfde richting als dat van de sperlaag. Hierdoor wordt het veld sterker en zullen vrije ladingsdragers de sperlaag zeker niet kunnen oversteken. De diode staat in sperrichting en er zal nauwelijks<sup>4</sup> stroom lopen. Een andere manier om dit in te zien is dat de gaten naar de negatieve pool worden getrokken en het gebied rond de sperlaag verlaten. Daar blijven nu dus nog meer negatieve ionen achter; de sperlaag wordt dikker. Idem aan de andere zijde van de sperlaag.</p>"},{"location":"diodes/#doorlaatrichting","title":"Doorlaatrichting","text":"<p>Wanneer we de polariteit omdraaien en de p-typezijde verbinden aan de positieve pool en de n-typezijde aan de negatieve pool dan ontstaat er een elektrisch veld van p-type naar n-type, tegengesteld aan het sperveld. Wanneer het potentiaalverschil op de diode \u2014 ten gevolge van een externe spanningsbron \u2014 lager is dan het potentiaalverschil over de sperlaag, dan zal er nog steeds geen stroom kunnen lopen. De sperlaag wordt echter wel dunner. Wanneer het externe potentiaalverschil groter is, dan keert het netto elektrisch veld in de sperlaag om en kunnen gaten en elektronen de grenslaag oversteken. Er loopt een stroom, maar wel anders dan in een geleider. De gaten en elektronen recombineren in het gebied van de grenslaag, terwijl er aan de metaal/halfgeleider grenzen nieuwe elektron-gatparen worden gevormd. Er stromen aan de zijde van de n-type halfgeleider dus continu elektronen vanuit het metaal naar de grenslaag en aan de zijde van de p-type halfgeleider stromen continu gaten van het metaal naar de grenslaag. Aan de grenslaag metaal/p-type halfgeleider verlaten elektronen de halfgeleider (en zo ontstaan de gaten). Voor de vrije ladingsdragers is de weerstand in de halfgeleider vrij laag waardoor de stroomsterkte flink kan oplopen. Een diode geleidt dus in de doorlaatrichting, maar pas boven een minimale doorlaatspanning.</p>"},{"location":"diodes/#lichtgevende-diode","title":"Lichtgevende diode","text":"<p>Wanneer een elektron en een gat elkaar tegenkomen is het energetisch gunstiger om te recombineren. Het elektron bindt zich aan de atomen in het rooster. Hierbij komt dus energie vrij. Meestal is dit in de vorm van roostertrillingen (warmte). Wanneer de materialen goed gekozen worden is het mogelijk om het energieverlies niet dominant via roostertrillingen te laten verlopen, maar via emissie van licht. Bij een doorzichtige halfgeleider kan het licht de grenslaag verlaten en uitgestraald worden. De LEDs die wij gebruiken bestaan uit een heel klein stukje halfgeleidermateriaal in een kegelvormige reflector om het licht naar boven te richten. Het geheel is ter bescherming in kunststof gegoten en de bolvorm zorgt voor een lenseffect om zoveel mogelijk licht in \u00e9\u00e9n richting uit te stralen.</p>"},{"location":"diodes/#de-iu-karakteristiek-van-een-diode","title":"De I,U-karakteristiek van een diode","text":"<p>Shockley, \u00e9\u00e9n van de uitvinders van de transistor, ontwikkelde een model voor p-n-overgangen. Volgens dat model<sup>7</sup> wordt de stroomsterkte gegeven door</p> <p>\\begin{equation}   I = I_\\mathrm{S} \\left(e^\\frac{V_\\mathrm{D}}{nV_\\mathrm{T}} - 1 \\right), \\end{equation} met $I$ de diodestroom, $I_\\mathrm{S}$ de diodelekstroom, $V_\\mathrm{D}$ de spanning over de diode, $n$ de kwaliteitsfactor van de diode en $V_\\mathrm{T}$ de thermal voltage gegeven door \\begin{equation}   V_\\mathrm{T} = \\frac{kT}{q}, \\end{equation} met $k$ de constante van Boltzmann, $T$ de temperatuur van het materiaal en $q$ de elementaire lading. De diodelekstroom is de stroomsterkte ten gevolge van de minderheidsladingsdragers<sup>5</sup> \u2014 het kleine aantal vrije elektronen in p-type halfgeleider en het kleine aantal gaten in n-type halfgeleider.</p> <p></p> <p>De stroom door een diode ten gevolge van de spanning over de diode.</p> <ol> <li> <p>In de praktijk worden er geen twee losse halfgeleiders aan elkaar verbonden maar wordt een enkel siliciumkristal zeer selectief plaatselijk verontreinigd: de ene helft om een p-type te maken, de andere helft om een n-type te maken.\u00a0\u21a9</p> </li> <li> <p>Engels: depletion zone.\u00a0\u21a9</p> </li> <li> <p>Zie o.a. Giancoli<sup>6</sup> voor een beschrijving van het veld van twee vlakke en tegengesteld geladen schijven.\u00a0\u21a9</p> </li> <li> <p>Bedenk dat in een niet-gedoteerde halfgeleider door roostertrillingen elektron-gat-paren worden gevormd waardoor de halfgeleider een beetje geleidt. Dit gebeurt \u00f3\u00f3k in een gedoteerde halfgeleider. In n-type komen dus ook (weinig) gaten voor, en in p-type ook (weinig) elektronen. Deze kunnen de sperlaag wel oversteken en er zal dus toch een zeer kleine stroom kunnen lopen.\u00a0\u21a9</p> </li> <li> <p>Engels: minority charge carriers. \u21a9</p> </li> <li> <p>D.C. Giancoli. Physics for Scientists and Engineers with Modern Physics. Pearson Education, 2008. ISBN 9780131495081. URL: https://books.google.nl/books?id=xz-UEdtRmzkC.\u00a0\u21a9</p> </li> <li> <p>W. Shockley. The theory of p-n junctions in semiconductors and p-n junction transistors. Bell System Technical Journal, 28(3):435\u2013489, 1949. URL: https://onlinelibrary.wiley.com/doi/abs/10.1002/j.1538-7305.1949.tb03645.x, arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/j.1538-7305.1949.tb03645.x, doi:10.1002/j.1538-7305.1949.tb03645.x.\u00a0\u21a9</p> </li> </ol>"},{"location":"docstrings/","title":"Docstrings","text":"<p>Documentatie is vaak een onderschoven kindje, maar is ontzettend belangrijk. Als je zelf informatie opzoekt over bijvoorbeeld een voor jou onbekende Pythonbibliotheek dan vind je het heel fijn als er een duidelijke tutorial is. Als je code schrijft die ook door andere mensen gebruikt moet worden dan is documentatie nodig. Als de code langer mee moet gaan dan zeg een paar weken, dan helemaal. Want over een paar weken ben jij zelf een ander persoon. Hoe vervelend het ook is, code die je nota bene zelf geschreven hebt, is over een paar weken niet meer glashelder. Je zult dan moeten uitzoeken hoe je ook alweer iets hebt gedaan of wat de gedachte erachter was.</p> <p>Tot nu toe heb je waarschijnlijk gebruikgemaakt van <code># stukjes commentaar</code> om duidelijk te maken wat je code doet. Maar als je de applicatie aan het gebruiken bent en je wilt weten wat een bepaalde functie eigenlijk doet, moet je de code induiken op zoek naar de betreffende functie. Met docstrings \u2014 documentatiestrings \u2014 is dat verleden tijd. De documentatie over een functie kan automatisch gegenereerd worden vanuit je code met behulp van de docstring. </p> <p>Docstrings staan tussen drie dubbele aanhalingstekens en hebben doorgaans een vaste structuur:<sup>1</sup> De eerste regel van de docstring geeft een korte samenvatting, na de witregel komt een langere samenvatting. Met <code>Args:</code> worden alle argumenten opgesomd die aan de functie worden meegegeven en <code>Returns:</code> geeft aan wat de functie teruggeeft. Je kunt de documentatie opvragen met de <code>help()</code>-functie. Zo vraag je bijvoorbeeld de documentatie van onderstaande functie op met <code>help(integers_up_to)</code>. Dat geeft het resultaat zoals gegeven (druk op ).</p>  integers_up_to.py <pre><code>def integers_up_to(number):\n    \"\"\"List integers up to a given number.\n\n    Args:\n        number (int): list integers up to this number\n\n    Returns:\n        list: containing the integers\n    \"\"\"\n    if number &gt; 1:\n        return list(range(1, number))\n    else:\n        return []\n\n\nhelp(integers_up_to)\n</code></pre> <pre>\n<code>(ECPC) &gt; python integers_up_to.py\nHelp on function integers_up_to in module __main__:\n\nintegers_up_to(number)\n    List integers up to a given number.\n\n    Args:\n        number (int): list integers up to this number\n\n    Returns:\n        list: containing the integers\n</code></pre> <p>Je zult misschien niet altijd de <code>help()</code>-functie gebruiken, maar gebruik zoveel mogelijk docstrings \u2014 ze helpen ook enorm als je de code leest. Het is extra werk maar het verdient zich dubbel en dwars terug. Je hoeft geen proza te schrijven, maar wees duidelijk. Lees voor meer voorbeelden en handvaten bijvoorbeeld de Google Python Style Guide.<sup>3</sup></p>"},{"location":"docstrings/#docstring-generator","title":"Docstring generator","text":"<p>Om het gemakkelijker te maken om docstrings ook \u00e9cht te gaan schrijven, zijn er docstring generators ontwikkeld. Voor Visual Studio Code is er de extensie autoDocstring - Python Docstring Generator.<sup>4</sup></p> <p>autodocstring</p> opdrachtcheck <p>Kijk in Visual Studio Code bij extensions hoe je de docstring generator autoDocstring kunt gebruiken. Kies daarvoor in de linkerkantlijn het goede icoon voor extensions en selecteer dan de extensie autoDocstring. Zoek in de documentatie op hoe je automatisch (een deel van) de docstring kunt genereren.</p> <p>Projecttraject</p> <ul> <li> autodocstring</li> </ul> <p>Wanneer je voor de functie <code>integers_up_to()</code> de docstring generator gebruikt, krijg je het volgende: <pre><code>def integers_up_to(number):\n\"\"\"_summary_\n\nArgs:\n    number (_type_): _description_\n\nReturns:\n    _type_: _description_\n\"\"\"\nif number &gt; 1:\n    return list(range(1, number))\nelse:\n    return []\n</code></pre></p> <p>Zo kun je gemakkelijk de docstring invullen. Je kunt met Tab naar het volgende veld om de docstring snel in te vullen, zolang je niet op Esc drukt. Het is mooi als je daarna onder de summary nog een uitgebreidere uitleg geeft van een paar zinnen. Vergeet ook niet om de docstring zonodig bij te werken als je een functie aanpast. </p> <p>Pythondaq: docstrings</p> opdrachtcodecheck <p>Alle code van je <code>pythondaq</code>-applicatie voorzie je van docstrings. Je hebt in de Google Python Style Guide<sup>3</sup> opgezocht waar je docstrings moet plaatsen. </p> <p>Daarna test je het gemak van docstrings uit. Je bent aan het werk in je model (<code>diode_experiment.py</code>) en ziet dat er gebruik wordt gemaakt van een method <code>get_input_voltage()</code> die in de controller (<code>arduino_device.py</code>) staat. Je vraagt je ineens af wat deze method ook al weer doet. Voorheen ging je dan naar de controller en scrolde je naar de method <code>get_input_voltage()</code>. Maar tegenwoordig heb je overal docstrings geschreven. Je blijft daarom in het model, je houd je muis bij <code>get_input_voltage()</code> en je ziet daar je fantastische omschrijving van de method die in de controller staat! </p> <p>Pseudo-code <pre><code># class ArduinoVISADevice\n    \"\"\"Summary of class\n\n    Longer class information...\n    Longer class information...\n    \"\"\"\n#   ...\n</code></pre> Testcode:  arduino_device.py <pre><code>if __name__ == \"__main__\":\n    help(ArduinoVISADevice)\n</code></pre> <pre>\n<code>(ECPC) &gt; python arduino_device.py\nHelp on class ArduinoVISADevice in module main:\nclass ArduinoVISADevice(builtins.object)\n|  Summary of class\n|\n|  Longer class information...\n|  Longer class information...\n|\n|  Data descriptors defined here:\n|\n-- More --\n</code></pre> </p> <p>Checkpunten:</p> <ul> <li> De controller, het model \u00e9n de view zijn voorzien van docstrings.</li> <li> Er staan docstrings bij onder andere functies, classes en methods.</li> <li> De docstrings hebben een vaste structuur volgens de Google Python Style Guide.<sup>3</sup></li> <li> De docstrings zijn volledig.</li> <li> De docstrings bevatten noodzakelijke en nuttige informatie.</li> </ul> <p>Projecttraject:</p> <ul> <li> Pythondaq: docstrings</li> <li> Pythondaq: uv</li> <li> Pythondaq: src-layout</li> <li> Pythondaq: test imports</li> <li> Pythondaq: applicatie</li> </ul> Material for MkDocs <ol> <li> <p>Die vaste structuur wordt niet door Python afgedwongen, maar is een goed gebruik. Er worden verschillende stijlen gebruikt. E\u00e9n van de meest gebruikte stijlen is door programmeurs van Google bedacht.<sup>3</sup> \u21a9</p> </li> <li> <p>Sphinx is van oudsher de standaard documentatiegenerator voor Pythonprojecten. Maar Sphinx is al redelijk op leeftijd en gebruikt als tekstformaat niet het bekende en zeer populaire Markdown maar het steeds minder populaire Restructured Text. MkDocs wordt steeds meer gebruikt en Sphinx steeds minder. Toch zul je Sphinx nog veel tegenkomen bij projecten omdat het na al die jaren zeer veel features heeft en zeer stabiel is.\u00a0\u21a9</p> </li> <li> <p>Google. Google python style guide. URL: https://google.github.io/styleguide/pyguide.html.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Nils Werner. Autodocstring - python docstring generator. URL: https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring.\u00a0\u21a9</p> </li> <li> <p>Accelerators and Beam Physics Computing Group. Accelerators and beam physics computing. URL: https://abpcomputing.web.cern.ch.\u00a0\u21a9</p> </li> <li> <p>Will McGugan and others. Textual. URL: https://textual.textualize.io.\u00a0\u21a9</p> </li> <li> <p>Martin Breuss. Build your python project documentation with mkdocs. URL: https://realpython.com/python-project-documentation-with-mkdocs/.\u00a0\u21a9</p> </li> </ol>"},{"location":"docstrings/#documentatie-met-material-for-mkdocs","title":"Documentatie met Material for MkDocs","text":"<p>Een bijkomend voordeel van docstrings is dat ze gebruikt kunnen worden om automatisch documentatie te genereren voor een heel project met behulp van bijvoorbeeld MkDocs of Sphinx.<sup>2</sup> MkDocs is een documentatiegenerator en Material for MkDocs is daar de meestgebruikte uitbreiding op. Het wordt veel gebruikt om documentatie te schrijven voor softwareprojecten. Een paar voorbeelden zijn de website van de Accelerators and Beam Physics Computing groep op CERN<sup>5</sup> en de nieuwe Textual-bibliotheek<sup>6</sup> om zogenaamde text-based user interfaces te maken, een tegenhanger van grafische interfaces. Behalve dat je vrij eenvoudig uitgebreide documentatie kunt schrijven, kan MkDocs alle docstrings gebruiken om een referentie op te bouwen. De website voor de ECPC cursus is ook gebouwd met Material for MkDocs.</p> <p>Het voert tijdens deze cursus te ver om veel aandacht te besteden aan MkDocs. Maar aangezien documentatie zo belangrijk is, wilden we het toch noemen! Voor een uitgebreide tutorial zie Build Your Python Project Documentation With MkDocs.<sup>7</sup></p>"},{"location":"eindfeest/","title":"Eindfeest","text":"<p>Jullie hebben tijdens deze cursus heel veel geleerd. Nu wordt het tijd om dat toe te passen op een nieuw project! Jullie worden hiervoor niet beoordeeld. Dat geeft jullie de vrijheid om in een ontspannen sfeer dingen uit te proberen. Jullie hebben al een hele structuur opgebouwd en misschien hoef je alleen maar je model en view te kopi\u00ebren en wat dingen aan te passen; misschien heb je hele wilde plannen en begin je met een nieuw project. Het mag allemaal, zolang jullie wel een plan hebben en het te maken heeft met het aansturen van een experiment vanuit Python.</p> <p>Hebben jullie een eigen plan? Overleg met de staf! Als we het plan goedkeuren kunnen jullie meteen aan de slag; anders kunnen we bespreken wat er allemaal w\u00e9l kan. We hebben een paar projecten ter suggestie. De meeste zijn behoorlijk open en we geven geen garantie dat je het werkend krijgt in twee dagdelen, maar dat kan ook juist een leuke uitdaging zijn! De meest 'veilige' optie die het meest lijkt op het experiment dat we tot nu toe gedaan hebben staat onderaan (de zonnecel).</p>"},{"location":"eindfeest/#michelson-interferometer","title":"Michelson interferometer","text":"<p>E\u00e9n van de experimenten uit het eerste jaar is de Michelsoninterferometer. We hebben die in het klein als bouwpakket aangeschaft bij het Nikhef. Hij moet nog in elkaar worden gezet (niet heel moeilijk) maar het zou leuk zijn als de metingen (kies je eigen onderzoeksvraag!) geautomatiseerd kunnen worden. Daarvoor moet dan nog wel de opstelling uitgedacht worden en zijn er ongetwijfeld onderdelen nodig (motortje, sensor, ...?). Dus als dit je leuk lijkt, begin dan snel met idee\u00ebn bedenken zodat we voor het eindfeest onderdelen kunnen bestellen.</p>"},{"location":"eindfeest/#morse-code-communicatie","title":"Morse code communicatie","text":"<p>Type op je computer een tekst, druk op 'verzend', en zie de tekst verschijnen bij je buurmens. We kennen dit allemaal van e-mail, Discord, Whatsapp, etc. Dat kan via communicatie over het internet, maar het kan ook met Morse. Schrijf een chat-applicatie waarmee je tekst kunt verzenden van de ene computer en kunt ontvangen op de andere computer. Gebruik daarvoor een LED om te verzenden en een light-dependent resistor (LDR) om te ontvangen. Hiervoor moet je nog een eenvoudige schakeling bouwen. Als het werkt kun je het ook uitbreiden naar bidirectionele communicatie: heen en weer chatten.</p>"},{"location":"eindfeest/#ocean-optics","title":"Ocean Optics","text":"<p>Tijdens het eerste jaar heb je misschien het spectroscopie-experiment uitgevoerd. Hierbij heb je een spectroscoop gebouwd om gasontladingslampen te onderzoeken. Handmatig heb je spectraallijnen opgezocht, hoeken genoteerd en omgerekend naar golflengtes. Dat was een tijdrovende klus. Het bedrijf Ocean Optics brengt digitale spectroscopen op de markt. Je richt die op een lichtbron en krijgt een dataset van de lichtsterkte bij verschillende golflengtes. De modellen die wij hebben worden niet meer ondersteund en er is geen software meer voor beschikbaar. Maar: we hebben wel documentatie gevonden over hoe we ze aan kunnen sturen. Je kunt dus zelf een applicatie schrijven om een spectrum te meten! Binnen een seconde heb je dan een volledig spectrum gemeten; heel anders dan vorig jaar!</p>"},{"location":"eindfeest/#functiegenerator-oscilloscoop","title":"Functiegenerator / Oscilloscoop","text":"<p>Functiegeneratoren en oscilloscopen behoren tot de standaarduitrusting van een natuurkundig laboratorium. Dat je ze met de hand kunt bedienen kan heel fijn zijn om snel dingen uit te proberen, maar is lastiger als je uitgebreidere experimenten wilt uitvoeren die deels met de computer bediend worden. Daarom zijn veel modellen met de computer aan te sturen en uit te lezen. Ontwikkel daarvoor een applicatie naar keuze.</p>"},{"location":"eindfeest/#picoscope","title":"PicoScope","text":"<p>Omdat oscilloscopen nog vaak gebruikt worden voor experimenten komen er ook steeds meer modellen op de markt die je alleen met de computer aan kunt sturen. We gebruiken de PicoScope 5000 Series in ons eigen lab bijvoorbeeld voor het uitlezen van de scintillatordetectoren voor deeltjesdetectie. In hun eentje vervangen die een batterij aan oude apparatuur. De manier van aansturen gaat wel wat anders dan bij de Arduino. Als je dat leuk vindt kun je zelf een interface maken om de PicoScope aan te sturen en uit te lezen. Je kunt hiervoor een functiegenerator gebruiken om het signaal aan te leveren, maar als je wilt mag je bij voldoende toezicht ook op de zaal met radioactieve bronnen werken.</p>"},{"location":"eindfeest/#arduino-nano-33-iot","title":"Arduino Nano 33 IoT","text":"<p>De Arduino die wij gebruiken heeft ook nog ingebouwde sensoren. De leukste is een versnellingsmeter / gyroscoop. Hiermee kun je de snelheid van rotaties meten of de stand van de Arduino ten opzichte van de lokale gravitatierichting. Door de firmware aan te passen met nieuwe firmwarecommando's kun je die ook uitlezen met een Pythonapplicatie. Je zou de stand van de Arduino kunnen gebruiken als een soort muiscursor of een joystick. E\u00e9n student heeft een keer een 3D-model op het scherm getoond die meedraaide met de echte Arduino.</p>"},{"location":"eindfeest/#de-iu-karakteristiek-van-een-zonnecel","title":"De $I,U$-karakteristiek van een zonnecel","text":"<p>In het eerste jaar bepalen natuurkundestudenten een $I,U$-curve van een zonnepanneel. Zij vari\u00ebren met de hand de weerstand en lezen de stroom en spanning af. Wij gaan het experiment automatiseren zodat met \u00e9\u00e9n druk op de knop een $I,U$-curve getoond wordt. </p> <p>Deze opdracht is vergelijkbaar met wat we tot nu toe hebben gedaan. We gaan wederom een $I,U$-curve bepalen, maar niet van een diode maar van een zonnepaneel. Een zonnepaneel gedraagt zich \u2014 afhankelijk van de belastingsweerstand van het circuit \u2014 soms als een spanningsbron en soms als een stroombron. Het geleverde vermogen is ook zeer afhankelijk van deze belasting. Voor de werking van de zonnecel en een beschrijving van de $I,U$- en $P,R$-curves, zie hoofdstuk Zonnecel.</p>"},{"location":"eindfeest/#de-schakeling","title":"De schakeling","text":"<p>In de figuur hieronder is de equivalente schakeling die we gaan bouwen weergegeven.</p> <p></p> <p>We gebruiken een variabele weerstand $R_\\text{var}$ om de belasting van het zonnepaneel te vari\u00ebren. Deze is in serie geschakeld met een stroomsterktemeter om de stroomsterkte door het circuit te meten. Parallel is een spanningsmeter geschakeld waarmee we de spanning die geleverd wordt door het zonnepaneel kunnen meten.</p> <p>Merk op dat onze Arduino geen stroomsterktemeter heeft. We zullen dus de spanning over een kleine weerstand moeten meten om zo \u2014 met behulp van de wet van Ohm \u2014 de stroomsterkte te bepalen. Een ander probleem is dat de spanning die geleverd wordt door het zonnepaneel groter kan zijn dan de 3.3 V die maximaal op de pinnen mag staan. Hiervoor gaan we gebruik maken van een 3:1 spanningsdeler zodat de spanning altijd onder de 3.3 V zal blijven \u2014 volgens de specificaties komt de maximale spanning van het zonnepaneel in de meest ideale omstandigheden uit op 10 V.<sup>3</sup> Het laatste probleem is de variabele weerstand: er zijn variabele weerstanden te koop waarbij de weerstand zeer nauwkeurig kan worden gekozen. Helaas is de minimale weerstand, ten gevolge van de vrij ingewikkelde interne schakelingen, te groot om de maximale stroom van een zonnepaneel te meten. Daarom maken we gebruik van een type veldeffect transistor, de MOSFET. Een MOSFET is feitelijk een soort schakelaar. Afhankelijk van de spanning die op de gate gezet wordt, is de weerstand tussen de source (aarde, minpool) en de drain (pluspool)<sup>1</sup> te vari\u00ebren tussen nul en oneindig. Er is maar een relatief klein gebied waarin de weerstand snel verandert van oneindig naar nul.</p> <p>De schakeling voor onze Arduino is weergegeven in de figuur hieronder. Hier belasten we het zonnepaneel met een MOSFET. In serie hiermee staat een kleine weerstand van 4.7 \u03a9 waarover we de spanning meten ten behoeve van de bepaling van de stroomsterkte. De pin van de Arduino die verbonden is met de gate van de MOSFET is beschermd met een weerstand van 1 k\u03a9. Dit is belangrijk, want wanneer er een spanning gezet wordt op de gate kan er kortdurend een vrij grote stroom lopen. De gate gedraagt zich als een kleine capaciteit. Parallel aan de MOSFET + weerstand is een 3:1 spanningsdeler geschakeld met weerstanden van 2 M\u03a9 en 1 M\u03a9. </p> <p></p> <p>In de 3D-model<sup>2</sup> hieronder is een Arduino Nano 33 IoT op een 400-punt breadboard geschakeld. Aan de linkerkant van het breadboard is de serieschakeling van de MOSFET met de kleine weerstand geplaatst. De pinnen van de MOSFET zijn van boven naar beneden de gate, de drain (+) en de source (-). De rechterkant bevat de spanningsdeler. Het zonnepaneel zelf wordt aan de $+$ en $-$ power rails aan de rechterkant van het bord geschakeld. </p> <p></p> <ol> <li> <p>De namen source en drain verwijzen hier naar de elektronenstroom. Elektronen worden geleverd door de source (aard, minpool) en stromen dan naar de drain (pluspool).\u00a0\u21a9</p> </li> <li> <p>Dit model bevat twee 3D modellen die zijn gecre\u00eberd door Lara Sophie Sch\u00fctt en AppliedSBC en zijn gedeeld onder respectievelijk een CC-BY en CC-BY-SA licentie. De originele modellen zijn te vinden via [CC0] Set of Electronic Components en Arduino Nano 33 IoT. De modellen zijn samengevoegd en Voorzien van een Arduino texture, mosfet, zonnecel en draden. Dit 3D model heeft een CC-BY-SA licentie.\u00a0\u21a9</p> </li> <li> <p>Seeed Studio. Small solar panel 55x70mm 0.5w. URL: https://www.seeedstudio.com/0-5W-Solar-Panel-55x70.html.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/","title":"FAQ: lijst conventies","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"faq/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"faq/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"faq/#ideeen","title":"Idee\u00ebn","text":"Schakeling bouwen <p>Als je geen kant-en-klare schakeling bij je werkplek hebt liggen, druk de Arduino in het breadboard en bouw een schakeling met een LED op de manier die is weergegeven in fig:arduino-LED-breadboard. De weerstand heeft een waarde van 220 \u03a9. De LED heeft aan \u00e9\u00e9n zijde een platte kant in de dikkere ring onderaan de plastic behuizing (goed kijken!); schakel die aan de kant van de aarde. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED. Het heeft geen zin om naar het plaatje te kijken hoe het er \u00edn de LED uitziet \u2014 dat verschilt per type LED.</p> <p>Bestand: <code>docs/index.md</code> en ook <code>pythondaq/models/diode.py</code>. Die vind je<sup>1</sup> ook in de repository <code>davidfokkema/tailor</code>. Folder: <code>oefenopdrachten</code>.</p> <p>Eenheden: 220 \u03a9 m/s of ms<sup>-1</sup> of $220\\,ms^{-1}$ en $220\\,\\Omega$. We doen het eerste!!</p> <p>Voor menu's gaan we het zo doen: Menu &gt; Code &gt; Add repository en voor toetsen Ctrl+F.</p> <p>Een referentie naar een opdracht of figuur maak je aan door <code>&lt;div id=\"label\"&gt;&lt;/div&gt;</code> blokje als label neer te zetten. Verwijzen gaat dan met <code>[opdracht _label_](bronbestand.md#label)</code> waarbij je dus ook het bestand moet weten waarin het label gedefinieerd wordt.</p> <p>Voor vergelijkingen: \\begin{equation} f(x) \\sin x, \\end{equation} met $f(x)$ een functie van $x$.</p> <p>Voor code: hier een <code>print</code>-statement, maar meer code met: Titel<pre><code>print(\"Hello, world!\")\n</code></pre></p> <p>oefenopdracht</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa</p> <p>Inlever opdracht</p> <p>Deze opdracht lever je in. </p> <p>Meer leren</p> <p>Met deze opdracht kan je meer leren</p> <ol> <li> <p>en dit is dus een voetnoot\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/#uitdaging-wheels","title":"Uitdaging: wheels","text":"<p>Waarschuwing</p> <p>Let op dat dit ook kan.</p> <p>Info</p> <p>Of niet.</p> <p>En zo verder.</p>"},{"location":"firmware/","title":"Firmware","text":""},{"location":"firmware/#firmware","title":"Firmware","text":"<p>De firmware bestaat uit een gedeeltelijke implementatie van het VISA-protocol.<sup>1</sup> Het voornaamste verschil bestaat uit het feit dat VISA voor ieder commando zowel een korte als een lange versie heeft. Zo zou je in de documentatie van een instrument het commando <code>MEASure</code> kunnen vinden. Je kunt dan zowel <code>MEAS</code> als <code>MEASURE</code> gebruiken om het commando te geven. In deze implementatie is het slechts mogelijk om de korte vorm te gebruiken.</p> <p>De nummering van de kanalen volgt de nummering van de Arduino hardware. Dus kanaal 0 is pin A0 op de Arduino, kanaal 1 is pin A1, enz. De digitale resolutie is ingesteld op 10 bits ($2^{10}$~stappen, ofwel waardes tussen 0 en 1023) en het analoge bereik is 0 V tot 3.3 V.</p> <p>Bij het versturen van opdrachten naar het apparaat, moet je afsluiten met een linefeed ('\\n'). Het apparaat sluit zijn antwoorden af met een carriage return gevolgd door een linefeed ('\\r\\n').</p> <p>De code is terug te vinden in de repository <code>/davidfokkema/arduino-visa-firmware</code>.<sup>2</sup> Deze documentatie is voor versie 1.1.0. De commando's die geaccepteerd worden door de firmware zijn weergegeven in de tabel hieronder.</p> Commando Beschrijving <code>*IDN?</code> Geeft de identificatiestring van de firmware. <code>OUT:CH&lt;ch&gt; &lt;value&gt;</code> Zet een specifieke spanning <code>&lt;value&gt;</code> op uitvoerkanaal <code>&lt;ch&gt;</code>. Waardes mogen liggen tussen 0 (minimale spanning) en 1023 (maximale spanning). Voorbeeld: <code>OUT:CH0 1023</code> <code>OUT:CH&lt;ch&gt;?</code> Geef de huidige instelling voor de spanning terug op uitvoerkanaal <code>&lt;ch&gt;</code> in het bereik 0 tot 1023. Voorbeeld: <code>OUT:CH0?</code> <code>MEAS:CH&lt;ch&gt;?</code> Meet de spanning op invoerkanaal <code>&lt;ch&gt;</code> in het bereik 0 tot 1023. Voorbeeld: <code>MEAS:CH1?</code> <ol> <li> <p>IVI Foundation. Vpp-4.3: the visa library. 2018. URL: https://www.ivifoundation.org/downloads/Architecture Specifications/IVIspecstopost10-22-2018/vpp43_2018-10-19.pdf.\u00a0\u21a9</p> </li> <li> <p>David B.R.A. Fokkema. Arduino visa firmware. 2020. URL: https://github.com/davidfokkema/arduino-visa-firmware.\u00a0\u21a9</p> </li> </ol>"},{"location":"github/","title":"Versiebeheer met GitHub","text":""},{"location":"github/#versiebeheer","title":"Versiebeheer","text":"<p>Zodra je scripts wat ingewikkelder worden, begin je tegen heel praktische problemen aan te lopen. Het werkt nu, maar je wilt een flinke aanpassing gaan doen. Werkt het dan straks nog wel? Hoe ingewikkelder het script, hoe ingewikkelder de wijzigingen en hoe minder het vertrouwen dat het in \u00e9\u00e9n keer gaat lukken. Misschien heb je wel eens de ervaring gehad dat een wijziging maar niet wilde werken en dat je niet goed meer wist wat je precies had veranderd ten opzichte van toen het nog wel werkte. Veel mensen hebben daarom de neiging om naast een <code>script.py</code> een <code>script-v1.py</code>, <code>script-v2.py</code>, enzovoorts aan te maken. Soms zelfs een <code>script-eindversie.py</code> en met wat pech dan toch nog een <code>script-eindversie-definitief.py</code>. Niet heel fijn. Je ziet dan nog steeds niet goed wat er veranderd is (dat blijft naast elkaar leggen en zoeken) en je map loopt vol met overbodige scripts. Dit kan beter\u2026 met versiebeheer!</p> <p>Versiebeheer (Engels: version control) stelt je in staat om af en toe een momentopname te maken van al je bestanden in een bepaalde map, inclusief alle submappen. Dit doe je niet na iedere regel code, maar bijvoorbeeld wel als je een stukje code af hebt en na het testen weet dat het werkt. Zo'n momentopname heet een commit. Hoe vaak je commit is aan jou; maar wacht niet te lang \u2014 anders is het geen versiebeheer meer.</p> <p>Je versiebeheersysteem geeft ondertussen duidelijk al je wijzigingen weer ten opzichte van de laatste commit. Ook kun je de wijzigingen tussen oudere versies bekijken. Alles is relatief: je kunt zien wat er veranderd is tussen twee weken terug en gisteren, of tussen gisteren en vandaag; iedere commit kun je vergelijken met willekeurig iedere andere commit. Heb je iets verprutst en wil je een oude versie terughalen? Prima! Commit die ook, dan kun je zelfs dat weer terugdraaien. Je verliest zo nooit meer je werk. En stukmaken mag!<sup>1</sup></p>"},{"location":"github/#git","title":"Git","text":"<p>Ruim tien jaar geleden werden er nog vele concurrerende systemen gebruikt. Die tijd is grotendeels voorbij. E\u00e9n van de nieuwste systemen, Git,<sup>2</sup> wordt tegenwoordig door bijna iedereen gebruikt of ondersteund. Git is ontwikkeld door Linus Torvalds als alternatief voor het commerci\u00eble systeem dat gebruikt werd voor de ontwikkeling van de Linux kernel.<sup>7</sup> Het begon als een zeer eenvoudig \u2014 en volkomen ongebruiksvriendelijk \u2014 programma. Later is het in een veel gebruiksvriendelijker jasje gestoken.</p> <p>Git werkt in principe via de command-line. Je geeft opdrachten in de map waar je broncode staat: toevoegen van wijzigingen aan de staging area, bekijken van de meest recente wijzigingen, committen van je code, teruggaan en werken met oudere versies, aanmaken van branches,<sup>3</sup> je wijzigingen uploaden naar internet, enzovoorts. Het geheel van de map met broncode en de versiegeschiedenis wordt een repository genoemd.</p> <p>In deze cursus zul je gebruik maken van een grafische applicatie die eenvoudiger werkt. Je kunt daarna \u2014 als je dat wilt \u2014 de stap maken naar de command-line, waarmee je veel meer mogelijkheden tot je beschikking krijgt. Zie het boek Pro Git<sup>8</sup> voor meer informatie over Git en het gebruik via de command-line.</p>"},{"location":"github/#github","title":"GitHub","text":"<p>Git is een distributed version control system (DVCS), wat wil zeggen dat er geen centrale server hoeft te zijn. Je kunt volledig offline werken in je eigen repository en je wijzigingen af en toe committen. Als je daar zin in hebt kun je je wijzigingen naar een collega sturen (pushen) en je kunt een collega toestemming geven om de wijzigingen op te halen (pullen). Je bouwt dan aan \u00e9\u00e9n grote versiegeschiedenis met kopie\u00ebn op meerdere computers. Je bent zo volledig onafhankelijk van bedrijven die servers in de lucht houden of bepalen wie er wel en niet toegang krijgt. Dat is fijn, maar een centrale plek om repositories neer te zetten heeft weer het grote voordeel dat je de wereld kunt laten zien wat voor moois je gemaakt hebt \u00e9n het vermakkelijkt samenwerking. Daarnaast is iedereen uit je team up-to-date als iedereen regelmatig commits pusht naar een centrale server.</p> <p>Er zijn tegenwoordig veel websites die een plek bieden voor Git repositories. De bekendste zijn GitHub, GitLab, Bitbucket en SourceForge. GitHub, aangekocht door Microsoft, is op dit moment het bekendste en grootste platform. Veel bekende softwareprojecten vinden daar hun thuis.</p> <p>In deze cursus ga je werken met GitHub. Je moet hiervoor wel een (gratis) account aanmaken. Als student kom je ook nog in aanmerking voor een educatiekorting op een pro-account.<sup>4</sup> Je betaalt dan nog steeds niets.</p> <p>Account aanmaken</p> opdrachtcheck <p>Ga naar https://github.com/ en klik op <code>Sign up for GitHub</code>. Maak een account aan onder je priv\u00e9-emailadres. Op deze manier blijf je toegang houden tot je account ook nadat je afgestudeerd bent.</p> <p>Info</p> <p>Mogelijk heb je eerder al eens een account aangemaakt bij GitHub, bijvoorbeeld bij de cursus Project natuurkunde/sterrenkunde 1. Maak voor ECPC dan ook gebruik van dit account. Controleer wel nog even of je voor dit account je priv\u00e9-emailadres gebruikt.</p> <p>Checkpunten</p> <ul> <li> Je hebt een account aangemaakt op https://github.com/. </li> <li> Je hebt dit account aangemaakt onder je priv\u00e9-emailadres. </li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull        </li> </ul>"},{"location":"github/#github-desktop","title":"GitHub Desktop","text":"<p>Om het programmeurs makkelijker te maken met GitHub te werken heeft GitHub een desktopapplicatie ontwikkeld met de naam GitHub Desktop. Je gaat GitHub Desktop gebruiken om een repository te maken van de map met de oefenopdrachten.</p> <p>Van bestaande map repository maken</p> opdrachtcheck <p> Zorg dat Visual Studio Code is afgesloten en geen bestanden meer open heeft staan. Je gaat een repository maken van een bestaande map. Als je van de map <code>ECPC</code> een repository maakt, kun je daar geen andere repositories meer in zetten. Dat is onhandig! Daarom maak je in de map <code>ECPC</code> een nieuwe map <code>oefenopdrachten</code> aan. Hierin zet je alle Python-bestanden die je tot nu toe hebt gemaakt, zoals de opdrachten PyVISA in Pythonscript en flashingLED.            Je gaat naar GitHub Desktop en logt in met je eigen account. Je vindt onder het dropdownmenu File drie opties:  <code>New repository...</code>, <code>Add local repository...</code> en <code>Clone repository...</code>. Hoewel <code>New repository...</code> een goede optie lijkt, is dit niet wat je zoekt. Op het moment dat je een nieuwe repository maakt, wordt er ook een nieuwe map aangemaakt en dat is niet wat je wilt. Daarom kies je voor <code>Add local repository...</code>. Je geeft de map <code>oefenopdrachten</code> op als locatie en krijgt in rode tekst een waarschuwing. De waarschuwing geeft aan dat de map wel bestaat maar dat het geen <code>Git repository</code> is, daarom klik je op de blauwe tekst <code>create a repository</code>. Je vinkt <code>Initialize this repository with a README</code> aan en kiest bij <code>Git ignore</code> voor Python. Daarna klik je op de blauwe knop <code>Create Repository</code>.            De repository <code>oefenopdrachten</code> is in GitHub Desktop geopend en als je op het tabblad 'History' klikt dan zie je dat er een <code>Initial commit</code> is met wat <code>git</code>-bestanden en de Pythonscripts die je in de map hebt gezet. Vanaf nu staat <code>oefenopdrachten</code> in versiebeheer en houdt Git je wijzigingen bij. Het is wel belangrijk dat je met regelmaat zelf commit!      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>test_arduino.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>flashingLED.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022       </p> <p>-symbool</p> <p>Vanaf nu duiden we een repository aan met het -symbool. </p> <p>Git ignore Python</p> <p>Waarom zou je bij <code>Git ignore</code> voor Python kiezen, je gaat toch juist Python bestanden maken? De <code>Git ignore</code> zorgt ervoor dat allerlei hulpbestanden van Python niet bewaard worden als commit. Maar de Pythoncode zelf wordt wel bewaard.</p> <p>Checkpunten</p> <ul> <li> De repository <code>oefenopdrachten</code> zit in de map <code>ECPC</code>.</li> <li> In de repository <code>oefenopdrachten</code> bevinden zich de Python-bestanden die je tot nu toe hebt gemaakt.</li> <li> In de repository <code>oefenopdrachten</code> bevindt zich een bestand <code>README.md</code>.</li> <li> In de repository <code>oefenopdrachten</code> bevindt zich een bestand <code>.gitattributes</code>.</li> <li> In de repository <code>oefenopdrachten</code> bevindt zich een bestand <code>.gitignore</code>.</li> <li> In GitHub Desktop zie je onder 'History' een <code>Initial commit</code> staan.</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul>"},{"location":"github/#commit","title":"Commit","text":"<p>Alle wijzigingen aan bestanden in de repository kun je vanaf nu bijhouden door regelmatig een commit te maken. Met een commit maak je als het ware een snapshot van alle bestanden en hang je daar een labeltje aan. Dit kan in GitHub Desktop, maar ook direct vanuit Visual Studio Code. Elke commit geef je een begeleidend schrijven mee, een commit message. Je hoopt dat jij \u2014 maar ook je collega \u2014 na het lezen van de commit message snel begrijpt wat er veranderd is \u00e9n waarom. Wanneer je bepaalde wijzigingen ongedaan wilt maken, kan je door het lezen van de commit messages snel vinden bij welke commit je dan moet zijn. En wanneer je je applicatie gaat uitbrengen op GitHub, kun je de commit messages gebruiken om snel op te sommen wat de nieuwste versie van jouw app kan!</p> <p>Hieronder zie je een aantal voorbeelden van commit messages. De titel (summary) is kort en krachtig. In de beschrijving (description) staat specifieke en uitgebreidere informatie. </p> Enabled initialization of the measurement instrument and calibration of sensors for accurate data collection. Commit to main Resolved calibration errors caused by incorrect sensor configurations. Commit to main Upgraded matplotlib and click to the latest versions to enable error bar functionality. Commit to main Fetched all measurements prior to analysis to enhance performance and efficiency. Commit to main Updated README to include information about the new plot button and save feature. Commit to main Commit to main <p>Commit</p>  GitHub DesktopVisual Studio Codecheck <p>Voer de volgende opdrachten uit:</p> <ol> <li>Open GitHub Desktop, klik op Current repository (links onder de menubalk) en selecteer de repository <code>oefenopdrachten</code>.</li> <li>Ga naar het dropdownmenu Repository en kies voor <code>Open in Visual Studio Code</code> (of druk op Ctrl+Shift+A ) en open de repository <code>oefenopdrachten</code> in Visual Studio Code.</li> <li>Open in Visual Studio Code \u00e9\u00e9n van je Pythonscripts.</li> <li>Type een stukje code erbij \u2014 bijvoorbeeld een <code>print</code>-statement \u2014 en haal ergens anders iets weg. Sla het bestand op.</li> <li>Ga terug naar GitHub Desktop. Controleer bij Current repository (links onder de menubalk) of de repository <code>oefenopdrachten</code> nog steeds is geopend.</li> <li>Klik daaronder op het tabblad Changes.</li> <li>Als er meerdere bestanden gewijzigd zijn, kun je met een blauwe vinkje aangeven voor welke bestanden je een commit schrijft. </li> <li>Onder de lijst met gewijzigde bestanden vind je twee invulvelden. Een smal veld voor een titel en een groot veld voor een uitgebreide beschrijving (Description). In het veld voor een titel staat in lichtgrijs een nietzeggende commit, bijvoorbeeld Update test.py. Schrijf daar een nuttige commit message. Dus niet: opdracht: commit. Maar meer zoiets als: feat: lookup port name for device. Houd de titel in de commit message kort en krachtig. Een uitgebreidere beschrijving kun je kwijt in het grote veld.</li> <li>Klik op Commit to main. Gefeliciteerd!  Je hebt je eerste commit gedaan!</li> </ol> <p>Voer de volgende opdrachten uit:</p> <ol> <li>Open GitHub Desktop, klik op Current repository (links onder de menubalk) en selecteer de repository <code>oefenopdrachten</code>.</li> <li>Ga naar het dropdownmenu Repository en kies voor <code>Open in Visual Studio Code</code> (of druk op Ctrl+Shift+A ) en open de repository <code>oefenopdrachten</code> in Visual Studio Code.</li> <li>Open in Visual Studio Code \u00e9\u00e9n van je Pythonscripts.</li> <li>Type een stukje code erbij \u2014 bijvoorbeeld een <code>print</code>-statement \u2014 en haal ergens anders iets weg. Sla het bestand op.</li> <li>In Visual Studio Code verschijnt links een blauw bolletje bij Source Control . (Geen blauw bolletje? Bekijk het info-blok hieronder.) Dit bolletje laat weten dat er wijzigingen zijn ten opzichte van de vorige commit. Klik op Source Control. </li> <li>Onder Changes staat een lijst met bestanden waar wijzigingen in aangebracht zijn. Kies welke bestanden je wilt committen door achter de bestandsnamen op <code>+</code> te klikken. Deze bestanden komen nu op het \"podium\" te staan onder Staged Changes. Je kunt ook alle bestanden in een keer op het \"podium\" zetten door naast het kopje Changes op <code>+</code> te klikken.</li> <li>Schrijf een nuttige commit message. Dus niet: opdracht: commit. Maar meer zoiets als: feat: lookup port name for device. Je kunt je commit message opdelen in een titel (of summary) en een beschrijving. Dit doe je door een witregel toe te voegen tussen de titel en de beschrijving. Houd de titel in de commit message kort en krachtig. De beschrijving mag uitgebreider zijn.</li> <li>Klik op het vinkje Commit om te committen. Gefeliciteerd!  Je hebt je eerste commit gedaan!</li> </ol> <p>Geen blauw bolletje</p> <p>Zie je geen bolletje verschijnen? Kijk of je het bestand zeker weten hebt opgeslagen. Nog steeds geen blauw bolletje? Ga naar  GitHub Dekstop en ga verder met stap 5.</p> <p>Checkpunten</p> <ul> <li> In GitHub Desktop is aan het tabblad History een nieuw commit message toegevoegd, de commit message die jij zojuist geschreven hebt.</li> <li> De commit message bevat in ieder geval een kort en krachtige titel.</li> <li> De commit message is gekoppeld aan het bestand waarin je aanpassingen hebt gedaan. </li> <li> De toevoegde code is in het overzicht aangegeven in het groen en de verwijderde code is aangegeven in het rood. </li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul> <p>In GitHub Desktop zie je nu bij History de commit staan, met in \u00e9\u00e9n oogopslag alle wijzigingen.</p> <p>Info</p> <p>Als je wilt opzoeken hoe iets werkt bij GitHub Desktop, kijk dan in de documentatie: https://docs.github.com/en/desktop.</p> <p>Push en pull</p> opdrachtcheck <p>De repository <code>oefenopdrachten</code> bestaat alleen nog maar op de computer. Als de zaalcomputerkabouters 's nachts langskomen kan het zijn dat de zaalcomputer daarna is gewist en je alles kwijt bent.<sup>5</sup> Dat zal op je eigen laptop niet zo snel gebeuren gelukkig. Maar het kan dus fijn zijn om de repository ook in de cloud te hebben op github.com. Bovendien geeft dat de mogelijkheid je code op andere computers binnen te halen of te delen met anderen.</p> <p>In GitHub Desktop vind je een knop <code>Publish repository; Publish this repository to GitHub</code>. Als je daar op drukt kun je nog een andere naam aan de repository geven (deze naam bepaalt de url op github.com), een beschrijving toevoegen en aangeven of de code priv\u00e9 moet zijn. Daarna klik je op de blauwe knop <code>Publish repository</code>. Als je nu naar github.com gaat zie je bij jouw repositories de zojuist gepubliceerde repository staan. </p> <p>Om je wijzigen ook in de cloud op te slaan kun je commits <code>pushen</code> naar github.com met de knop <code>Push origin</code>. Als je op een andere computer gaat werken kun je de repository vanuit de cloud naar de computer halen door op <code>Fetch origin</code> te klikken en daarna op <code>Pull origin</code>.</p> <p>Checkpunten</p> <ul> <li> De repository <code>oefenopdrachten</code> is \u00e9\u00e9n van jouw repositories op github.com. </li> <li> Alle bijbehorende commit messages zijn ook te vinden op github.com.</li> </ul> <p>Projecttraject</p> <ul> <li> Vergelijk script met <code>pyvisa-shell</code></li> <li> Environment aanmaken</li> <li> PyVISA in Pythonscript</li> <li> LED laten branden</li> <li> flashingLED</li> <li> Account aanmaken</li> <li> Van bestaande map repository maken</li> <li> Commit </li> <li> Push en pull</li> </ul>"},{"location":"github/#github_1","title":"GitHub","text":"<p>Om makkelijk je Git repository te delen met vrienden, collega's en de rest van de wereld kun je er dus voor kiezen om deze op GitHub te zetten. Je kunt dan je commits pushen naar GitHub en wijzigingen die je vrienden hebben gemaakt pullen, zodat jij er ook weer aan verder kan werken. Van alle repositories die op GitHub staan \u00e9n openbaar zijn kun je de broncode clonen en er zelf mee aan de slag! Laten we eens een kijkje nemen op GitHub.</p> <p>Tailor</p> opdrachtcheck <p>Als je nog nooit op GitHub bent geweest dan kunnen de pagina's nogal intimiderend overkomen. De informatiedichtheid is nogal hoog. Na een paar bezoeken weet je meestal wel waar je dingen kunt vinden. David heeft een data-analyse app geschreven dat Tailor heet. Deze app wordt gebruikt bij natuurkundepractica voor studenten Medische natuurwetenschappen en Science, business and innovation. Interessant om eens te kijken wat je hierover kunt vinden op GitHub.</p> <ol> <li>Zoek de repository <code>/davidfokkema/tailor</code> op github.com op.</li> <li>Je komt nu terecht op de hoofdpagina. Hier zie je een mappenstructuur met een aantal bestanden. Rechts daarvan staat een korte beschrijving onder het kopje About. Een uitgebreidere beschrijving vind je als je naar beneden scrolt onder README.</li> <li>Linksboven zie je een aantal tabbladen (Code, Issues, Pull requests, enzovoorts). Het tabblad Code is de hoofdpagina met de mappenstructuur. Navigeer door de mappen, wat staat er op regel 14 van <code>plot_tab.py</code>?</li> <li>Ga terug naar de hoofdpagina. In de regel boven de mappenstructuur vind je onder andere informatie over de commits (onder de groene knop met Code). Hoeveel commits zijn er gemaakt? Klik op Commits en daarna op een aantal commit messages. Hoeveel regels zijn er bij een commit message weggehaald of bijgekomen?</li> <li>Je kunt per bestand bekijken wanneer die is aangepast en wat er is aangepast. Ga naar het bestand <code>pyproject.toml</code> en klik rechtsboven op History. Wat is er aangepast in <code>pyproject.toml</code> bij de commit Release v2.0.0? Je ziet ook welke bestanden nog meer zijn gewijzigd in deze commit, welk bestand is nog meer gewijzigd bij de commit Release v2.0.0?</li> <li>Ga terug naar de hoofdpagina. Welke versie van Tailor is als laatste gereleased? Kijk hiervoor onder Releases aan de rechterkant.</li> <li>Je kent het misschien wel, dat je een app gebruikt maar dat het niet helemaal goed werkt (bug), of je hebt een idee hoe het nog beter kan worden (enhancement). Daarvoor is op GitHub het tabblad <code>Issues</code>. Hoeveel bugs zijn er gerapporteerd? En hoeveel enhancements?</li> <li>Als het jou gelukt is om een bug te fixen, of je hebt een super handige feature ontworpen, dan kan je de eigenaren van de repository vragen om jouw code te implementeren door een pull request te sturen. Ga naar het tabblad Pull requests, klik op Closed en bekijk welke pull requests zijn ge\u00efmplementeerd.</li> <li>Het meest tabblad Insights geeft je, tegen alle verwachtingen in, inzicht. Je kan bijvoorbeeld zien door hoeveel mensen er aan het project gewerkt wordt (Contributors). En kijk eens bij Code frequency, in welke periode is er het meest aan de code veranderd?</li> <li>Als je een repository goed/handig/slim/fijn vindt, kun je dit aangeven met een ster. Klik daarvoor rechtsboven op  Star.</li> <li>Dan tot slot die ene, meest in het oogspringende groene Code-knop op de hoofdpagina. Met die knop kun je de repository als ZIP-bestand downloaden of openen met GitHub Desktop.</li> </ol> <p>Projecttraject</p> <ul> <li> Tailor</li> </ul> Clone repository <p>Clone de repository <code>lmfit-py</code> van GitHub:</p> <ol> <li>Zoek op github.com de repository <code>lmfit/lmfit-py</code> op.</li> <li>Klik op de groene knop Code en kies voor Open with GitHub Desktop.</li> <li>Kies zelf een map op je harde schijf waar je de repository wilt bewaren.</li> <li>Open Visual Studio Code en open de repository met File en kies voor <code>Open Folder...</code>.<sup>6</sup> Als GitHub Desktop de ge\u00efnstalleerde Visual Studio Code herkent, dan kun je de repository ook direct vanuit GitHub Desktop in Visual Studio Code openen. Ga hiervoor naar het dropdownmenu Repository en kies voor <code>Open in Visual Studio Code</code>. </li> <li>Open de map <code>examples</code> en daarna het bestand <code>README.txt</code>. Verander in de eerste paragraaf \"Below are examples\" in \"Below are different examples\" en sla het bestand op.</li> <li>Schakel naar de GitHub Desktop applicatie en bekijk de wijziging.</li> <li>Schrijf een commmit message. Houd de titel in de commit message kort en krachtig. Een uitgebreidere beschrijving kun je kwijt in het grote veld. Commit.</li> <li>Bekijk het tabblad History. Bovenaan staat nu jouw wijziging. Daaronder kun je alle wijzigingen van anderen bekijken.</li> </ol> <p>Aangezien je geen schrijfrechten hebt voor LMfit kun je niet kiezen voor <code>Push origin</code> \u2014 de knop die in GitHub Desktop bovenin verschijnt. Met die knop duw je je wijzigingen naar GitHub zodat iedereen ze kan zien. Dat is mooi, maar je mag niet zomaar de repository van iemand anders wijzigen.</p> Git in de terminal <p>Tot nu toe heb je Visual Studio Code of GitHub Desktop gebruikt om te committen. Maar je kunt Git ook bedienen via de terminal. De mogelijkheden van Git zijn in de terminal ook veel groter dan in de grafische applicaties die we gebruikt hebben.</p> <ol> <li>Open een repository in Visual Studio Code.</li> <li>Gebruik de terminal in Visual Studio Code en bekijk de commit geschiedenis met het commando <code>git log</code>. Scroll door de commit messages met spatie.</li> <li>Zoek via https://initialcommit.com/blog/Git-Cheat-Sheet-Beginner het commando om een commit toe te voegen. Wijzig iets in je code en commit via de terminal.</li> <li>Dit waren twee dingen die je met GitHub Desktop ook kunt doen. Snuffel op het internet om te zien wat je met Git nog meer kunt.</li> </ol> Branches <ol> <li> <p>Stukmaken mag, maar het terughalen van een oude versie is niet met \u00e9\u00e9n druk op de knop gebeurd. Vraag om hulp als je terug wilt naar een oude versie, wij helpen je graag!\u00a0\u21a9</p> </li> <li> <p>https://initialcommit.com/blog/How-Did-Git-Get-Its-Name \u21a9</p> </li> <li> <p>Een branch is een splitsing in je versiegeschiedenis. Je kunt het gebruiken om over een langere tijd een grote wijziging uit te testen, terwijl je af en toe heen en weer springt tussen je main branch en de nieuwe branch. Commits in de verschillende branches blijven gescheiden. Later kun je ervoor kiezen om de wijzigingen in de nieuwe branch te mergen met je main branch, maar dat hoeft niet.\u00a0\u21a9</p> </li> <li> <p>https://github.com/education/students \u21a9</p> </li> <li> <p>Dit is geen grap en is al meerdere studenten gebeurd. De zaalcomputers worden om privacy- en effici\u00ebntieredenen met enige regelmaat automatisch opgeschoond. Ok, het zijn waarschijnlijk geen kabouters \u2014 dat is wel een grap, denken we.\u00a0\u21a9</p> </li> <li> <p>Als je vergeten bent waar je de repository ook alweer bewaard hebt, dan kun je via GitHub Desktop de locatie terugvinden. Selecteer in GitHub Desktop de betreffende repository. Ga naar het dropdownmenu Repository en kies voor <code>Show in explorer</code>.\u00a0\u21a9</p> </li> <li> <p>Linus Torvalds and others. Git. 2005. URL: https://git-scm.com.\u00a0\u21a9</p> </li> <li> <p>Scott Chacon and Ben Straub. Pro git: Everything you need to know about Git. Apress, second edition, 2014. URL: https://git-scm.com/book/en/v2.\u00a0\u21a9</p> </li> </ol>"},{"location":"github/#branches","title":"Branches","text":"<p>Soms wil je je code flink onder handen nemen of iets heel nieuws ergens aan toevoegen. Terwijl je bezig bent ga je natuurlijk eerst van alles stukmaken, voordat je het weer werkend hebt gekregen. Maar ondertussen kun je de oude functionaliteit van je code niet gebruiken. Of je bent samen met een vriend aan een package bezig en om de haverklap werkt jouw stukje code niet meer omdat ergens anders de code verbouwd wordt. Dan is het handig als je vanaf het punt dat je code werkt een zijweg kunt inslaan. Daarvoor zijn branches uitgevonden. Je kunt vanuit Github Desktop, vanuit Visual Studio Code en natuurlijk via de terminal een branch aanmaken.</p> <p>Branches</p> <ol> <li>Open een repository naar keuze en maak een nieuwe branch aan.</li> <li>Maak een aantal wijzigingen en commit.</li> <li>Ga terug naar de main branch.</li> <li>Merge de nieuwe branch in de main branch.</li> </ol>"},{"location":"gui/","title":"Graphical user interfaces","text":""},{"location":"gui/#grafische-interfaces-met-pyside","title":"Grafische interfaces met PySide","text":"<p>Als je een grafische applicatie schrijft roep je functies aan van het besturingssysteem om vensters, knoppen, menu's e.d. te laten tekenen en te reageren op muisklikken en het toetsenbord. Het lastige daaraan is dat een applicatie voor MacOS heel anders geschreven moet worden dan \u00e9\u00e9n voor Linux of Windows. Om die reden zijn er verschillende cross-platform bibliotheken ontwikkeld die als het ware tussen het besturingssysteem en je applicatie komen te staan. Je kunt dezelfde applicatie maken voor alle besturingssystemen en de bibliotheek kiest welke functies aangeroepen moeten worden om een venster te tekenen. Het voordeel is duidelijk: je hoeft maar \u00e9\u00e9n applicatie te schrijven die overal werkt. Het nadeel is dat je niet \u00e9cht gebruik kunt maken van alle functies en opties die het besturingssysteem biedt. Hier kiezen we voor de voordelen en gaan we gebruik maken van misschien wel de meest populaire optie: Qt.<sup>1</sup> De bibliotheek <code>PySide6</code> is de offici\u00eble Pythonbibliotheek.</p> <p>Info</p> <p>Maak voor de oefeningen een nieuw conda environment <code>test-qt</code> met: Terminal<pre><code>conda create --name test-qt python=3.12\nconda activate test-qt\npip install pyside6 pyqtgraph\n</code></pre> Selecteer het nieuwe <code>test-qt</code> conda environment in Visual Studio Code en sluit alle oude terminals met het  -icoon.<sup>2</sup></p> <p>Een minimale Qt-applicatie ziet er als volgt uit:</p> <p><pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n\nclass UserInterface(QtWidgets.QMainWindow):\n    pass\n\n\ndef main():\n    app = QtWidgets.QApplication(sys.argv)\n    ui = UserInterface()\n    ui.show()\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()  \n</code></pre> Eerst importeren we een paar bibliotheken. Het draait uiteindelijk om de <code>UserInterface</code> class. De naam mag je zelf kiezen, zolang je maar aangeeft dat de class een subclass is van <code>QtWidgets.QMainWindow</code>, het hoofdvenster van je applicatie (voor meer informatie zie paragraaf subclasses). In het hoofdgedeelte van het programma (gedefinieerd in de functie <code>main()</code>) maak je eerst een instance van <code>QtWidgets.QApplication</code>.<sup>3</sup> Ook maken we een instance van onze eigen class en we roepen de <code>show()</code> method aan. Die hebben we niet zelf geprogrammeerd; die zit in de parent class <code>QMainWindow</code>. Als laatste roepen we de <code>exec()</code> method aan van onze <code>QApplication</code> en de uitvoer daarvan (een exit code) geven we mee aan de functie <code>sys.exit()</code>. Dat betekent dat als het programma afsluit met een foutmelding, dat een foutcode wordt meegegeven aan het besturingssysteem. Iemand anders die een script schrijft kan die code afvangen en daar iets mee doen.</p> <p>Een aantal elementen uit dit programma (<code>sys.argv</code>, <code>sys.exit()</code>) zijn strikt genomen niet noodzakelijk, maar wel good practice. Ook het schrijven van een <code>main()</code> functie is niet strikt noodzakelijk, maar het maakt het wel makkelijk om straks een zogeheten entry point te hebben als we weer een applicatie willen schrijven. In de <code>pyproject.toml</code> geven we dan aan dat we de <code>main()</code> functie willen aanroepen. Dat komt later.</p> <p>Minimale GUI</p> opdrachtcodecheck <p>      Je gaat de gegeven Python code voor een een minimale GUI testen. In de map <code>ECPC</code> maak je een <code>example-gui.py</code> aan en zet daarin de Python code. Je activeert de <code>test-qt</code> conda environment  en runt het bestand <code>example-gui.py</code>. Er verschijnt een leeg venster in beeld met als venstertitel <code>python</code> en drie knoppen. Een streepje (minimize), een vierkant (maximize) en een kruis (close). Je drukt op het kruisje en het venster sluit.       <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>example-gui.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het juiste conda environment is geactiveerd</li> <li> De code is volledig overgenomen</li> <li> Er verschijnt een leeg venster</li> </ul> <p>Projecttraject:</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>Elke keer als je een nieuwe Qt applicatie gaat schrijven kun je bovenstaand stukje code copy/pasten. Als we dit programma draaien hebben we echter een klein leeg venster op het scherm, zonder elementen. Die elementen kunnen we op twee manieren toevoegen: door ze te programmeren of door het gebruik van een visueel ontwerp met Qt Designer. Beide zullen in de volgende secties toegelicht worden.</p>"},{"location":"gui/#een-interface-programmeren-met-pyside6","title":"Een interface programmeren met PySide6","text":"<p>We gaan de eenvoudige interface programmeren die hieronder is weergegeven:</p> <p></p> <p>We doen dat door de class <code>UserInterface</code> uit te breiden met widgets uit de <code>QtWidgets</code> bibliotheek.</p> <p>Het defini\u00ebren van layouts gebeurt in veruit de meeste opmaaksystemen met rechthoeken (Engels: boxes) die op verschillende manieren gestapeld worden \u2014 naast elkaar, boven elkaar, of op een rechthoekig grid bijvoorbeeld. Zulke systemen zijn ook hi\u00ebrarchisch: je stopt boxes in andere boxes.</p> <p>De layout van bovenstaande screenshot is als volgt opgebouwd. Het hoofdelement van de grafische interface is de <code>central widget</code>:</p> <p></p> <p>De <code>central widget</code> krijgt een verticale layout die we <code>vbox</code> noemen:</p> <p></p> <p>In de verticale layout plaatsen we een <code>textbox</code> en een horizontale layout die we <code>hbox</code> noemen:</p> <p></p> <p>In de horizontale layout plaatsen we twee <code>button</code>s:</p> <p></p> <p>Het stuk programma om bovenstaande layout op te bouwen geven we hieronder weer. We bespreken straks de code regel voor regel.</p> <p><pre><code>from PySide6.QtCore import Slot\n\n\nclass UserInterface(QtWidgets.QMainWindow):\n    def __init__(self):\n        # roep de __init__() aan van de parent class\n        super().__init__()\n\n        # elk QMainWindow moet een central widget hebben\n        # hierbinnen maak je een layout en hang je andere widgets\n        central_widget = QtWidgets.QWidget()\n        self.setCentralWidget(central_widget)\n\n        # geef de central widget een verticale layout\n        vbox = QtWidgets.QVBoxLayout()\n        central_widget.setLayout(vbox)\n\n        # voeg geneste layouts en widgets toe\n        self.textedit = QtWidgets.QTextEdit()\n        vbox.addWidget(self.textedit)\n        hbox = QtWidgets.QHBoxLayout()\n        vbox.addLayout(hbox)\n\n        clear_button = QtWidgets.QPushButton(\"Clear\")\n        hbox.addWidget(clear_button)\n        add_text_button = QtWidgets.QPushButton(\"Add text\")\n        hbox.addWidget(add_text_button)\n\n        # Slots and signals\n        clear_button.clicked.connect(self.textedit.clear)\n        add_text_button.clicked.connect(self.add_text_button_clicked)\n\n    @Slot()\n    def add_text_button_clicked(self):\n        self.textedit.append(\"You clicked me.\")\n</code></pre> Allereerst defini\u00ebren we een <code>__init__()</code>. Helaas gaat dat niet zomaar. We schrijven namelijk niet helemaal zelf een nieuwe class (<code>class UserInterface</code>), maar breiden de <code>QMainWindow</code>-class uit (<code>class UserInterface(QtWidgets.QMainWindow)</code>). Door dat te doen zijn er heel veel methods al voor ons gedefinieerd. Daar hoeven we verder niet over na te denken, onze interface werkt gewoon. Het gaat mis als wij zelf nieuwe methods gaan schrijven die dezelfde naam hebben. Stel dat de parent class <code>QMainWindow</code> een method <code>click_this_button()</code> heeft. Als onze class ook een method <code>click_this_button()</code> heeft, dan zal die worden aangeroepen in plaats van de method uit de parent class. Dat is handig als je de parent method wilt vervangen maar niet zo handig als je de parent method wilt aanvullen, zoals nodig is bij <code>__init__()</code>. Immers, we willen onze eigen class initialiseren, maar we willen ook dat de parent class volledig wordt ge\u00efnitialiseerd.</p> <p>De oplossing is gelukkig vrij eenvoudig: we kunnen de <code>__init__()</code> van de parent class gewoon aanroepen en daarna ons eigen ding doen. De Pythonfunctie <code>super()</code> verwijst altijd naar de parent class, dus met <code>super().__init__()</code> wordt de parent class volledig ge\u00efnitialiseerd. Dat is dus het eerste dat we doen in regel 10. Kijk voor meer informatie over <code>super().__init__()</code> in de paragraaf subclasses.</p> <p>In de volgende opdrachten ga je zelf de hele applicatie opbouwen, zodat je precies weet wat in de code hierboven staat. </p> <p>Parent class initialiseren</p> opdrachtcodecheck <p>Je hebt gezien hoe je widgets aan de applicatie kunt toevoegen. Maar omdat het veel stappen in een keer zijn ga je de instructies stap voor stap volgen en steeds tussendoor testen. Je begint met het maken van een <code>__init__()</code> method voor de <code>class UserInterface</code> en zorgt ervoor dat de parent class (<code>QtWidgets.QMainWindow</code>) volledig wordt ge\u00efnitialiseerd. Je runt <code>example-gui.py</code> en ziet dat er nog steeds een leeg venster wordt gestart. Je bent benieuwd of het initialiseren \u00e9cht nodig is, daarom haal je de <code>super()</code>-aanroep weg en kijkt wat er gebeurd als je <code>example-gui.py</code> runt. Je zet <code>super()</code>-aanroep heel gauw weer terug.</p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Er is een <code>__init__()</code> method gemaakt voor de subclass <code>UserInterface</code>.</li> <li> In de <code>__init__()</code> method wordt de parent class ge\u00efnitialiseerd (regel 10).</li> <li> Er verschijnt een leeg venster.</li> </ul> <p>Projecttraject:</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>Verder heeft iedere applicatie een centrale widget nodig. Niet-centrale widgets zijn bijvoorbeeld een menubalk, knoppenbalk of statusbalk.</p> <p>Central widget toevoegen</p> opdrachtcodecheck <p>Nu de parent class wordt ge\u00efnitialiseerd kan je een widget aanmaken met <code>QtWidgets.QWidget()</code>, je noemt deze widget <code>central_widget</code>. En stelt deze in als centrale widget met de method <code>setCentralWidget()</code> van de class <code>QtWidgets.QMainWindow</code>. Je runt <code>example-gui.py</code> en ziet dat er nog steeds een leeg venster wordt gestart. </p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n        # create central widget with QtWidgets.QWidget()\n        # set central widget\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Er is een central widget gemaakt met <code>QtWidgets.QWidget()</code> (regel 14).</li> <li> De widget wordt als centrale widget ingesteld met <code>setCentralWidget()</code> (regel 15).</li> <li> De method <code>setCentralWidget()</code> is afkomstig van de class <code>QtWidgets.QMainWindow</code> welke ge\u00efnitialiseerd is, de method wordt daarom met <code>self.setCentralWidget()</code> aangeroepen.</li> <li> Er verschijnt een leeg venster.</li> </ul> <p>Projecttraject:</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen    </li> </ul> <p>Daarna gaan we layouts en widgets toevoegen. Layouts zorgen ervoor dat elementen netjes uitgelijnd worden. We willen het tekstvenster en de knoppen onder elkaar zetten en maken dus eerst een verticale layout. Aan die layout voegen we een textbox toe.</p> <p>textbox toevoegen</p> opdrachtcodecheck <p>Omdat je de textbox en de knoppen onder elkaar wilt uitlijnen voeg je een verticale layout toe aan de <code>central_widget</code>. Je maakt een textbox aan en voegt deze toe aan de verticale layout. Je runt <code>example-gui.py</code>en ziet een venster met een textbox verschijnen, je typt een vrolijke tekst en sluit het venster. </p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n        # create central widget with QtWidgets.QWidget()\n        # set central widget\n\n        # create vertical layout\n        # set layout of central widget as vertical layout\n        # create textbox\n        # add textbox to vertical layout\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Er is een verticale layout gemaakt (regel 18).</li> <li> De <code>central_widget</code> krijgt als layout een verticale layout (regel 19)</li> <li> Er is een tekstbox gemaakt (regel 22).</li> <li> De tekstbox (<code>QTextEdit</code>) is toegevoegd aan de verticale layout (regel 23).</li> <li> Er verschijnt een venster met textbox waar je in kan typen .</li> </ul> <p>Projecttraject:</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>De knoppen zelf plaatsen we straks in een horizontale layout, dus die voegen we ook toe aan de <code>vbox</code>. En we maken de layout compleet door knoppen toe te voegen aan de <code>hbox</code>.</p> <p>Knoppen toevoegen</p> opdrachtcodecheck <p>Omdat de knoppen naast elkaar moeten komen te staan voeg je een horizontale layout toe aan de verticale layout. Je maakt een <code>clear button</code> en een <code>add button</code> en voegt deze toe aan de horizontale layout. Je runt <code>example-gui.py</code>en ziet een venster met een textbox verschijnen met daaronder twee knoppen, je drukt verwoed op de knoppen maar er gebeurt niets<sup>4</sup>. </p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n        # create central widget with QtWidgets.QWidget()\n        # set central widget\n\n        # create vertical layout\n        # set layout of central widget as vertical layout\n        # create textbox\n        # add textbox to vertical layout\n\n        # create horizontal layout\n        # add horizontal layout to vertical layout\n\n        # create clear_button\n        # add clear button to horizontal layout\n        # create add_text_button\n        # add add_text_button to horizontal layout\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Er is een horizontale layout aangemaakt (regel 24).</li> <li> De horizontale layout is toegevoegd aan de verticale layout (regel 25).</li> <li> Er is een <code>clear_button</code> en <code>add_text_button</code> aan gemaakt met daarop de tekst \"Clear\" en \"Add text\" respectievelijk (regels 27 en 29).</li> <li> De buttons zijn toegevoegd aan de horizontale layout (regel 28 en 30).</li> <li> Als je op de knoppen drukt gebeurt er niets.</li> </ul> <p>Projecttraject</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>Info</p> <p>Widgets zoals knoppen voeg je toe met <code>addWidget()</code>. Layouts voeg je toe aan andere layouts met <code>addLayout()</code>.</p> <p>De horizontale layout (voor de knoppen) moeten we expliciet toevoegen aan de verticale layout zodat hij netjes verticaal onder het tekstvenster verschijnt. </p> <p>Als laatste verbinden we de knoppen aan functies. Zodra je op een knop drukt wordt er een zogeheten signal afgegeven. Die kun je verbinden met een slot. Er zijn ook verschillende soorten signalen. Het drukken op een knop zorgt voor een clicked signal, het veranderen van een getal in een keuzevenster geeft een changed signal. Wij verbinden \u00e9\u00e9n knop direct met een al bestaande method van het tekstvenster <code>clear()</code> en de andere knop met een eigen method <code>add_button_clicked()</code>. De naam is geheel vrij te kiezen, maar boven de functiedefinitie moet je wel de <code>@Slot()</code>-decorator gebruiken (voor meer informatie over decorators zie paragraaf Decorators). PySide kan dan net wat effici\u00ebnter werken.</p> <p>Slots en signals toevoegen</p> opdrachtcodecheck <p>Je gaat functionaliteit aan de knoppen verbinden. Je verbint de <code>clear_button</code> aan de <code>clear()</code> method van <code>textedit</code>. Je maakt een eigen <code>Slot</code> met de naam <code>add_text_button_clicked</code> die een tekst aan de textbox toegevoegd. Je vind de tekst \"You clicked me.\" maar suf en bedenkt zelf een andere leuke tekst. Je runt <code>example-gui.py</code>en ziet een venster met een textbox verschijnen met daaronder twee knoppen. Je drukt op \"Add text\" en er verschijnt tekst in de textbox, daarna druk je op \"Clear\" en de tekst verdwijnt.</p> <p>() ontbreken bij <code>clear</code> en <code>add_text_button_clicked</code></p> <p>Bij het verbinden van het <code>clicked</code>-signaal met <code>clicked.connect()</code> geef je aan connect de methods <code>clear</code> en <code>add_text_button_clicked</code> mee zonder deze aan te roepen (dat gebeurt later). Concreet betekent dit dat je de haakjes weglaat (regel 33 en 34).</p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6.QtCore import Slot\n\nfrom PySide6 import QtWidgets\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n        # create central widget with QtWidgets.QWidget()\n        # set central widget\n\n        # create vertical layout\n        # set layout of central widget as vertical layout\n        # create textbox\n        # add textbox to vertical layout\n\n        # create horizontal layout\n        # add horizontal layout to vertical layout\n\n        # create clear_button\n        # add clear button to horizontal layout\n        # create add_text_button\n        # add add_text_button to horizontal layout\n\n        # connect clear_button to clear method of textedit\n        # connect add_text_button to add_text_button_clicked\n\n    # decorate method with Slot function\n    # def add_text_button_clicked\n        # add text to textedit\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het <code>clicked</code> signaal van <code>clear_button</code> is met <code>connect</code> verbonden met de <code>clear()</code>method van <code>textedit</code> (regel 33). </li> <li> Het clicked signaal van <code>add_text_button</code> is met <code>connect</code> verbonden met een eigen method <code>add_text_button_clicked</code> (regel 34). </li> <li> De method <code>add_text_button_clicked</code> is voorzien van een decorator <code>@Slot()</code> met Slot met een hoofdletter en ronde haakjes erachter omdat Slot een functie is (regel 36).</li> <li> De <code>Slot</code> functie is ge\u00efmporteerd vanuit de <code>PySide6.QtCore</code>.</li> <li> De method <code>add_text_button_clicked</code> voegt met <code>append</code> een tekst toe aan <code>textedit</code> (regel 38). </li> <li> Druk op de knop \"Add text\" zorgt voor het verschijnen van tekst in de textbox.</li> <li> Druk op de knop \"Clear\" zorgt ervoor dat alle tekst in de textbox verdwijnt.</li> </ul> <p>Projecttraject</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>Er zijn veel verschillende widgets met eigen methods en signals. We hebben de handigste voor jullie verzameld in de compacte PySide6 documentatie. De methods komen bij Qt<sup>5</sup> vandaan, Qt zelf bestaat uit C++ code en PySide6 vertaalt alle methods e.d. letterlijk naar Python. Vandaar ook de methodnaam <code>addWidget()</code> in plaats van <code>add_widget()</code>. In C++ en Java is het wel gebruikelijk om functies <code>CamelCase</code> namen te geven als <code>kijkDitIsEenMooieFunctie()</code>, maar in Python zijn we <code>snake_case</code> gewend, als in <code>kijk_dit_is_een_mooie_functie()</code>.</p> Volgorde layout aanpassen <p>De volgorde waarin je layout en widgets toevoegt bepaalt het uiterlijk van de grafische interface. Verander de code om de layout aan te passen (zet bijvoorbeeld de knoppen boven de textbox of zet de knoppen onder elkaar en naast de textbox).</p> <p>'Hello world' en Quit knoppen toevoegen</p> opdrachtcodecheck <p>Nu de minimale GUI werkt wil je meer knoppen toevoegen. Je begint met een knop <code>Hello, world</code> die de tekst \"Hello, world\" aan de textbox toevoegd. Je runt <code>example-gui.py</code> en ziet dat de knop werkt. Daarna voeg je een <code>Quit</code>-knop toe die onder de andere knoppen staat. Het signaal van deze knop verbind je met de method <code>self.close()</code> zodat de applicatie wordt afgesloten. Je runt <code>example-gui.py</code> drukt nog een paar keer op de <code>Hello, world</code>-knop en daarna op de knop  <code>Quit</code>, het venster is gesloten de opdracht is voltooid .</p> <p>Pseudo-code <pre><code># create hello_world button and add to layout\n# create Quit button and add to layout\n\n# connect hello_world button to add_hello_world_clicked method\n# connect Quit button to self.close()\n\n# decorate with Slot\n# def add_hello_world_clicked\n    # add Hello World to textbox        \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De 'Add Text' en 'Clear' knoppen werken nog zoals verwacht.</li> <li> Druk op de <code>Hello World</code> knop voegt de text \"Hello World\" toe aan de textbox.</li> <li> De <code>Quit</code> knop staat _ onder_ de andere knoppen.</li> <li> Druk op de <code>Quit</code> knop sluit het venster.</li> </ul> <p>Projecttraject</p> <ul> <li> Minimale GUI</li> <li> Parent class initialiseren</li> <li> Central widget toevoegen    </li> <li> textbox toevoegen</li> <li> knoppen toevoegen</li> <li> Slots en signals toevoegen</li> <li> 'Hello world' en Quit knoppen toevoegen</li> </ul> <p>Number display</p> opdrachtcodecheck <p>      Maak aan de hand van de onderstaande schets een grafische interface. Kijk in de Compacte Pyside6 documentatie welke widgets je daarvoor nodig hebt. Het getal moet met de pijltjes kunnen worden aangepast. Zorg dat de het getal alleen waardes tussen 1 en 28 kan aannemen.  Wanneer je op de knop 'Add value' drukt wordt het getal in de textbox toegevoegd.      <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>      \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>number-display-gui.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code># import statements\n\n# class UserInterface(QtWidgets.QMainWindow):\n    ...\n\n    # create widgets for textedit, spinbox and button\n    # connect widget to method\n\n    # method for button\n        # Add value of spinbox to textedit\n\n# create application\n# show UserInterface\n# close properly\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> In het ontwerp staan de PushButton en de SpinBox onder het tekstveld en naast elkaar.</li> <li> Op de <code>PushButton</code> staat de tekst <code>Add value</code>.</li> <li> Wanneer je op de knop <code>Add value</code> drukt wordt de waarde uit de SpinBox aan de textbox toegevoegd.</li> <li> Wanneer je het getal in de SpinBox veranderd naar 14 en daarna op <code>Add value</code> drukt wordt het getal 14 toegevoegd aan de textbox.</li> <li> De minimale waarde van de SpinBox staat ingesteld op 1, de maximale waarde op 28.</li> <li> Wanneer het venster wordt vergroot schalen de textbox en de knoppen mee. </li> </ul> <p>Projecttracject</p> <ul> <li> Number display</li> </ul>"},{"location":"gui/#compacte-pyside6-documentatie","title":"Compacte PySide6 documentatie","text":"<p>De documentatie van PySide6<sup>6</sup> is niet super-intu\u00eftief. Daarom hebben we speciaal voor jullie een Compacte PySide6 documentatie\ud83d\udcc4 geschreven. Daarin kan je een lijst van widgets vinden met de meest handige methods en signals. De documentatie is dus niet compleet maar genoeg voor een simpele GUI. Een overzicht van alle classes gedocumenteerd in de compacte documentatie vind je hieronder.</p> <p>Subclasses van <code>QLayout</code>:</p> <ul> <li> <p><code>QHBoxLayout</code>: Beheert een horizontale indeling van widgets. Meer info.</p> </li> <li> <p><code>QVBoxLayout</code>: Beheert een verticale indeling van widgets. Meer info.</p> </li> <li> <p><code>QFormLayout</code>: Beheert een indeling waarbij de ruimte wordt verdeeld in een linker kolom met labels en een rechter kolom met widgets. Meer info. </p> </li> </ul> <p>Subclasses van <code>QWidgets</code>:</p> <ul> <li> <p><code>QApplication</code>: Beheert de controleflow en hoofdinstellingen van de GUI-applicatie. Meer info.</p> </li> <li> <p><code>QMainWindow</code>: Biedt een framework voor het bouwen van de gebruikersinterface van een applicatie. Meer info.</p> </li> <li> <p><code>QGroupBox</code>: Biedt een frame, een titel erboven, en kan verschillende andere widgets binnen zichzelf weergeven. Meer info.</p> </li> <li> <p><code>QTextEdit</code>: Geeft tekst weer en stelt de gebruiker in staat om deze te bewerken. Meer info.</p> </li> <li> <p><code>QCheckBox</code>: Schakelknop met een checkbox-indicator. Meer info.</p> </li> <li> <p><code>QLabel</code>: Een widget die tekst weergeeft. Meer info.</p> </li> <li> <p><code>QComboBox</code>: Een widget waarmee de gebruiker een keuze kan maken uit een lijst met opties. Meer info.</p> </li> <li> <p><code>QSpinBox</code>: Een widget waarmee de gebruiker een geheel nummer kan kiezen uit een bereik. Meer info.</p> </li> <li> <p><code>QDoubleSpinBox</code>: Een widget waarmee de gebruiker een komma getal kan kiezen uit een bereik. Meer info.</p> </li> <li> <p><code>QPushButton</code>: Een knop die door de gebruiker kan worden ingedrukt. Meer info.</p> </li> <li> <p><code>QLineEdit</code>: Een widget waarmee de gebruiker een enkele regel platte tekst kan invoeren en bewerken. Meer info.</p> </li> <li> <p><code>QFileDialog</code>: Biedt een dialoogvenster waarmee de gebruiker bestanden of mappen kan selecteren. Meer info.</p> </li> </ul>"},{"location":"gui/#functieplotter","title":"Functieplotter","text":"<p>In de eindopracht willen we data weergeven op een scherm. We zullen dus nog moeten plotten. In de volgende opdrachten gaan we daarmee aan de slag. </p> <p>Je bent bekend met matplotlib en dat kan ook ingebouwd worden in Qt-applicaties. Helaas is matplotlib voor het gebruik in interactieve interfaces nogal traag zodra we te maken krijgen met meer data. We kiezen daarom voor een populair alternatief: PyQtGraph. E\u00e9n nadeel: de documentatie is niet fantastisch. Het geeft dus niets als je ergens niet uitkomt en je hulp nodig hebt van de assistent of een staflid.</p>"},{"location":"gui/#de-plotter-als-script","title":"De plotter als script","text":"<p>Om PyQtGraph te importeren en globale opties in te stellen moeten we bovenaan ons programma het volgende schrijven:</p> <p><pre><code>import pyqtgraph as pg\n\n\n# PyQtGraph global options\npg.setConfigOption(\"background\", \"w\")\npg.setConfigOption(\"foreground\", \"k\")\n</code></pre> Dit geeft zwarte letters op een witte achtergrond. Je kunt de opties weglaten en dan krijg je de standaardinstelling: grijze letters op een zwarte achtergrond. Het is maar wat je fijn vindt.</p> <p>Gebruik de volgende regel om een plot widget te krijgen in de <code>__init__()</code>: <pre><code>self.plot_widget = pg.PlotWidget()\n</code></pre></p> <p>Om daadwerkelijk een functie te plotten kun je deze code aanpassen:</p> <p><pre><code>import numpy as np\n\nclass UserInterface(QtWidgets.QMainWindow):\n\n    ...\n\n    def plot(self):\n        x = np.linspace(-pi, pi, 100)\n        self.plot_widget.plot(x, np.sin(x), symbol=None, pen={\"color\": \"m\", \"width\": 5})\n        self.plot_widget.setLabel(\"left\", \"y-axis [units]\")\n        self.plot_widget.setLabel(\"bottom\", \"x-axis [units]\")\n</code></pre> Je kunt uiteraard spelen met de instellingen zoals <code>symbol</code> en <code>pen</code> om te zien wat ze doen. Leeg maken kan met <code>self.plot_widget.clear()</code>.</p> <p>Functionplotter: plot</p> opdrachtcodecheck <p>      We gaan een nieuwe repository aanmaken in de <code>ECPC</code> map (zie hiernaast). Maak een Poetry project <code>functionplotter</code>, voeg die toe aan GitHub Desktop  en open hem in Visual Studio Code. Bekijk <code>pyproject.toml</code> en zorg dat er een commando is aangemaakt om de applicatie te starten. Je maakt een nieuw conda environment aan met alleen Python daarin . Gebruik <code>poetry install</code> om het project te installeren  en voer het commando uit om de applicatie te starten. Als je applicatie af is verschijnt er een scherm met een plot waarin de functie $\\sin(x)$ plot in het domein $(0, 2\\pi)$ is weergegeven. Een golfje van trots gaat door je heen en je gaat door naar de volgende opdracht.      <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u251c\u2500\u2500  <code>functionplotter</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>pyproject.toml</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code <pre><code># import statements\n\n# class UserInterface(QtWidgets.QMainWindow):\n    ...\n    # when app starts plot sin function\n\n# create application\n# show UserInterface\n# close properly\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Er is een repository <code>functionplotter</code></li> <li> Er is een commando om de applicatie te starten</li> <li> De applicatie laat een $\\sin(x)$ plot zien in het domein $(0, 2\\pi)$</li> <li> De applicatie werkt ook na <code>poetry install</code> in een nieuwe conda environment.</li> </ul> <p>Projecttraject</p> <ul> <li> Functionplotter: plot</li> <li> Functionplotter: widgets</li> </ul> <p>Functionplotter: widgets</p> opdrachtcodecheck <p>Voer opnieuw het commando uit om de applicatie <code>functionplotter</code> te starten. Dit keer zorg je dat de applicatie de mogelijkheid krijgt om het domein van de plot aan te passen. Je ziet dan de sinusplot veranderen wanneer je de startwaarde verhoogd. Je kunt de startwaarde ook naar beneden aanpassen. Hetzelfde geldt voor de stopwaarde. Dan maak je nog een widget om het aantal punten (<code>num</code>) te kiezen waarmee de sinus wordt geplot. Speel eens met de widget en zie de sinus van hoekig naar mooi glad veranderen. Steeds als je een waarde aanpast moet de functie automatisch opnieuw geplot geworden.</p> <p>Pseudo-code <pre><code># import statements\n\n# class UserInterface(QtWidgets.QMainWindow):\n    ...\n    # when app starts plot sin function\n\n    # create widgets for start, stop and num\n    # connect widgets to methods\n\n    # methods for start stop and num\n\n# create application\n# show UserInterface\n# close properly\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het is mogelijk om de start waarde aan te passen.</li> <li> Het is mogelijk om de stop waarde aan te passen.</li> <li> Het is mogelijk om het aantal punten te kiezen waarmee de sinus functie wordt geplot.</li> <li> Na het aanpassen van een waarde wordt de plot automatisch opnieuw geplot.</li> </ul> <p>Projecttraject</p> <ul> <li> Functionplotter: plot</li> <li> Functionplotter: widgets</li> </ul> Functieplotter: functie kiezen drop-down menu <p>Gebruik een <code>QComboBox</code> om de functie te kunnen kiezen. Je moet hem leeg toevoegen aan je interface en vult hem vanuit je programma. Zoek de widget op in de documentatie om uit te zoeken welke functie je moet gebruiken om keuzemogelijkheden toe te voegen en welk signaal je moet koppelen om te zorgen dat de plot opnieuw wordt uitgevoerd als je de functie aanpast. Geef de gebruiker de keuzes $\\sin(x)$, $\\cos(x)$, $\\tan(x)$ en $\\exp(x)$.</p> Functieplotter: meer functies <p>Voeg aan de functiekiezer de functies $x$, $x^2$, $x^3$, en $\\frac{1}{x}$ toe. Je kunt daarvoor lambda functions gebruiken, maar dat is niet per se nodig.</p> Functieplotter: functies typen <p>Vervang de functiekiezer door een tekstveld waarin de gebruiker zelf functies kan typen zoals <code>x ** 2</code>, <code>sin(x)</code> of <code>1 / sqrt(x + 1)</code>. Gebruik daarvoor het <code>asteval</code> package.<sup>14</sup> Documentatie vind je op https://newville.github.io/asteval/.</p> <p>Waarschuwing</p> <p>Gebruik nooit zomaar <code>eval()</code> op een string die iemand anders aanlevert. Anders kan iemand met typen in een tekstveld of het inlezen van een tekstbestand je computer wissen bijvoorbeeld, of malware installeren. Als je <code>eval()</code> wilt gebruiken, lees dan de sectie Minimizing the Security Issues of eval() in Python eval(): Evaluate Expressions Dynamically.<sup>15</sup> Maar veel makkelijker is om <code>asteval</code> te gebruiken.</p>"},{"location":"gui/#een-interface-ontwerpen-met-qt-designer","title":"Een interface ontwerpen met Qt Designer","text":"<p>Bij het ontwerpen van een grafische interface kan het fijn zijn om het ontwerp steeds voor je te zien als je iets wilt aanpassen. Misschien wil je de knoppen toch onder elkaar, of een slider gebruiken in plaats van een spinbox. Je kunt natuurlijk steeds je code aanpassen en opnieuw runnen, maar PySide6 heeft ook een drag-and-drop applicatie 'Designer' gemaakt. Je gebruikt Designer om het uiterlijk van je applicatie vorm te geven, de functionaliteit voeg je vervolgens toe in je code. </p> <p>Designer kan (bijna) alles wat je ook met programmeren kan, daarom kan het programma op het eerste gezicht wat onoverzichtelijk overkomen. In de onderstaande video's nemen we je stap voor stap mee op een tour door Designer. Aan het eind heb je de basis informatie over Designer en kan je de minimale gui die je eerder geprogrameerd hebt, ook maken met Designer. </p> <p>Info</p> <p>Druk in de video's op het vierkant rechtsboven om ze in volledig scherm te bekijken.</p> <p>Designer: opstarten</p> opdrachtcodecheck <p></p> <p>Bekijk de bovenstaande video. Activeer het conda environment <code>test-qt</code> die je eerder hebt aangemaakt  en start designer op. Open een template voor een <code>MainWindow</code> en ontrolleer dat bij jou in de <code>object inspector</code> dezelfde widgets staan als in het filmpje hierboven.</p> <p>Test-code <pre><code>(test-qt) &gt; pyside6-designer \nstart Designer app\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De MainWindow bevat een centralwidget, menubar en statusbar.</li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul> <p>Laten we kijken hoe we widgets toevoegen en de centralwidget een layout geven in Designer:</p> <p>Designer: layout toevoegen aan centralwidget</p> opdrachtcheck <p></p> <p>Bekijk de bovenstaande video. Voeg zelf ook een <code>TextEdit</code> toe geef de <code>central widget</code> een verticale layout. Voeg onder de <code>TextEdit</code> een horizontale layout toe.</p> <p>Checkpunten:</p> <ul> <li> In de object inspector heeft de <code>centralwidget</code> geen rood rondje in het icoon ervoor staan.</li> <li> Er is een <code>TextEdit</code> en een horizontale layout aan de <code>centralwidget</code> toegevoegd.</li> <li> In het ontwerp staat de horizontale layout onder de <code>TextEdit</code>.</li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul> <p>In het volgende filmpje kun je zien hoe je gemakkelijk een widget aan de horizontale layout toevoegd en hoe je de eigenschappen van de widgets aanpast.</p> <p>Designer: eigenschappen widgets aanpassen</p> opdrachtcheck <p></p> <p>Bekijk de bovenstaande video. Voeg zelf ook een <code>PushButton</code> en een <code>SpinBox</code> toe aan de horizontale layout. Pas de tekst op de <code>PushButton</code> aan naar <code>Add value</code>. Zorg dat de <code>SpinBox</code> alleen waardes tussen 1 en 28 kan aannemen. Pas de <code>objectName</code> aan van de <code>TextEdit</code> naar <code>textedit</code>, van <code>PushButton</code> naar <code>add_value_button</code> en van <code>SpinBox</code> naar <code>value</code>. </p> <p>Checkpunten:</p> <ul> <li> In het ontwerp staan de PushButton en de SpinBox onder het tekstveld en naast elkaar.</li> <li> Op de <code>PushButton</code> staat de tekst <code>Add value</code>.</li> <li> De minimale waarde van de SpinBox staat ingesteld op 1, de maximale waarde op 28.</li> <li> De <code>objectName</code> van de <code>TextEdit</code> is <code>textedit</code>, met kleine letters.</li> <li> De <code>objectName</code> van de <code>PushButton</code> is <code>add_value_button</code>.</li> <li> De <code>objectName</code> van de <code>SpinBox</code> is <code>value</code>.</li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul> <p>Om het ontwerp te kunnen gebruiken moet je het ontwerp opslaan en vertalen naar een Pythonbestand met een class die je importeert in je eigen programma.</p> <p>Designer: De .ui vertalen naar .py</p> opdrachtcodecheck <p>      Bekijk de bovenstaande video. Sla het ontwerp op als <code>number_display_app.ui</code>. In een terminal in Visual Studio Code, navigeer naar dezelfde map waarin <code>number_display_app.ui</code> staat.<sup>7</sup> Gebruik de optie <code>--output</code> van <code>pyside6-uic</code> om het bestand <code>number_display_app.ui</code> om te zetten naar het bestand <code>ui_number_display_app.py</code>.      <code>ECPC</code>     \u251c\u2500\u2500  <code>oefenopdrachten</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>number-display-gui.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>number_display_app.ui</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022       </p> <p>Wijzigingen in het ontwerp</p> <p>Het omzetten van het .ui-bestand naar een .py bestand moet je doen elke keer als je in Designer iets wijzigt (en opslaat). Gebruik de Up-toets om oude commando's terug te halen. Dat scheelt typewerk. Later, met Poetry, zullen we dit eenvoudiger maken.</p> <p>Test-code <pre><code>(ECPC) &gt; pyside6-uic number_display_app.ui --output ui_number_display_app.py \n</code>\n <code>ECPC</code>\n\u251c\u2500\u2500  <code>oefenopdrachten</code>\n\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>number-display-gui.py</code>\n\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>number_display_app.ui</code>\n\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>ui_number_display_app.py</code>\n\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022\n\u2514\u2500\u2500 \u2022\u2022\u2022\n\n</pre></p> <p>Checkpunten:</p> <ul> <li> Er is een bestand <code>ui_number_display_app.py</code> bijgekomen.</li> <li> In het bestand <code>ui_number_display_app.py</code> staat een class <code>Ui_MainWindow</code></li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul> <p>Designer: ontwerp importeren</p> opdrachtcodecheck <p>Maak een nieuw pythonbestand <code>number-display-gui-designer.py</code>, kopieer de code van de vorige opdracht number display en vervang de volledige class door:</p> <p></p> <p><pre><code>from ui_number_display_app import Ui_MainWindow\n\n\nclass UserInterface(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        self.ui = Ui_MainWindow()\n        self.ui.setupUi(self)\n\n        self.ui.add_value_button.clicked.connect(self.add_value_button_clicked)\n\n    @Slot()\n    def add_value_button_clicked(self):\n        self.ui.textedit.append(\"You've clicked the 'Add value' button\")\n</code></pre> In deze code defini\u00ebren we niet <code>self.ui.add_value_button</code>; die naam hebben we in Designer aan de knop gegeven. De namen van alle objecten in Designer zijn daarna beschikbaar in onze code om bijvoorbeeld de signalen te koppelen.</p> <p>self.add_value_button wordt self.ui.add_value_button</p> <p>Merk op dat we nu niet meer <code>self.add_value_button</code> gebruiken maar <code>self.ui.add_value_button</code>. Alle widgets komen op deze manier onder een <code>.ui</code>-object te hangen.</p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6.QtCore import Slot\n\nfrom PySide6 import QtWidgets\n\nfrom ui_number_display_app import Ui_MainWindow\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n\n        # create an instance of the class Ui_MainWindow\n        # Setup the UI with the method setupUi(self) from the class Ui_MainWindow\n\n        # connect add_value_button to add_value_button_clicked\n\n    # decorate method with Slot function\n    # def add_button_clicked\n        # add text to textedit\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De class <code>Ui_MainWindow</code> wordt geimporteerd uit <code>ui_number_display_app.py</code></li> <li> De widgets worden aangeroepen met <code>self.ui</code> ervoor.</li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul> <p>Designer: slots en signals toevoegen</p> opdrachtcodecheck <p>Pas de code aan zodat de waarde van de SpinBox aan de textedit wordt toegevoegd. Voeg daarna in Designer een knop <code>Quit</code> toe onder de SpinBox en de PushButton. Zorg dat het venster sluit wanneer je op de knop <code>Quit</code> drukt.</p> <p>Pseudo-code <pre><code>import sys\n\nfrom PySide6.QtCore import Slot\n\nfrom PySide6 import QtWidgets\n\nfrom ui_number_display_app import Ui_MainWindow\n\n# create subclass of QtWidgets.QMainWindow\n    # def __init__()\n        # initialise the parent class Qtwidgets.QMainWindow\n\n        # create an instance of the class Ui_MainWindow\n        # Setup the UI with the method setupUi(self) from the class Ui_MainWindow\n\n        # connect add_value_button to add_value_button_clicked\n        # connect Quit button to self.close()\n\n    # decorate method with Slot function\n    # def add_value_button_clicked\n        # Add value to textedit\n\ndef main():\n    # create instance of QtWidgets.QApplication with arguments from sys.argv\n    # create instance of subclass\n    # call show method of subclass\n    # get exit code with exec method of QApplication instance and give exit code to sys.exit()\n\n# when run this script:\n    # run main function  \n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Wanneer je op de knop <code>Add value</code> drukt wordt de waarde uit de SpinBox aan de textedit toegevoegd.</li> <li> Wanneer je het getal in de SpinBox veranderd naar 14 en daarna op <code>Add value</code> drukt wordt het getal 14 toegevoegd aan de textedit.</li> <li> Onder de SpinBox en de knop <code>Add value</code> staat een knop <code>Quit</code>.</li> <li> Wanneer je op de knop <code>Quit</code> drukt sluit de applicatie.</li> </ul> <p>Projecttraject</p> <ul> <li> Designer: opstarten</li> <li> Designer: layout toevoegen aan centralwidget</li> <li> Designer: eigenschappen widgets aanpassen</li> <li> Designer: De .ui vertalen naar .py</li> <li> Designer: ontwerp importeren</li> <li> Designer: slots en signals toevoegen</li> </ul>"},{"location":"gui/#een-grafische-interface-voor-ons-experiment","title":"Een grafische interface voor ons experiment","text":"<p>In het vorige hoofdstuk hebben we een tekst-interface geschreven voor ons experiment. We gaan nu een grafische interface schrijven voor hetzelfde experiment.</p> <p>We hebben tot nu toe veel moeite gedaan om onze code te splitsen volgens het MVC-model: werken in laagjes, goed nadenken over wat waar hoort. Als dat netjes gelukt is kunnen we relatief makkelijk \u00e9\u00e9n van die laagjes vervangen. We kunnen de <code>ArduinoVISADevice</code> vervangen door een <code>RaspberryPiDevice</code> of een <code>PicoScopeDevice</code> <sup>8</sup>. Ook kunnen we een nieuwe applicatie schrijven voor ons bestaande experiment. We hoeven dan alleen een extra view te schrijven (de interface met de gebruiker) en de rest kunnen we hergebruiken. Misschien dat we hier en daar iets willen aanpassen maar zorg er dan voor dat je oude applicatie nog steeds werkt!</p> <p>We gaan nu \u2014 in stapjes \u2014 een grafische applicatie schrijven voor ons experiment.</p> <p>Ga je programmeren of gebruik je Designer?</p> <p>Je mag zelf kiezen of je de grafische interface gaat ontwerpen met Designer of dat je hem volledig programmeert. Als je kiest om Designer te gebruiken, staan hieronder een paar handige tips en trucs.</p> <p>Pythondaq: leeg venster</p> opdrachtcodecheck <p>      Je gaat in stapjes een GUI maken voor de <code>pythondaq</code> applicatie. Maak daarvoor een <code>gui.py</code> waarin een leeg GUI venster wordt gemaakt. Zorg dat het lege venster ook wordt getoond zodra je een commando in de terminal intypt.          De gebruiker test de GUI met de volgende handelingen. De gebruiker maakt een nieuwe conda environment aan met Python daarin . De gebruiker installeert de <code>Pythondaq</code> package met Poetry . De gebruiker kijkt in de <code>pyproject.toml</code> wat het commando is om de GUI op te starten. De gebruiker typte het commando in de terminal en ziet een leeg venster verschijnen.       <code>ECPC</code>     \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>src</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>gui.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code gui.py<pre><code># create empty window\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het uitvoeren van een commando zorgt ervoor dat een leeg venster wordt getoond. </li> <li> De GUI werkt ook na het installeren van de package <code>pythondaq</code> met Poetry in een nieuwe conda environment met Python. </li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: leeg venster</li> <li> Pythondaq: plot scan</li> <li> Pythondaq: widgets</li> <li> Pythondaq: save </li> <li> Pythondaq: selecteer Arduino </li> </ul> <p>Pythondaq: plot scan</p> opdrachtcodecheck <p>Pas de GUI aan zodat de applicatie een scan uitvoerd en de metingen in een plot laat zien binnen het venster. Voor het gemak mag je de poortnaam, start- en stopwaardes e.d. hard coded in je script zetten. Later ga je ervoor zorgen dat de gebruiker alles kan instellen en zelf een scan kan starten, maar dat komt straks wel.   De gebruiker test de GUI met de volgende handelingen. De gebruiker maakt een nieuwe conda environment aan met Python daarin . De gebruiker installeert de <code>Pythondaq</code> package met Poetry . De gebruiker kijkt in de <code>pyproject.toml</code> wat het commando is om de GUI op te starten. De gebruiker typte het commando in de terminal en ziet dat het LEDje gaat branden. Niet veel later ziet de gebruiker een grafiek met metingen verschijnen in de GUI. </p> <p>Foutenvlaggen plotten</p> <p>Foutenvlaggen toevoegen aan een pyqtgraph is helaas iets minder intuitief dan bij matplotlib. Met breedte en hoogte geef je aan hoe groot de vlaggen zijn, de vlag is 2 keer zo hoog of breed als de onzekerheid. Samen met de $x$ en $y$ data maak je dan een <code>ErrorBarItem</code> aan die je expliciet toevoegt aan de plot. Let op: <code>x</code>, <code>y</code>, <code>x_err</code> en <code>y_err</code> moeten NumPy arrays zijn of, en dat geldt alleen voor de errors, een vast getal. Gewone lijsten werken helaas niet.</p> <pre><code>def plot(self):\n    \"\"\"Clear the plot widget and display experimental data.\"\"\"\n\n    # Genereer wat data als demo.\n    # **Let op:** `x`, `y`, `x_err` en `y_err` *moeten* NumPy arrays zijn *of*,\n    # en dat geldt alleen voor de errors, een vast getal.\n    x = np.linspace(0, 2 * np.pi, 20)\n    y = np.sin(x)\n    x_err = 0.1\n    y_err = np.random.normal(0, 0.2, size=len(x))\n\n    # Maak eerst een scatterplot\n    self.plot_widget.plot(x, y, symbol=\"o\", symbolSize=5, pen=None)\n\n    # nu de foutvlaggen, met 'breedte' en 'hoogte' in plaats van x errors en y\n    # errors.\n    error_bars = pg.ErrorBarItem(x=x, y=y, width=2 * x_err, height=2 * y_err)\n    # we moeten de error_bars expliciet toevoegen aan de plot\n    self.plot_widget.addItem(error_bars)\n</code></pre> <p>Pseudo-code <pre><code># when application starts\n    # ask model to do scan\n    # plot results in application window\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Het uitvoeren van het commando zorgt ervoor dat een scan wordt gestart.</li> <li> Het LED lampje gaat branden.</li> <li> De resultaten van de meting worden geplot in het venster.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: leeg venster</li> <li> Pythondaq: plot scan</li> <li> Pythondaq: widgets</li> <li> Pythondaq: save </li> <li> Pythondaq: selecteer Arduino</li> </ul> <p>Pythondaq: widgets</p> opdrachtcodecheck <p>Pas de GUI aan zodat de applicatie opstart met een lege plot en widgets om de start- en stopwaardes, en het aantal metingen aan te passen en een startknop waarmee een (nieuwe) meting wordt uitgevoerd.  De gebruiker test de GUI met de volgende handelingen. De gebruiker typte het commando in de terminal en er verschijnt een GUI met daarin een lege plot. De gebruiker vult verschillende waardes in voor de start- en stopwaardes en het aantal metingen en drukt op de startknop. De gebruiker ziet dat het LEDje gaat branden. Niet veel later ziet de gebruiker een grafiek met metingen verschijnen in de GUI.</p> <p>Pseudo-code <pre><code># create widgets in designer or in the script\n# for start, stop, measurements and start scan\n\n# connect widgets to methods\n\n# methods for start, stop, measurements and start scan\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> De applicatie start op met een lege plot.</li> <li> In de applicatie kan de startwaarde in volt worden aangepast.</li> <li> In de applicatie kan de stopwaarde in volt worden aangepast.</li> <li> In de applicatie kan het aantal metingen worden aangepast.</li> <li> Druk op de startknop laat een meting starten.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: leeg venster</li> <li> Pythondaq: plot scan</li> <li> Pythondaq: widgets</li> <li> Pythondaq: save </li> <li> Pythondaq: selecteer Arduino </li> </ul>"},{"location":"gui/#plotwidget-toevoegen-in-designer","title":"Plotwidget toevoegen in Designer","text":"<p>Voeg als volgt een plot widget toe in Designer:</p> <ol> <li>Voeg aan je interface een Graphics View toe;</li> <li>Klik er op om hem te selecteren en klik daarna op de rechtermuistoets;</li> <li>Kies voor Promote To ...;</li> <li>Bij Promoted class name vul je in <code>PlotWidget</code> en bij Header file vul je in <code>pyqtgraph</code> (zonder <code>.h</code> aan het eind);</li> <li>Dan klik je op Add en vervolgens op Promote.</li> </ol> <p>De stappen zijn weergegeven in onderstaand screenshot. Bij de rode pijl vind je Graphics View en in het rode kader staat wat je moet invullen om te promoten:</p> <p></p> <p>Nu je dit een keer gedaan hebt kun je voortaan op een Graphics View meteen kiezen voor Promote to &gt; PlotWidget en hoef je niets meer in te typen. Vergeet niet je widget nog even een handige naam te geven, bijvoorbeeld <code>plot_widget</code>.</p>"},{"location":"gui/#commando-toevoegen-om-ui-te-vertalen-naar-py","title":"Commando toevoegen om .ui te vertalen naar .py","text":"<p>Als je Designer gaat gebruiken voor de grafische interface dan is het lastig dat je steeds <code>pyside-uic</code> moet aanroepen en moet zorgen dat je in de goede directory staat. We kunnen met Poetry taken aanmaken die je met een eenvoudig commando kunt laten uitvoeren. Die taken zijn alleen beschikbaar tijdens het ontwikkelen van je applicatie. Doe dit als volgt:</p> <ol> <li>Installeer Poe the Poet \u2014 een zogeheten task runner \u2014 als development dependency met:     Terminal<pre><code>poetry add --group dev poethepoet\n</code></pre>     We geven hiermee aan dat we dit package nodig hebben voor de ontwikkeling van onze applicatie, maar dat deze niet meegeleverd hoeft te worden als we de applicatie gaan delen met anderen.</li> <li>Voeg aan je <code>pyproject.toml</code> het volgende toe \u2014 uitgaande van de mappenstructuur in de <code>pythondaq</code> package en <code>mainwindow.ui</code> als naam van je <code>.ui</code>-bestand:     <pre><code>[tool.poe.tasks.compile]\nshell = \"\"\"\npyside6-uic src/pythondaq/mainwindow.ui --output src/pythondaq/ui_mainwindow.py\n\"\"\"\ninterpreter = [\"posix\", \"powershell\"]\n</code></pre>     Je kunt binnen de driedubbele aanhalingstekens meerdere regels toevoegen als je meerdere <code>.ui</code>-bestanden hebt \u2014 voor ieder bestand een regel.</li> <li>In bovenstaande regels is de naam na <code>tool.poe.tasks</code> de naam van de taak \u2014 in dit geval dus <code>compile</code>. Je kunt die naam zelf kiezen en vervolgens gebruiken om de taak uit te voeren in de terminal:     Terminal<pre><code>poe compile\n</code></pre>     En dat gaat een stuk sneller dan die lange <code>pyside-uic</code>-regel onthouden en intypen!</li> </ol>"},{"location":"gui/#bewaren-van-meetgegevens","title":"Bewaren van meetgegevens","text":"<p>Je zou na iedere meting de gegevens automatisch kunnen wegschrijven naar bestanden zonder dat de gebruiker nog iets kan kiezen, maar je kunt ook gebruik maken van een <code>Save</code>-knop en dialoogvensters. Je kunt de knop koppelen aan een method <code>save_data()</code> en daarin de volgende regel opnemen:</p> <pre><code>filename, _ = QtWidgets.QFileDialog.getSaveFileName(filter=\"CSV files (*.csv)\")\n</code></pre> <p>De functie <code>getSaveFileName()</code> opent een dialoogvenster om een bestand op te slaan. Vanwege het filter argument geeft het venster (op sommige besturingssystemen) alleen CSV-bestanden weer. In elk geval geldt op alle besturingssystemen dat als de gebruiker als naam <code>metingen</code> intypt, dat het filterargument ervoor zorgt dat er automatisch <code>.csv</code> achter geplakt wordt.<sup>9</sup> De functie geeft twee variabelen terug: <code>filename</code> en <code>filter</code>, die je zelf hebt meegegeven in bovenstaande aanroep. Die laatste kenden we dus al en gooien we weg met behulp van de weggooivariabele <code>_</code>.</p> <p>Het enige dat het dialoogvenster doet is de gebruiker laten kiezen waar en onder welke naam het bestand moet worden opgeslagen. Je krijgt echt alleen een pad en bestandsnaam terug, de data is niet opgeslagen en het bestand is niet aangemaakt. De variabele <code>filename</code> is echt niets anders dan een bestandsnaam, bijvoorbeeld: <code>/Users/david/LED-rood.csv</code>. Nadat je die bestandsnaam gekregen hebt moet je dus zelf nog code schrijven zodat het CSV-bestand wordt opgeslagen onder die naam.</p> <p>Pythondaq: save</p> opdrachtcodecheck <p>Pas de GUI aan zodat de applicatie de metingen kan wegschrijven naar een csv-bestand.  De gebruiker test de GUI met de volgende handelingen. De gebruiker typte het commando in de terminal en er verschijnt een GUI met daarin een lege plot. De gebruiker vult verschillende waardes in voor de start- en stopwaardes en het aantal metingen en drukt op de startknop. De gebruiker ziet dat het LEDje gaat branden. Niet veel later ziet de gebruiker een grafiek met metingen verschijnen in de GUI. De gebruiker ziet in de GUI een <code>Save</code>-knop en klikt daarop. Er vershijnt een dialoogvenster. De gebruiker kiest een locatie en typt een bestandsnaam en klikt op <code>Save</code> (of <code>Opslaan</code>). De gebruiker gaat op de computer naar de locatie waar het bestand opgeslagen zou zijn. De gebruiker opent het bestand en ziet de metingen staan. </p> <p>Pseudo-code <pre><code># create widget for save in designer or in the script\n\n# connect widget to method\n\n# methods save\n    # open dialog\n    # save measurements as csv in given filename\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> Druk op de knop <code>Save</code> opent een dialoogvenster.</li> <li> De metingen worden opgeslagen als csv-bestand op de gegeven locatie en onder de gegeven bestandsnaam.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: leeg venster</li> <li> Pythondaq: plot scan</li> <li> Pythondaq: widgets</li> <li> Pythondaq: save </li> <li> Pythondaq: selecteer Arduino </li> </ul> Menu's, taak- en statusbalken"},{"location":"gui/#menus-taak-en-statusbalken","title":"Menu's, taak- en statusbalken","text":"<p>Je kunt je grafische applicatie volledig optuigen met menu's of taakbalken. Ook kun je onderin je applicatie met een statusbalk weergeven wat de status is: gereed, aan het meten, foutcode, etc. Dat valt buiten het bestek van deze cursus, maar een mooie referentie is PySide6 Toolbars &amp; Menus \u2014 QAction.<sup>16</sup> Als je vaker grafische applicaties wilt gaan maken dan moet je dat zeker eens doornemen!</p> <p>Pythondaq: statusbalk</p> <p>Maak een statusbalk die aangeeft wat de identificatiestring is van het device dat geselecteerd is. Maak ook een menu waarmee je een CSV-bestand kunt opslaan en een nieuwe meting kunt starten. Let op: je hebt dan een menu-item \u00e9n een knop die dezelfde method aanroepen. Je hoeft geen dubbele code te schrijven, maar moet de <code>save_data()</code>-method wel twee keer verbinden.</p>"},{"location":"gui/#selecteer-de-arduino","title":"Selecteer de Arduino","text":"<p>Je hebt nu waarschijnlijk nog de poortnaam van de Arduino in je code gedefinieerd als vaste waarde. Dat betekent dat als je de code deelt met iemand anders \u2014 bijvoorbeeld wanneer je de code inlevert op Canvas of wanneer je je experiment op een labcomputer wilt draaien \u2014 je het risico loopt dat je applicatie crasht omdat de Arduino aan een andere poort hangt. Zeker bij de overstap van Windows naar MacOS of Linux, of andersom! Je kunt dit op twee manieren oplossen:</p> <ol> <li>Je maakt een keuzemenu waarmee de gebruiker de Arduino kan selecteren;</li> <li>Je probeert de Arduino te detecteren op \u00e9\u00e9n van de poorten. De gebruiker hoeft dan niet te weten welke poort dat zou kunnen zijn. Het werkt dan vanzelf!</li> </ol> <p>Je kunt je voorstellen dat mogelijkheid 2 de voorkeur heeft! Helaas is dit moeilijker dan gedacht. Zodra je andere devices gaat openen en commando's gaat sturen om te ontdekken wat voor apparaat het is kunnen er gekke dingen gebeuren. Onder MacOS bijvoorbeeld kunnen Bluetooth luidsprekers en koptelefoons opeens ontkoppelen. We gaan dus toch voor keuze 1. Bijkomend voordeel van deze keuze is dat je meerdere Arduino's aan je computer kunt hangen en kunt schakelen \u2014 vooral handig als je meerdere experimenten vanaf \u00e9\u00e9n computer wilt aansturen.</p> <p>Pythondaq: selecteer Arduino</p> opdrachtcodecheck <p>Pas de GUI aan zodat het mogelijk is om een device te selecteren.  De gebruiker test de GUI met de volgende handelingen. De gebruiker typte het commando in de terminal en er verschijnt een GUI met daarin een lege plot. De gebruiker ziet ook een keuzemenu (<code>QComboBox</code>), de gebruiker klikt op het keuzemenu en ziet een lijstje van poorten verschijnen. De gebruiker selecteert de poort waarop de Arduino is aangesloten. De gebruiker start een meting en ziet het LEDje branden.  De gebruiker leent een (of twee, of drie) Arduino('s) bij de buren en sluit deze aan op de computer en start opnieuw de applicatie. Ditmaal ziet de gebruiker veel meer poorten in het keuzemenu staan. De gebruiker kiest een Arduino, start een meting en ziet een lampje branden. De gebruiker selecteert daarna een andere Arduino, start een meting en ziet een ander lampje branden, hoe leuk .</p> <p>Arduino afsluiten</p> <p>Als je met meerdere Arduino's werkt kan het handig zijn om na afloop van de scan de communicatie met de Arduino weer te sluiten. In de opdracht Pyvisa in terminal heb je al eens gewerkt met het commando <code>close</code>. Dit werkt ook voor pyvisa in een script. Je hebt in de controller de communicatie geopend met <code>self.device = rm.open_resource(port, read_termination=\"\\r\\n\", write_termination=\"\\n\")</code>, je kunt de communicatie met <code>self.device</code> in de controller sluiten met <code>self.device.close()</code>. Je kunt een method in de controller toevoegen die de communicatie sluit. Via het model kun je deze method aanroepen in de gui.</p> <p>Pseudo-code <pre><code># create widget for select Arduino\n\n# method start scan\n    # open communication with selected Arduino\n    # start scan\n</code></pre></p> <p>Checkpunten:</p> <ul> <li> In de applicatie kan een Arduino geselecteerd worden.</li> <li> De gekozen Arduino wordt gebruikt tijdens het uitvoeren van een scan</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: leeg venster</li> <li> Pythondaq: plot scan</li> <li> Pythondaq: widgets</li> <li> Pythondaq: save </li> <li> Pythondaq: selecteer Arduino</li> </ul> Threads <ol> <li> <p>Uitspraak: het Engelse cute.\u00a0\u21a9</p> </li> <li> <p>Of in \u00e9\u00e9n keer met View &gt; Command Palette &gt; Terminal: Kill All Terminals \u21a9</p> </li> <li> <p>Die kun je eventuele command-line arguments meegeven die door Python in <code>sys.argv</code> bewaard worden. Meestal zijn die leeg, maar we geven ze gewoon door aan Qt.\u00a0\u21a9</p> </li> <li> <p>Waarom doen de knoppen niets als je er op klikt?\u00a0\u21a9</p> </li> <li> <p>https://doc.qt.io/qtforpython/PySide6/QtWidgets/index.html#list-of-classes \u21a9</p> </li> <li> <p>https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/index.html#list-of-classes \u21a9</p> </li> <li> <p>Overleg met elkaar of met de assistent als je niet weet hoe dat moet.\u00a0\u21a9</p> </li> <li> <p>Je moet dan wel eerst nieuwe controllers schrijven (of krijgen van een collega) om deze nieuwe instrumenten aan te sturen. Maar als je die hebt kun je vrij eenvoudig wisselen.\u00a0\u21a9</p> </li> <li> <p>Het eerste deel van het argument (<code>CSV files</code>) is vrij te kiezen en geeft alleen informatie aan de gebruiker. Het deel tussen haakjes (<code>*.csv</code>) is het gedeelte dat echt van belang is. Het geeft de extensie die achter alle bestandsnamen geplakt wordt.\u00a0\u21a9</p> </li> <li> <p>Er is een subtiliteit. In Python draaien threads niet tegelijk, maar om de beurt. In de praktijk merk je daar niet veel van: threads worden z\u00f3 vaak per seconde gewisseld dat het lijkt alsof ze tegelijk draaien. Terwijl de ene thread steeds even tijd krijgt voor een meting kan de andere thread steeds even de plot verversen. In het geval van zwaar rekenwerk schiet het alleen niet op. Er draait maar \u00e9\u00e9n berekening tegelijkertijd dus threads of niet, het is even snel. Wil je echt parallel rekenen, dan moet je kijken naar de <code>multiprocessing</code> module om meerdere processen te starten in plaats van threads.\u00a0\u21a9</p> </li> <li> <p>Variabelen die we in een class defini\u00ebren door ze aan te maken met <code>self.</code> ervoor zijn instance attributes.\u00a0\u21a9</p> </li> <li> <p>Hier zie je een probleem met threads. Het k\u00e1n \u2014 in uitzonderlijke situaties \u2014 voorkomen dat de plot-functie n\u00e9t wil gaan plotten als de $x$-waardes al langer gemaakt zijn, maar de $y$-waardes nog niet. Die kans is heel klein en wij accepteren het risico. Schrijf je software voor een complex experiment dat drie dagen draait, dan is dit iets waar je echt rekening mee moet houden. Je moet dan gebruik gaan maken van zogeheten locks of semaphores maar dat valt buiten het bestek van deze cursus.\u00a0\u21a9</p> </li> <li> <p>Door een beetje ons best te doen kunnen we ervoor zorgen dat zowel de command-line interface als de grafische interface allebei gebruikt kunnen worden.\u00a0\u21a9</p> </li> <li> <p>Matt Newville. Asteval: minimal python ast evaluator. URL: https://newville.github.io/asteval.\u00a0\u21a9</p> </li> <li> <p>Leodanis Pozo Ramos. Python eval(): evaluate expressions dynamically. 2020. URL: https://realpython.com/python-eval-function/.\u00a0\u21a9</p> </li> <li> <p>Martin Fitzpatrick. Pyside6 toolbars &amp; menus \u2014 qaction. 2021. URL: https://www.pythonguis.com/tutorials/pyside6-actions-toolbars-menus/.\u00a0\u21a9</p> </li> </ol>"},{"location":"gui/#meerdere-dingen-tegelijkertijd-threads","title":"Meerdere dingen tegelijkertijd: threads","text":"<p>Afhankelijk van de instellingen die we gekozen hebben kan een meting best lang duren. In ieder geval moeten we even wachten tot de meting afgelopen is en pas daarna krijgen we de resultaten te zien in een plot. Als een meting langer duurt dan een paar seconden kan het besturingssysteem zelfs aangeven dat onze applicatie niet meer reageert. En inderdaad, als we ondertussen op knoppen proberen te drukken dan reageert hij nergens op. Onze applicatie kan helaas niet twee dingen tegelijk. Kon hij dat wel, dan zouden we zien hoe de grafiek langzaam opbouwt tot het eindresultaat.</p> <p>De manier waarop besturingssystemen meerdere dingen tegelijk doen is gebaseerd op processes en threads. Een process is, eenvoudig gezegd, een programma. Als je meerdere applicaties opstart zijn dat allemaal processen. Besturingssystemen regelen dat ieder proces een stuk geheugen krijgt en tijd van de processor krijgt toegewezen om zijn werk te doen. Processen zijn mooi gescheiden en kunnen dus eenvoudig naast elkaar draaien. Het wordt iets lastiger als een proces meerdere dingen tegelijk wil doen. Dat kan wel, met threads. Het besturingssysteem zorgt dat meerdere threads naast elkaar draaien.<sup>10</sup></p> <p>Threads geven vaak problemen omdat ze in zekere zin onvoorspelbaar zijn. Je weet niet precies hoe snel een thread draait, dus je weet niet zeker wat er in welke volgorde gebeurt. Dit kan leiden tot problemen waarvan de oorzaak maar lastig te vinden is. Google maar eens op <code>thread problems in programming</code>. We moeten dus voorzichtig zijn! Ook is het ombouwen van code zonder threads naar code met threads een klus waar makkelijk iets fout gaat. Het is dus belangrijk dat je in kleine stapjes je code aanpast en vaak test of het nog werkt.</p> <p>Info</p> <p>We gaan in het volgende stuk een kleine applicatie ombouwen van no-threads naar threads. We raden je ten zeerste aan om de code te copy/pasten en dan stapje voor stapje aan te passen zoals in de handleiding gebeurt. Probeer alle stappen dus zelf! Pas na stap 4 ga je aan de slag om je eigen code om te bouwen. Samenvattend: doorloop dit stuk handleiding twee keer. De eerste keer doe je de opdrachten met het demoscript, de tweede keer met je eigen code voor <code>pythondaq</code>.</p> view.pymodel.py <pre><code>import sys\n\nimport numpy as np\n\nfrom PySide6 import QtWidgets\nimport pyqtgraph as pg\n\nfrom model import Experiment\n\n\nclass UserInterface(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        central_widget = QtWidgets.QWidget()\n        self.setCentralWidget(central_widget)\n\n        vbox = QtWidgets.QVBoxLayout()\n        central_widget.setLayout(vbox)\n        self.plot_widget = pg.PlotWidget()\n        vbox.addWidget(self.plot_widget)\n        start_button = QtWidgets.QPushButton(\"Start\")\n        vbox.addWidget(start_button)\n\n        start_button.clicked.connect(self.plot)\n\n        # Maak een instance aan van Experiment\n        self.experiment = Experiment()\n\n    def plot(self):\n        \"\"\" Clear the plot widget and display experimental data. \"\"\"\n        self.plot_widget.clear()\n        x, y = self.experiment.scan(0, np.pi, 50)\n        self.plot_widget.plot(x, y, symbol=\"o\", symbolSize=5, pen=None)\n\ndef main():\n    app = QtWidgets.QApplication(sys.argv)\n    ui = UserInterface()\n    ui.show()\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()   \n</code></pre> <pre><code>import time\nimport numpy as np\n\nclass Experiment:\n    def scan(self, start, stop, steps):\n        \"\"\" Perform a scan over a range with specified steps and return the scanned values. \"\"\"\n        x = np.linspace(start, stop, steps)\n        y = []\n        for u in x:\n            y.append(np.sin(u))\n            time.sleep(0.1)\n        return x, y\n</code></pre> <p>In regels 15--24 bouwen we een kleine user interface op met een plot widget en een startknop. We koppelen die knop aan de <code>plot()</code>-method. In regel 27 maken we ons experiment (het model) aan en bewaren die. In regels 30--34 maken we de plot schoon, voeren we een scan uit en plotten het resultaat. <code>model.py</code> vormt ons experiment. Eerst wordt een rij $x$-waardes klaargezet en dan, in een loop, wordt punt voor punt de sinus uitgerekend en toegevoegd aan een lijst met $y$-waardes. De <code>time.sleep(.1)</code> wacht steeds 0.1 s en zorgt hiermee voor de simulatie van trage metingen. En inderdaad, als we deze code draaien dan moeten we zo'n vijf seconden wachten voordat de plot verschijnt.</p> <p>In de volgende opdrachten gaan we de code stap voor stap ombouwen naar threads. Als we daarmee klaar zijn worden de metingen gedaan binnen de <code>scan()</code>-method van de <code>Experiment()</code>-class en verversen we ondertussen af en toe de plot. De <code>plot()</code>-method van onze user interface wordt regelmatig aangeroepen terwijl de meting nog loopt en moet dus de hele tijd de huidige metingen uit kunnen lezen. Dat kan, als de metingen worden bewaard in instance attributes.<sup>11</sup></p> <p>Threads 0</p> <p>Neem <code>view.py</code> en <code>model.py</code> over en test de applicatie.</p>"},{"location":"gui/#stap-1-de-meetgegevens-altijd-beschikbaar-maken","title":"Stap 1: de meetgegevens altijd beschikbaar maken","text":"<p>We maken in de <code>scan()</code>-method lege lijsten <code>self.x</code> en <code>self.y</code>. Hier komen de meetgegevens in en die staan dus los van de lijst met $x$-waardes die je klaarzet. Met andere woorden: de variabele <code>x</code> is niet hetzelfde als de variabele <code>self.x</code>:</p> model.py <pre><code>class Experiment:\n    def scan(self, start, stop, steps):\n        x = np.linspace(start, stop, steps)\n        self.x = []\n        self.y = []\n        for u in x:\n            self.x.append(u)\n            self.y.append(np.sin(u))\n            time.sleep(0.1)\n        return self.x, self.y\n</code></pre> <p>We zorgen er zo voor dat de lijst met meetgegevens voor zowel de $x$- als de $y$-waardes steeds even lang zijn. Dit is nodig voor het plotten: hij kan geen grafiek maken van 50 $x$-waardes en maar 10 $y$-waardes.<sup>12</sup> Ook moeten we er voor zorgen dat er altijd (lege) meetgegevens beschikbaar zijn \u2014 ook als de meting nog niet gestart is. Anders krijgen we voordat we een meting hebben kunnen doen een foutmelding dat <code>self.x</code> niet bestaat. We doen dat in de <code>__init__()</code>:</p> model.py <pre><code>class Experiment:\n    def __init__(self):\n        self.x = []\n        self.y = []\n\n    ...\n</code></pre> <p>We laten <code>self.x = []</code> (en idem voor <code>self.y</code>) ook staan in de <code>scan()</code>-methode zodat bij iedere nieuwe scan de oude meetgegevens worden leeggemaakt.</p> <p>Threads I</p> <p>Pas de code aan zodat de meetgegevens altijd beschikbaar zijn. Test je code, de applicatie moet nog steeds werken.</p>"},{"location":"gui/#stap-2-plot-de-meetgegevens-vanuit-het-experiment","title":"Stap 2: plot de meetgegevens vanuit het experiment","text":"<p>Nu we de meetgegevens bewaren als instance attributes van de <code>Experiment</code>-class kunnen we die ook plotten. We geven ze nog steeds terug als return value vanuit de <code>scan()</code>-method voor ouderwetse code,<sup>13</sup> maar wij gaan nu de nieuwerwetse instance attributes gebruiken:</p> view.py <pre><code>class UserInterface(QtWidgets.QMainWindow):\n\n    ...\n\n    def plot(self):\n        \"\"\" Clear the plot widget and display experimental data. \"\"\"\n        self.plot_widget.clear()\n        self.experiment.scan(0, np.pi, 50)\n        self.plot_widget.plot(\n            self.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n        )\n</code></pre> <p>De code wordt hier niet sneller van \u2014 hij maakt nog steeds pas een grafiek als de meting helemaal is afgelopen \u2014 maar we bereiden de code wel voor op het gebruik van de instance attributes.</p> <p>Threads II</p> <p>Pas de code aan zodat je instance attributes gebruikt voor het plotten. Test je code, het moet nog steeds werken als vanouds.</p>"},{"location":"gui/#stap-3-threads","title":"Stap 3: threads","text":"<p>We gaan nu met threads werken. Je importeert daarvoor de <code>threading</code> module en maakt voor iedere thread een <code>threading.Thread()</code> instance. Deze heeft twee belangrijke parameters: <code>target</code> waarmee je de functie (of method) aangeeft die in de thread moet worden uitgevoerd, en <code>args</code> waarmee je argumenten meegeeft voor die functie of method. We maken een nieuwe method <code>start_scan()</code> waarmee we een nieuwe thread starten om een scan uit te voeren. We doen dit als volgt:</p> model.py <pre><code>import threading\n\nclass Experiment:\n    def start_scan(self, start, stop, steps):\n        \"\"\"Start a new thread to execute a scan.\"\"\"\n        self._scan_thread = threading.Thread(\n            target=self.scan, args=(start, stop, steps)\n        )\n        self._scan_thread.start()\n\n    def scan(self, start, stop, steps):\n        \"\"\" Perform a scan over a range with specified steps and return the scanned values. \"\"\"\n        x = np.linspace(start, stop, steps)\n        self.x = []\n        self.y = []\n        for u in x:\n            self.x.append(u)\n            self.y.append(np.sin(u))\n            time.sleep(0.1)\n        return self.x, self.y\n</code></pre> <p>In plaats van dat onze plotfunctie de <code>scan()</code>-method aanroept, moeten we nu de <code>start_scan()</code>-method aanroepen. Maar: die method start een scan en sluit meteen af, terwijl de daadwerkelijke meting op de achtergrond wordt uitgevoerd. De plotfunctie moet \u2014 in deze stap nog even \u2014 wachten tot de scan klaar is. Er is een manier om op een thread te wachten. Je moet daartoe de <code>join()</code> method van de thread aanroepen. In bovenstaande code hebben we de thread bewaard in de variabele <code>_scan_thread</code>, dus hij is voor ons beschikbaar:</p> view.py <pre><code>class UserInterface(QtWidgets.QMainWindow):\n\n    ...\n\n    def plot(self):\n        \"\"\" Clear the plot widget and display experimental data. \"\"\"\n        self.plot_widget.clear()\n        self.experiment.start_scan(0, np.pi, 50)\n        self.experiment._scan_thread.join()\n        self.plot_widget.plot(\n            self.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n        )\n</code></pre> <p>Threads III</p> <ul> <li>Pas de code aan zodat je een thread opstart om de scan op de achtergrond uit te voeren. Roep in je plotfunctie de goede method aan en wacht tot de thread klaar is. Test je code. Wederom moet het werken als vanouds. </li> <li>Kijk ook eens wat er gebeurt als je niet wacht tot de metingen klaar zijn door de regel <code>self.experiment._scan_thread.join()</code> uit te commentari\u00ebren (hekje ervoor). Niet vergeten het hekje weer weg te halen.</li> </ul>"},{"location":"gui/#stap-4-plotten-op-de-achtergrond","title":"Stap 4: plotten op de achtergrond","text":"<p>We zijn er nu bijna. We gebruiken threads om de metingen op de achtergrond uit te voeren maar we wachten nog steeds tot de metingen klaar zijn voordat we \u2014 eenmalig \u2014 de grafiek plotten. In deze laatste stap doen we dat niet meer. Als je straks op de startknop drukt dan start de meting op de achtergrond. Ondertussen wordt er regelmatig geplot. Je ziet dan tijdens de metingen de plot opbouwen. We doen dat door het scannen en plotten van elkaar los te koppelen \u2014 niet meer samen in \u00e9\u00e9n functie \u2014 en door met een <code>QTimer</code> de plotfunctie periodiek aan te roepen. Kijk de code goed door.</p> view.py <pre><code>from PySide6 import QtWidgets, QtCore\n\nclass UserInterface(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        ...\n\n        start_button.clicked.connect(self.start_scan)\n\n        ...            \n\n        # Plot timer\n        self.plot_timer = QtCore.QTimer()\n        # Roep iedere 100 ms de plotfunctie aan\n        self.plot_timer.timeout.connect(self.plot)\n        self.plot_timer.start(100)\n\n    def start_scan(self):\n        \"\"\"Starts a scanning process with specified parameters.\"\"\"\n        self.experiment.start_scan(0, np.pi, 50)\n\n    def plot(self):\n        \"\"\" Clear the plot widget and display experimental data. \"\"\"\n        self.plot_widget.clear()\n        # Twee regels code zijn verwijderd\n        self.plot_widget.plot(\n            self.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n        )\n</code></pre> <p>Hiermee zijn we klaar met de implementatie van threads. De gebruiker hoeft niet langer in spanning te wachten maar krijgt onmiddelijke feedback.</p> <p>Threads IV</p> <p>Pas de code op dezelfde manier aan zodat de metingen op de achergrond worden uitgevoerd terwijl je de plot ziet opbouwen. De code werkt nu niet als vanouds, en voelt veel sneller!</p> <p>Pythondaq: threads in je eigen code</p> <p>Doorloop nu opnieuw stappen 1 t/m 4 maar dan voor je eigen <code>pythondaq</code>-applicatie.</p> Events"},{"location":"gui/#stap-5-puntjes-op-de-i-events","title":"Stap 5: puntjes op de i: events","text":"<p>Wanneer je op de startknop drukt, even wacht en dan w\u00e9\u00e9r op de startknop drukt, dan kun je zien dat er twee metingen tegelijk worden uitgevoerd op de achtergrond. Dat wil je voorkomen. Ook is het wel aardig om metingen tussentijds te kunnen stoppen. Dat is vooral handig als je merkt dat een meting veel te lang gaat duren. Verder is het ook nog zo dat we er nu met onze timer voor gezorgd hebben dat de plotfunctie meerdere keren per seconde wordt uitgevoerd \u2014 of er nu een meting loopt of niet.</p> <p>Je kunt dit oplossen met <code>threading.Event()</code> objecten. Dit zijn objecten met <code>set()</code>, <code>clear()</code> en <code>wait()</code> methods om gebeurtenissen aan te geven of er op te wachten. Zo kun je een event <code>is_scanning</code> aanmaken die je <code>set()</code> zodra een meting begint en <code>clear()</code> zodra de meting is afgelopen. Je controleert bij de start van de meting dan bijvoorbeeld eerst of de meting al loopt met <code>is_scanning.is_set()</code> en start alleen een meting als dat nog niet zo is.</p> <p>Ook kun je in de grafische interface na het starten van een meting de startknop onbeschikbaar maken met <code>start_button.setEnabled(False)</code> en weer beschikbaar maken met <code>start_button.setEnabled(True)</code>. De knop wordt dan tussendoor grijs. Dat kan handig zijn om duidelijk te maken dat een meting al loopt en dat je niet nogmaals op de startknop kunt drukken.</p> <p>Vergrendelen</p> <pre><code>Pas je code aan zodat je niet meerdere metingen tegelijk kunt starten. Zorg er ook voor dat de grafiek alleen geplot wordt tijdens de metingen (of tot kort daarna), maar niet de hele tijd.\n</code></pre>"},{"location":"kleurcodes/","title":"Kleurcodes voor weerstanden","text":"Kleur Cijferwaarde Vermenigvuldigingsfactor Tolerantie (%) Zilver --- 10<sup>-2</sup> 10 Goud --- 10<sup>-1</sup> 5 Zwart 0 10<sup>0</sup> --- Bruin 1 10<sup>1</sup> 1 Rood 2 10<sup>2</sup> 2 Oranje 3 10<sup>3</sup> 0.05 Geel 4 10<sup>4</sup> 0.02 Groen 5 10<sup>5</sup> 0.5 Blauw 6 10<sup>6</sup> 0.25 Paars 7 10<sup>7</sup> 0.1 Grijs 8 10<sup>8</sup> 0.01 Wit 9 10<sup>9</sup> --- <p>Helaas is het niet altijd mogelijk om de linkerkant van de weerstand van de rechterkant te onderscheiden. In dat geval moet je de weerstand beide kanten oplezen en vergelijken met je materialenlijst of de overige weerstanden om zeker te weten dat je de goede hebt gevonden. Bovenstaande weerstand heeft de waarde  220\u22c510<sup>0</sup> \u03a9 \u00b1 1 %, en niet de waarde 100\u22c510<sup>2</sup> \u03a9 \u00b1 2 %.</p>"},{"location":"mvc/","title":"Model-View-Controller","text":""},{"location":"mvc/#mvc-en-het-gebruik-van-packages","title":"MVC en het gebruik van packages","text":"<p>MVC staat voor Model-View-Controller en is een belangrijk, maar ook een wat diffuus concept in software engineering en is vooral van toepassing op gebruikersinterfaces. Het belangrijkste idee is dat een programma zoveel mogelijk wordt opgesplitst in onderdelen. Het model bevat de onderliggende data en concepten van het programma (een database, meetgegevens, berekeningen, etc.); de controller praat met de fysieke omgeving en reageert bijvoorbeeld op invoer van een gebruiker en past het model aan; de view is een weergave van de data uit het model en vormt de gebruikersinterface zelf. Vaak praten alle onderdelen met elkaar, maar een gelaagd programma is makkelijker te overzien en dus eenvoudiger te programmeren. In het geval van een natuurkunde-experiment is een gelaagd programma vaak mogelijk. Daarmee krijgt MVC in deze cursus een andere betekenis dan bijvoorbeeld bij het bouwen van websites. Het gelaagde MVC-programma dat je gaat gebruiken is hieronder weergegeven:</p> <p></p> <p>De controllers communiceren met de apparatuur, zij bevatten informatie en berekeningen die apparatuur afhankelijk zijn; het model bevat de meetgegevens, berekeningen over - en de opzet van - het experiment; de view zorgt voor een gebruikersinterface met weergave van de data.</p> <p>Het scheiden van je programma in deze lagen kan enorm helpen om ervoor te zorgen dat je geen spaghetticode schrijft \u2014 ongestructureerde en moeilijk te begrijpen code. Wanneer het drukken op een knop in de grafische omgeving maakt dat er direct commando's gestuurd worden naar de Arduino of dat de code voor het doen van een enkele meting meteen de $x$-as van een grafiek aanpast, dan sla je lagen over en knoop je delen van het programma aan elkaar die niet direct iets met elkaar te maken hebben. De knop moet een meting starten, ja, maar hoe dat precies moet is niet de taak van de gebruikersinterface. En de meting zelf moet zich niet bemoeien met welke grafiek er precies getekend wordt. Je zult merken dat het heel lastig wordt om overzicht te houden en later aanpassingen te doen als je alles door elkaar laat lopen. Je zult dan je hele code moeten doorzoeken als je \u00f3f de aansturing van de Arduino, \u00f3f de grafische interface wilt aanpassen. Om dat te voorkomen ga je alles netjes structureren.</p> <p>De verschillende onderdelen in het programma kun je als volgt beschrijven:</p> View Het startpunt van je applicatie. Geeft de opdracht om een meting te starten en geeft na afloop de resultaten van de meting weer op het scherm. Model De code die het experiment uitvoert door verschillende metingen te doen en instellingen aan te passen, zoals de spanning over de LED. Het model weet hoe het experiment in elkaar zit en dat er bijvoorbeeld een weerstand van 220 \u03a9 aanwezig is. Geeft opdrachten aan de controller. Controller De code die via <code>pyvisa</code> praat met de Arduino. Opdrachten worden omgezet in firmwarecommando's en doorgestuurd naar het apparaat. <p>Het opsplitsen van je programma hoeft niet in \u00e9\u00e9n keer! Dit kan stapsgewijs. Je kunt starten met een eenvoudig script \u2014 zoals je eerder gedaan hebt met <code>diode_experiment.py</code> \u2014 en dat langzaam uitbreiden.  Je begint klein, verdeelt je code in lagen en bouwt vervolgens verder.</p>"},{"location":"mvc/#implementeren-van-mvc","title":"Implementeren van MVC","text":"<p>Het opsplitsen van het <code>diode_experiment.py</code> in MVC ga je stapsgewijs doen. Je gaat eerst een class maken voor de aansturing van de Arduino, deze class valt in de categorie controller.</p> <p>Pythondaq: open repository</p> opdrachtcheck <p>Open in GitHub Desktop de repository van <code>pythondaq</code> en open deze repository in Visual Studio Code. In de volgende opdrachten ga je het <code>diode_experiment.py</code> uitbreiden en opsplitsen in model-view-controller.</p> <p>Projecttraject</p> <ul> <li> Pythondaq: open repository</li> <li> Pythondaq: controller bouwen</li> <li> Pythondaq: controller implementeren</li> <li> Pythondaq: controller afsplitsen</li> <li> Pythondaq: model en view splitsen</li> </ul> <p>Pythondaq: controller bouwen</p> opdrachtcodecheck <p>      Je schrijft een script <code>test_controller.py</code> waarmee je de Arduino aanstuurt. Een gebruiker test de door jou geschreven controller met de volgende handelingen:      <ul> <li> De gebruiker vraagt een lijst met beschikbare poorten op met de functie <code>list_resources()</code>.</li> <li> De gebruiker weet daarna aan welke poort de Arduino hangt en gebruikt deze poortnaam om een instance aan te maken van de class <code>ArduinoVISADevice</code>. Met deze class kan de gebruiker met de Arduino communiceren.</li> <li> Met de method <code>get_identification()</code> vraagt de gebruiker de identificatiestring op. </li> <li> De gebruiker zet met de method <code>set_output_value()</code> een waarde van 828 op uitvoerkanaal 0. De gebruiker ziet de LED branden en weet daardoor dat de method werkt.</li> <li> De gebruiker controleert met de method <code>get_output_value()</code> de waarde op uitvoerkanaal 0, die nog steeds 828 zou moeten zijn. </li> <li> De gebruiker vraagt met de method <code>get_input_value()</code> de spanning op kanaal 1 op. Dit herhaalt de gebruiker vervolgens voor kanaal 2.</li> <li> Met de method <code>get_input_voltage()</code> vraagt de gebruiker de spanning van kanaal 1 op in volt. De gebruiker rekent de gegeven waarde van de method <code>get_input_value()</code> op kanaal 1 om naar volt en ziet dat deze overeenkomt met de gegeven spanning door de method <code>get_input_voltage()</code> op kanaal 1. </li> </ul> <code>ECPC</code>      \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>diode_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>test_controller.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Pseudo-code test_controller.py<pre><code># def list_resources\n#    return list of available ports\n#\n# class ArduinoVISADevice:\n#    def __init__ (ask port from user)\n#        open device\n#\n#    def get_identification\n#        return identification string of connected device\n#\n#   def set_output_value\n#        set a value on the output channel\n#\n#   def get_output_value\n#        return the value of the output channel\n#      \n#   def get_input_value\n#        return the value of the input channel\n#\n#   def get_input_voltage\n#        return voltage in volt of the input channel\n</code></pre> Testcode  test_controller.py <pre><code># get available ports\nprint(list_resources())\n\n# create an instance for the Arduino on port \"ASRL28::INSTR\"\ndevice = ArduinoVISADevice(port=\"ASRL28::INSTR\")\n\n# print identification string\nidentification = device.get_identification()\nprint(identification)\n\n# set OUTPUT voltage on channel 0 in ADC values (0 - 1023)\ndevice.set_output_value(value=828)\n\n# measure the voltage on INPUT channel 2 in ADC values (0 - 1023)\nch2_value = device.get_input_value(channel=2)\nprint(f\"{ch2_value=}\")\n\n# measure the voltage on INPUT channel 2 in volts (0 - 3.3 V)\nch2_voltage = device.get_input_voltage(channel=2)\nprint(f\"{ch2_voltage=}\")\n\n# get the previously set OUTPUT voltage on channel 0 in ADC values (0 - 1023)\nch0_value = device.get_output_value()\nprint(f\"{ch0_value=}\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python test_controller.py\n('ASRL28::INSTR') \nArduino VISA firmware v1.1.0\nch2_value=224\nch2_voltage=0.7774193548387097\nch0_value=828\n</code></pre></p> <p>Checkpunten</p> <ul> <li> <code>list_resources()</code> is een functie die buiten de class staat.</li> <li> Aan de <code>__init__()</code>-method moet een poortnaam worden meegegeven.</li> <li> De <code>__init__()</code>-method opent de communicatie met de Arduino.</li> <li> Er is een method <code>get_identification()</code> die de identificatiestring teruggeeft.</li> <li> Aan de method <code>set_output_value()</code> moet een ADC-waarde worden meegegeven.</li> <li> De methods <code>set_output_value()</code> en <code>get_output_value()</code> communiceren standaard met kanaal 0.</li> <li> Aan de methods <code>get_input_value()</code> en <code>get_input_voltage()</code> moet een kanaal worden meegegeven. </li> <li> De methods <code>get_output_value()</code>, <code>get_input_value()</code> en <code>get_input_voltage</code> geven een ADC-waarde dan wel een spanning in volt terug.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: open repository</li> <li> Pythondaq: controller bouwen</li> <li> Pythondaq: controller implementeren</li> <li> Pythondaq: controller afsplitsen</li> <li> Pythondaq: model en view splitsen</li> </ul> <p>Je hebt nu een werkende controller, maar je gebruikt deze nog niet in je experiment. </p> <p>Pythondaq: controller implementeren</p> opdrachtcodecheck <p>Kopieer de functie <code>list_resources()</code> en de class <code>ArduinoVISADevice</code> uit het bestand <code>test_controller.py</code>. Voeg deze functie en class toe aan het bestand <code>diode_experiment.py</code>. Pas de code daarna zo aan dat in het bestand <code>diode_experiment.py</code> gebruikgemaakt wordt van de betreffende functie en de class met de bijhorende methods.</p> <p>Pseudo-code diode_experiment.py<pre><code># def list_resources\n#   ...\n#\n# class ArduinoVISADevice\n#   ...\n#\n# get list resources\n# connect to Arduino via class ArduinoVISADevice\n#\n# set output voltage from 0 to max\n#   set number of repeated measurements\n#       measure voltages\n#       calculate voltage LED\n#       calculate current LED\n#   calculate average voltage LED and uncertainty\n#   calculate average current LED and uncertainty\n#   print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#\n# turn LED off\n# create csv-file\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> In een script staan de functie <code>list_resources()</code>, de class <code>ArduinoVISADevice</code> en de code om de LED te laten branden, metingen te doen en het resultaat te laten zien.</li> <li> Wanneer de class <code>ArduinoVISADevice</code> uit het script wordt geknipt, werkt het bestand <code>diode_experiment.py</code> niet meer.</li> <li> Er wordt een lijst geprint met beschikbare poorten.</li> <li> Er wordt een plot getoond van de gemiddelde spanning over en de gemiddelde stroomsterkte door de LED met de bijbehorende onzekerheden.</li> <li> De gemiddelde spanning over en de gemiddelde stroomsterkte door de LED worden samen met de bijbehorende onzekerheden weggeschreven in een CSV-bestand.</li> <li> De LED wordt uitgezet na de meting.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: open repository</li> <li> Pythondaq: controller bouwen</li> <li> Pythondaq: controller implementeren</li> <li> Pythondaq: controller afsplitsen</li> <li> Pythondaq: model en view splitsen</li> </ul> <p>Als je de vorige opdracht succesvol hebt afgerond maakt het niet meer uit wat de precieze commando's zijn die je naar de hardware moet sturen. Als je de Arduino in de opstelling vervangt voor een ander meetinstrument moet je de class aanpassen, maar kan alle code die met het experiment zelf te maken heeft hetzelfde blijven.</p> <p>Pythondaq: controller afsplitsen</p> opdrachtcodecheck <p>      In latere opdrachten ga je een command-line interface en een grafische user interface maken voor het experiment. Daarom is het handig om alvast overzicht te cre\u00ebren door de verschillende onderdelen van de MVC in aparte scripts te zetten en om ze handige namen te geven die duidelijk maken wat wat is.           Je hebt eerder de code voor de controller gekopieerd van <code>test_controller.py</code> naar <code>diode_experiment.py</code> en dat is dus eigenlijk niet zo handig. Je hernoemt <code>test_controller.py</code> naar <code>arduino_device.py</code>. Het bestand <code>arduino_device.py</code> bevat de functie <code>list_resources()</code> en de class <code>ArduinoVISADevice</code>. Deze functie en class importeer je in het bestand <code>diode_experiment.py</code> (in plaats van dat je de code kopieert). De functie <code>list_resources()</code> en de class <code>ArduinoVISADevice</code> kun je in het bestand <code>diode_experiment.py</code> dan weer verwijderen.      <code>ECPC</code>      \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>arduino_device.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>diode_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 </p> <p>Error</p> <p>Waarschijnlijk krijg je \u00e9\u00e9n of meerdere errors als je <code>diode_experiment.py</code> runt. Lees het bericht bij de error goed door. Kijk om welk bestand het gaat: <code>arduino_device.py</code> of <code>diode_experiment.py</code>? Wat is er volgens het error bericht niet goed? Misschien helpt het als je de (inmiddels onnodige) testcode verwijdert uit <code>arduino_device.py</code>. Als dat inderdaad helpt, wat was dan het probleem?</p> <p>Pseudo-code arduino_device.py<pre><code># def list_resources\n#   ...\n#\n# class ArduinoVISADevice\n#   ...\n</code></pre> diode_experiment.py<pre><code>from arduino_device import ArduinoVISADevice, list_resources\n\n# get list resources\n# connect to Arduino via class ArduinoVISADevice\n#\n# set output voltage from 0 to max\n#   set number of repeated measurements\n#       measure voltages\n#       calculate voltage LED\n#       calculate current LED\n#   calculate average voltage LED and uncertainty\n#   calculate average current LED and uncertainty\n#   print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#\n# turn LED off\n# create csv-file\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Alle directe communicatie met de Arduino, firmware-commando's en PyVISA-commando's staan in het bestand <code>arduino_device.py</code>, de controller.</li> <li> Runnen van <code>diode_experiment.py</code> zorgt ervoor dat een meting start.</li> <li> Er wordt een lijst geprint met beschikbare poorten.</li> <li> Er wordt een plot getoond van de gemiddelde spanning over en de gemiddelde stroomsterkte door de LED met de bijbehorende onzekerheden.</li> <li> De gemiddelde spanning over en de gemiddelde stroomsterkte door de LED worden samen met de bijbehorende onzekerheden weggeschreven in een CSV-bestand.</li> <li> De LED wordt uitgezet na de meting.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: open repository</li> <li> Pythondaq: controller bouwen</li> <li> Pythondaq: controller implementeren</li> <li> Pythondaq: controller afsplitsen</li> <li> Pythondaq: model en view splitsen</li> </ul> <code>if __name__ == '__main__'</code> opdrachtcodecheck <p>Later wil je de functie <code>list_resources()</code> netjes in het hele model-view-controller systeem vlechten zodat je als gebruiker de lijst kunt opvragen, maar voor nu wil je af en toe even zien aan welke poort de Arduino hangt. Wanneer je het script <code>arduino_device.py</code> runt wordt er een lijst geprint met poorten. Dit gebeurt niet wanneer het bestand <code>diode_experiment.py</code> wordt gerund. </p> <p>Statement onbekend</p> <p>Nog niet bekend met het statement <code>if __name__ == '__main__'</code>? Kijk dan voor meer informatie in de paragraaf modules.</p> <p>Pseudo-code arduino_device.py<pre><code># def list_resources\n#   ...\n#\n# class ArduinoVISADevice\n#   ...\n#\n# get list resources when arduino_device.py is the main script \n# doesnot get list resources when arduino_device.py is imported as a module in another script\n</code></pre> diode_experiment.py<pre><code>from arduino_device import ArduinoVISADevice\n\n# connect to Arduino via class ArduinoVISADevice\n#\n# set output voltage from 0 to max\n#   set number of repeated measurements\n#       measure voltages\n#       calculate voltage LED\n#       calculate current LED\n#   calculate average voltage LED and uncertainty\n#   calculate average current LED and uncertainty\n#   print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#\n# turn LED off\n# create csv-file\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Er wordt een lijst met beschikbare poorten geprint wanneer <code>arduino_device.py</code> wordt gerund.</li> <li> De lijst met beschikbare poorten wordt niet geprint wanneer <code>diode_experiment.py</code> wordt gerund.</li> </ul> <p>Nu je de controller die de Arduino aanstuurt, hebt gemaakt en afgesplitst, blijft er nog een stuk code over. Het stuk code waar de plot en het CSV-bestand gemaakt worden kun je beschouwen als een view en de rest van de code \u2014 waar de metingen worden uitgevoerd en de spanning $U$ en stroomsterkte $I$ worden berekend \u2014 is een model. Je gaat de code nog wat verder opsplitsen om dit duidelijk te maken \u00e9n de onderdelen van model en view onderbrengen in verschillende bestanden \u2014 dat is uiteindelijk beter voor het overzicht.</p> <p>Pythondaq: model en view splitsen</p> opdrachtcodecheck <p>      Maak een bestand <code>run_experiment.py</code> aan. Dit bestand fungeert als view. In de view staat de code voor het maken van de plot en het genereren van het CSV-bestand. Daarnaast kan de gebruiker in de view een aantal dingen aanpassen, zoals het bereik en het aantal herhaalmetingen. De view importeert wat het nodig heeft uit het model, <code>diode_experiment.py</code>. Het is de bedoeling dat in het model de code voor het uitvoeren van de metingen netjes in een class <code>DiodeExperiment</code> zit, dit betekent dat je <code>diode_experiment.py</code> zult moeten aanpassen. Het kan makkelijk zijn om <code>diode_experiment.py</code> te kopi\u00ebren naar <code>run_experiment.py</code> en dan in beide bestanden weg te halen wat daar niet hoort. Dat scheelt copy/pasten.      Bij deze opdracht ga je dingen aanpassen, maar de meeste code heb je al geschreven. Schrijf dus niet allerlei code opnieuw!      Om gegevens naar de Arduino te sturen maakt het model gebruik van de controller. De gegevens die het model terugkrijgt van de Arduino worden volgens de fysische relaties verwerkt tot de benodigde spanningen en stroomsterktes en doorgestuurd naar de view. De resultaten worden in een plot getoond en naar een CSV-bestand weggeschreven. De gebruiker test de door jou geschreven applicatie (view, model, controller) met de volgende handelingen:     <ul> <li> Het runnen van het bestand <code>run_experiment.py</code> geeft een lijst van aangesloten instrumenten.</li> <li> De gebruiker past in het bestand <code>run_experiment.py</code> de poortnaam aan naar een poort waarop een Arduino is aangesloten. De instance van de class <code>DiodeExperiment</code>, die uit het model wordt ge\u00efmporteerd, gebruikt deze poortnaam om de communicatie met de Arduino te openen. </li> <li> De gebruiker roept de method <code>scan()</code> aan van de class <code>DiodeExperiment</code>, waarna een meting wordt gestart. </li> <li> De gebruiker past het bereik van de meting aan door de start- en stopparameters, die aan de method <code>scan()</code> worden meegegeven, aan te passen. </li> <li> De gebruiker past het aantal herhaalmetingen aan, die ook aan de method <code>scan()</code> wordt meegegeven.      <code>ECPC</code>      \u251c\u2500\u2500  <code>pythondaq</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>arduino_device.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>diode_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>run_experiment.py</code>     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500 \u2022\u2022\u2022     \u2514\u2500\u2500 \u2022\u2022\u2022 <p>Pseudo-code arduino_device.py<pre><code># def list_resources\n#   ...\n#\n# class ArduinoVISADevice\n#   ...\n</code></pre> diode_experiment.py<pre><code>from arduino_device import ArduinoVISADevice, list_resources\n\n# class DiodeExperiment\n#   ...\n#   connect to Arduino via class ArduinoVISADevice\n#   ...\n#   def scan with start, stop and repeat\n#       set output voltage from start to stop\n#           set number of repeated measurements\n#               measure voltages\n#               calculate voltage LED\n#               calculate current LED\n#           calculate average voltage LED and uncertainty\n#           calculate average current LED and uncertainty\n#           print average voltage: average_voltage_LED +/- err_average_voltage_LED V  average current: average_current_LED +/- err_average_current_LED A\n#       turn LED off\n#       return average voltage LED, average current LED, error average voltage LED and error average current LED\n</code></pre> run_experiment.py<pre><code>from diode_experiment import DiodeExperiment, list_resources\n\n# get list resources\n# connect to Arduino via class DiodeExperiment\n#\n# get average voltage, average current, error average voltage and error average current from method scan(start, stop, repeat)\n#\n# create csv-file\n# plot average_current_LED vs average_voltage_LED\n</code></pre></p> <p>Checkpunten</p> <ul> <li> Alle directe communicatie met de Arduino, firmware-commando's en PyVISA-commando's staan in het bestand <code>arduino_device.py</code>, de controller.</li> <li> Het model, <code>diode_experiment.py</code>, communiceert met de controller.</li> <li> Het model bevat een class <code>DiodeExperiment</code>, deze class heeft onder andere een method <code>scan()</code>.</li> <li> De view, <code>run_experiment.py</code>, communiceert alleen met het model. </li> <li> Runnen van <code>run_experiment.py</code> zorgt ervoor dat een lijst met beschikbare poorten wordt gegeven en een meting wordt gestart.</li> <li> Er wordt een plot getoond van de gemiddelde spanning over en de gemiddelde stroomsterkte door de LED met de bijbehorende onzekerheden.</li> <li> De gemiddelde spanning over en de gemiddelde stroomsterkte door de LED worden samen met de bijbehorende onzekerheden weggeschreven in een CSV-bestand.</li> <li> De LED wordt uitgezet na de meting.</li> <li> De bestanden bevatten alleen code die echt noodzakelijk is en niet meer dan dat. Dit betekent dat allerlei testcode is verwijderd.</li> </ul> <p>Projecttraject</p> <ul> <li> Pythondaq: open repository</li> <li> Pythondaq: controller bouwen</li> <li> Pythondaq: controller implementeren</li> <li> Pythondaq: controller afsplitsen</li> <li> Pythondaq: model en view splitsen</li> </ul> <p>Doordat je de verschillende onderdelen van de MVC in aparte scripts hebt gezet, is het oorspronkelijke script dat je gebruikte voor je meting steeds leger geworden. Als het goed is gaat de view (bijna) alleen maar over het starten van een meting en het weergeven en bewaren van de meetgegevens. In dit script komen verder geen berekeningen voor, deze staan immers beschreven in het model. Ook vind je in de view niets over welke commando's de Arduino firmware begrijpt, want dat staat beschreven in de controller. De splitsing van de code in de MVC-structuur maakt het veel makkelijker om in de vervolghoofdstukken een gebruiksvriendelijke applicatie te ontwikkelen waarmee je snel en eenvoudig metingen kunt doen.</p> User input <p>De gebruiker moet in de view het script aanpassen om bijvoorbeeld een meting met een ander bereik te doen. Maak gebruik van <code>input()</code> om bij de gebruiker de start, stop en het aantal herhaalmetingen op te vragen.</p> Error! <p>Als de gebruiker in de <code>run_experiment.py</code> per ongeluk een negatieve startwaarde of een negatief aantal metingen invult, gaat het niet goed. Gebruik exceptions om dergelijke gevallen af te vangen en een duidelijke error af te geven. </p>"},{"location":"projects/","title":"Pythonprojecten met uv","text":"<p>In de vorige hoofdstukken heb je gewerkt met een eigen virtual environment zodat je jouw pythonomgeving mooi gescheiden kan houden van andere projecten waar je aan werkt. Dit is echt de oplossing voor alle problemen waarbij volledige Pythoninstallaties onbruikbaar kunnen worden \u2014 waarna je alles opnieuw moet installeren. Dit kan gebeuren als je \u2014 vanwege al je verschillende projecten \u2014 zoveel packages installeert dat die met elkaar in conflict komen.</p> <p>Voor ieder project nieuwe environments aanmaken heeft wel een nadeel: je moet alle packages die je nodig hebt opnieuw installeren. Welke waren dat ook alweer? Vast <code>numpy</code>, en <code>matplotlib</code>, en\u2026? Niet handig. Als je code gaat delen met elkaar krijg je regelmatig te maken met een <code>ImportError</code> of <code>ModuleNotFoundError</code> omdat je niet precies weet wat er nodig is, waarna je weer \u00e9\u00e9n of ander package moet installeren.</p> <p>Nu pythondaq netjes is uitgesplitst in een MVC-structuur en de wijzigingen met Git worden bijgehouden, ga je er een package van maken zodat je het ook met anderen kan delen. Daarin staan alle benodigdheden duidelijk omschreven zodat gebruikers daar verder niet over hoeven na te denken.</p> <p>Packages op PyPI (de standaardplek waar Python packages gepubliceerd worden) geven altijd hun dependencies op. Dat zijn de packages die verder nog nodig zijn om alles te laten werken. Installeer je <code>matplotlib</code>, dan krijg je er <code>six, python-dateutil, pyparsing, pillow, numpy, kiwisolver, cycler</code> automatisch bij. Maar alleen de namen van packages zijn niet genoeg. Welke versies van <code>numpy</code> werken met de huidige versie van <code>matplotlib</code>? Allemaal zaken die je \u2014 als je een package schrijft \u2014 zelf moet bijhouden. Het voordeel is dat jouw gebruikers alleen maar jouw pakket hoeven te installeren \u2014 de rest gaat vanzelf.</p> <p>En\u2026 hoe test je je package zodat je zeker weet dat hij het bij een ander ook doet? Heel vaak werkt het bij jou wel, maar vergeet je een bestand mee te sturen dat wel echt nodig is.<sup>1</sup> Of: bij jou werkt <code>import my_new_cool_app.gui</code> wel, maar bij een ander geeft hij een <code>ImportError</code> of <code>ModuleNotFoundError</code>. De bestanden zijn er wel, maar worden verkeerd ge\u00efmporteerd.</p> <p>Hoe krijg je eigenlijk je code bij iemand anders? Liefst als \u00e9\u00e9n bestand, of zelfs met <code>pip install my_new_cool_app</code>; dat zou wel mooi zijn.</p> <p>Ook daarvoor gebruiken we uv.</p> <p>Info</p> <p>Voorgaande jaren leerden we studenten om Poetry te gebruiken. Heel populair, maar uv is de afgelopen anderhalf jaar nog veel populairder geworden. En terecht.</p> <p>Er zijn meerdere tools ontwikkeld om dezelfde problemen op te lossen. uv is in korte tijd heel populair geworden. Het richt zich op het offici\u00eble ecosysteem: standaard Python packages, ofwel PyPI en <code>pip</code>; niet <code>conda</code> (zie meer hierover in paragraaf pip vs conda). Dit zorgt er voor dat iedereen m\u00e9t of z\u00f3nder Anaconda je package kan installeren. Omdat uv ook in staat is zelf verschillende versies van Python te installeren hebben we Anaconda niet meer nodig. De installer van Anaconda is bijna 1 Gb groot en bevat heel veel Python packages die je nooit gebruikt. De installer van uv is nog geen 20 Mb en kun je gebruiken om precies te installeren wat je nodig hebt.</p> <p>Werken in een terminal</p> <p>uv is een tool die je enkel en alleen in de terminal kunt gebruiken. Het heeft alleen een command-line interface (CLI). Ben je nog niet zo bekend met het navigeren in een terminal dan kun je als oefening de Terminal Adventure Game spelen.</p> <p>We gaan uv bedienen door commando's te geven in de terminal van Visual Studio Code. We laten de terminal weten welk programma wij willen gaan besturen, door <code>uv</code> in te typen. En daarachter wat we willen dat uv gaat doen. We kunnen bijvoorbeeld kijken welke commando's allemaal beschikbaar zijn met <code>uv help</code>. Dat geeft een vrij lange lijst die je terug kunt scrollen in de terminal, maar je kunt ook <code>uv help | more</code> intypen om de tekst per pagina weer te geven.<sup>2</sup></p> <pre><code>&gt; uv help | more \nAn extremely fast Python package manager.\n\nUsage: uv [OPTIONS] \n\nCommands:\n  run                        Run a command or script\n  init                       Create a new project\n  add                        Add dependencies to the project\n  remove                     Remove dependencies from the project\n  version                    Read or update the project's version\n  sync                       Update the project's environment\n  lock                       Update the project's lockfile\n  export                     Export the project's lockfile to an alternate format\n  tree                       Display the project's dependency tree\n  tool                       Run and install commands provided by Python packages\n  python                     Manage Python versions and installations\n  pip                        Manage Python packages with a pip-compatible interface\n  venv                       Create a virtual environment\n  build                      Build Python packages into source distributions and wheels\n  publish                    Upload distributions to an index\n  cache                      Manage uv's cache\n  self                       Manage the uv executable\n  generate-shell-completion  Generate shell completion\n  help                       Display documentation for a command\n\nCache options:\n  -n, --no-cache               Avoid reading from or writing to the cache, instead using a temporary directory for the\n                               duration of the operation [env: UV_NO_CACHE=]\n      --cache-dir   Path to the cache directory [env: UV_CACHE_DIR=]\n-- More  --\n\n\n\n<p>uv help</p>\n<p>Open een terminal en vraag informatie over uv op met het commando <code>uv</code>. Lees de tekst die uv aan je teruggeeft vluchtig door tot het eind; waar kan je meer informatie vinden?<sup>3</sup> We hebben het commando <code>uv pip</code> al eerder gebruikt (waarvoor ook alweer?). Vraag eens meer informatie over het commando <code>pip</code>. Hoe kun je een lijst krijgen van alle packages die ge\u00efnstalleerd staan in je virtual environment? Voer dat commando uit. Voer ook het commando uit om een 'dependency tree' te krijgen. Wat houdt dat in? Overleg met je buurmens zodat jullie het eens zijn over de antwoorden op deze vragen.</p>\n\n\n<p>Info</p>\n<p>Zoals je gezien hebt heeft <code>uv</code> dus heel veel verschillende commando's. uv is een Zwitsers zakmes: het bevat heel veel tools voor wie dat nodig heeft. Wij hebben lang niet alles nodig dus laat je daardoor niet uit het veld slaan. In de rest van dit hoofdstuk vertellen we precies wat je wel nodig hebt. Als je meer wilt weten kun je het beste de documentatie lezen.</p>"},{"location":"projects/#nieuw-uv-project","title":"Nieuw uv project","text":"<p>Info</p>\n<p>We gaan werken met modules en packages. Ben je daar nog niet zo bekend mee, zorg dan dat je paragraaf Modules en paragraaf packages gemaakt hebt.</p>\n\n<p>Stel je wilt een package schrijven met wat handige functies om veelgebruikte statistische berekeningen makkelijk uit te voeren. Je noemt het <code>easystat</code>. Het doel is eerst om het in al je eigen analyses makkelijk te kunnen gebruiken (<code>import easystat</code>) maar je wilt het ook op GitHub zetten en wie weet vinden anderen het ook handig! Je wilt het dus ook netjes doen. En niet later van anderen horen: leuk, maar bij mij werkt het niet!</p>\n\n<p>Easystat uv project aanmaken</p>\nopdrachtcodecheck\n\n\n<ol>\n<li>Open Github Desktop en ga naar het dropdownmenu File. Kies hier voor <code>New repository ...</code>. Geef de repository de naam <code>easystat</code> en zet de repository in de map <code>ECPC</code>. Vink <code>Initialize this repository with a README</code> aan en kies bij <code>Git ignore</code> voor Python.</li>\n<li>Open de repository  <code>easystat</code> in Visual Studio Code.</li>\n<li>Open een Terminal in je Visual Studio Code-omgeving (Menu &gt; Terminal &gt; New Terminal). Maak het uv project aan met:\nTerminal<pre><code>uv init --package\n</code></pre></li>\n<li>\n<p>Je bekijkt de nieuw gemaakte mappenstructuur en ziet dat het overeenkomt met de mappenstructuur zoals hieronder weergegeven:</p>\n<p> <code>ECPC</code>\n\u251c\u2500\u2500  <code>oefenopdrachten</code>\n\u251c\u2500\u2500  <code>pythondaq</code>\n\u251c\u2500\u2500  <code>easystat</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>src</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>easystat</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>__init__.py</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>.gitattributes</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>.gitignore</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>.python-version</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>pyproject.toml</code>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>README.md</code>\n\u2514\u2500\u2500  \u2022\u2022\u2022  </p>\n</li>\n</ol>\n\n<p>src-layout</p>\n<p>Door het project in een source layout (src-layout) te bouwen (<code>easystat</code> zit in een mapje <code>src</code>) staat al je Pythoncode netjes bij elkaar weggestopt. Dit maakt het makkelijker om te testen of het installeren goed werkt zodat je zeker weet dat andere mensen met jouw code aan de slag kunnen.</p>\n\n\n\n<p>Testcode\n<pre><code>(ECPC) &gt; uv init --package \nInitialized project `easystat`\n</code></pre></p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> De projectmap <code>easystat</code> staat in de map <code>ECPC</code>.</li>\n<li> In de projectmap <code>easystat</code> staat een map <code>src</code>.</li>\n<li> In de map <code>src</code> staat een package map <code>easystat</code></li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Easystat uv project aanmaken</li>\n<li> Easystat virtual environment aanmaken</li>\n<li> Easystat <code>shortcuts.py</code>, <code>measurements.py</code> en <code>try_measurements.py</code> aanmaken</li>\n<li> Easystat <code>shortcuts.py</code> testen</li>\n<li> Easystat dependencies toevoegen</li>\n<li> Easystat package imports fixen</li>\n</ul>\n\n\n\n\n<p>Laten we \u00e9\u00e9n voor \u00e9\u00e9n kijken welke mappen en bestanden uv heeft aangemaakt. We hadden al een <code>README.md</code> in de projectmap staan. Hierin komt een algemene beschrijving van ons project.<sup>4</sup></p>\n<p>Dan komt de <code>src</code>-map. Daarin komt ons nieuwe package <code>easystat</code><sup>5</sup> te staan. Er is alvast voor ons een <code>__init__.py</code> aangemaakt. Handig! De bestanden <code>.gitattributes</code> en <code>.gitignore</code> bewaren wat instellingen voor git, en <code>.python-version</code> bewaart het versienummer van Python dat uv gebruikt. Vul je daar 3.12 in? Dan installeert uv Python 3.12 in je virtual environment.</p>\n<p>En als laatste\u2026 een <code>pyproject.toml</code><sup>6</sup> waarin alle informatie over je project wordt bijgehouden. Ook staat er in dit bestand informatie voor de verschillende tools die je kunt gebruiken. De inhoud van het bestand ziet er ongeveer zo uit:\n<pre><code>[project]\nname = \"easystat\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"David Fokkema\", email = \"davidfokkema@icloud.com\" }\n]\nrequires-python = \"&gt;=3.13\"\ndependencies = []\n\n[project.scripts]\neasystat = \"easystat:main\"\n\n[build-system]\nrequires = [\"uv_build&gt;=0.8.4,&lt;0.9.0\"]\nbuild-backend = \"uv_build\"\n</code></pre></p>\n<p>Het bestand is in het TOML-formaat.<sup>8</sup> Tussen de vierkante haken staan de koppen van de verschillende secties in dit configuratiebestand. In de eerste sectie staat informatie over ons project. Je kunt daar bijvoorbeeld een beschrijving toevoegen of het versienummer aanpassen. Ook bevat die sectie de dependencies. Dit zijn alle Pythonpackages die ons project nodig heeft. Op dit moment is dat nog niets. Ook het versienummer van Python is belangrijk. Hier is dat groter of gelijk aan 3.13. Dit kan belangrijk zijn. Gebruikers met een iets oudere versie van Python \u2014 bijvoorbeeld versie 3.11 \u2014 kunnen nu het package niet installeren. Als je niet per se de nieuwste snufjes van Python 3.13 nodig hebt kun je aangeven dat een iets oudere versie van Python ook prima is. Op moment van schrijven \u2014 zomer 2025 \u2014 is Python 3.13 de nieuwste versie. Het is dus prima om minimaal 3.12 te vragen \u2014 die versie is inmiddels een jaar oud. Het is handig om als je hier invult 'minstens 3.12', dat je dan in <code>.python-version</code> ook 3.12 invult omdat je anders niet zeker weet dat je code ook echt werkt met 3.12.</p>\n<p>De sectie <code>[project.scripts]</code> zorgt ervoor dat we ons script kunnen aanroepen door <code>easystat</code> in de terminal in te typen en de sectie <code>[build-system]</code> zorgt ervoor dat we een package kunnen maken en uploaden naar de Python Package Index (PyPI). Dat is nu nog niet belangrijk.</p>\n\n<p>Synchroniseren van virtual environments</p>\n<ol>\n<li>Hoewel we hierboven beweerden dat je <code>easystat</code> kunt intypen in de terminal en dat er dan een scriptje draait, werkt dat (nog) niet. Probeer maar eens! Het werkt ook niet als je een nieuwe terminal opent. En... er staat niets tussen haakjes aan het begin van de opdrachtprompt. Blijkbaar is er nog geen virtual environment actief.</li>\n<li>Open <code>src/eaystat/__init__.py</code>. Rechtsonderin zie je inderdaad <code>Select Interpreter</code>. Als je daarop klikt zie je alleen niet <code>Python 3.x.x (easystat)</code> in het rijtje staan... Druk op Esc om het menu te verlaten.</li>\n<li>In een terminal in VS Code, type in:\n<pre><code>&gt; uv sync \nUsing CPython 3.13.5\nCreating virtual environment at: .venv\nResolved 1 package in 5ms\nInstalled 1 package in 47ms\n\u00a0+ easystat==0.1.0 (from file:///C:/Users/David/Documents/ECPC/easystat)</code></pre>\nWat dit gedaan heeft is het automatisch aanmaken van het virtual environment op basis van je projectinstellingen. Dus de Pythonversie die in <code>.python-version</code> staat en eventuele dependencies die gedefinieerd zijn in je <code>pyproject.toml</code>.</li>\n<li>Kies het nieuwe virtual environment.</li>\n<li>Open een nieuwe terminal en type <code>easystat</code>. Als het goed is werkt het nu w\u00e9l!</li>\n</ol>\n\n\n<p>Easystat uv project committen</p>\n<p>Commit in GitHub Desktop de wijzigingen die <code>uv init</code> heeft gedaan.</p>"},{"location":"projects/#maken-van-de-easystat-package","title":"Maken van de easystat-package","text":"<p>We starten met ons package. We gaan een aantal <code>ModuleNotFoundError</code>s tegenkomen, maar dat lossen we ook weer op.  Stel, we berekenen vaak de standaarddeviatie van het gemiddelde en maken daarvoor een handige shortcut in <code>shortcuts.py</code>. Nu willen we deze shortcut ook in een ander script <code>measurements.py</code> gebruiken, die op basis van een aantal metingen het gemiddelde m\u00e9t een onzekerheid geeft. Dit kunnen we doen door de module te importeren in het nieuwe script zodat we de functie <code>stdev_of_mean</code> daar ook kunnen gebruiken. We maken uiteindelijk een script <code>try_measurements.py</code> om dit allemaal te testen, en die zetten we expres niet in het package, maar in een nieuwe map <code>tests</code>. Het testscript hoort immers niet bij de code van het <code>easystat</code> package.</p>\n\n<p>Easystat shortcuts.py en try_shortcuts.py aanmaken</p>\n<p>Maak zoals hieronder aangegeven de bestanden <code>shortcuts.py</code>, <code>measurements.py</code> en <code>try_measurements.py</code> aan, waarbij je let op in welke map de bestanden moeten staan (je moet nog een map zelf aanmaken):\n\n    \n    shortcuts.py<pre><code>import numpy as np \n\n\ndef stdev_of_mean(values):\n    \"\"\"Calculate the standard deviation of the mean\"\"\"\n    return np.std(values) / np.sqrt(len(values))    \n</code></pre>\n    measurements.py<pre><code>import numpy as np\nfrom shortcuts import stdev_of_mean\n\n\ndef result_with_uncertainty(values):\n    \"\"\"Return result with uncertainty from list of measurements.\"\"\"\n    return np.mean(values), stdev_of_mean(values)\n</code></pre>\n    try_measurements.py<pre><code>from measurements import result_with_uncertainty\n\nmeasurements = [1, 2, 2, 2, 3]\nresult, uncertainty = result_with_uncertainty(measurements)\n\nprint(f\"{measurements=}\")\nprint(f\"Result of measurements is: {result:.2f} +- {uncertainty:.2f}.\")\n</code></pre>\n    \n    \n     <code>easystat</code>\n    \u251c\u2500\u2500  <code>src</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>easystat</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>measurements.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>shortcuts.py</code>\n    \u251c\u2500\u2500  <code>tests</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>try_measurements.py</code>\n    \u251c\u2500\u2500  <code>pyproject.toml</code>\n    \u2514\u2500\u2500  <code>readme.md</code>\n    \n</p>\n\n<p><code>Import numpy could not be resolved</code></p>\n<p>Misschien is het je al opgevallen dat VS Code een oranje kringeltje onder <code>numpy</code> zet in de eerste regels van twee scripts, en ook onder <code>shortcuts</code> en <code>measurements</code>. Als je daar je muiscursor op plaatst krijg je een popup met de melding <code>Import numpy could not be resolved</code>. Daar moeten we misschien wat mee en dat gaan we straks ook doen.</p>\n\n\n<p>In de eerste regel van <code>test_measurements.py</code> importeren we de functie uit het nieuwe package om uit te proberen. In de eerste <code>print</code>-regel gebruiken we een handige functie van f-strings.<sup>7</sup></p>\n\n<p>Easystat shortcuts.py testen</p>\nopdrachtcodecheck\n\n\n<p>Je bent heel benieuwd of je package al werkt. Je runt als eerste het bestand <code>shortcuts.py</code> en krijgt een foutmelding...</p>\n\n\n<p>Testcode\n shortcuts.py\n<pre><code>import numpy as np\n\n\ndef stdev_of_mean(values):\n    \"\"\"Calculate the standard deviation of the mean\"\"\"\n    return np.std(values) / np.sqrt(len(values))\n</code></pre>\n<pre>\n<code>(easystat) &gt; python .\\src\\easystat\\shortcuts.py\nTraceback (most recent call last):\nFile \"C:\\Users\\David\\Documents\\ECPC\\easystat\\src\\easystat\\shortcuts.py\", line 1, in \n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Je hebt de juiste virtual environment geactiveerd.</li>\n<li> Je runt het bestand <code>shortcuts.py</code>.</li>\n<li> Je krijgt een foutmelding <code>ModuleNotFoundError: No module named 'NumPy'</code></li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Easystat uv project aanmaken</li>\n<li> Easystat virtual environment aanmaken</li>\n<li> Easystat <code>shortcuts.py</code>, <code>measurements.py</code> en <code>try_measurements.py</code> aanmaken</li>\n<li> Easystat <code>shortcuts.py</code> testen</li>\n<li> Easystat dependencies toevoegen</li>\n<li> Easystat package imports fixen</li>\n</ul>\n\n\n\n\n<p>De beloofde <code>ModuleNotFoundError</code>! Ons package heeft NumPy nodig en dat hebben we nog niet ge\u00efnstalleerd. Dat kunnen we handmatig doen maar dan hebben andere gebruikers een probleem. Veel beter is het om netjes aan te geven dat ons package NumPy nodig heeft \u2014 als dependency.</p>"},{"location":"projects/#dependencies-toevoegen","title":"Dependencies toevoegen","text":"<p>Om een dependency aan te geven vertellen we uv dat hij deze moet toevoegen met:</p>\n<pre><code>(easystat) &gt; uv add numpy \nResolved 2 packages in 453ms\n      Built easystat @ file:///C:/Users/David/Documents/ECPC/easystat\nPrepared 1 package in 82ms\nUninstalled 1 package in 9ms\nInstalled 2 packages in 798ms\n ~ easystat==0.1.0 (from file:///C:/Users/David/Documents/ECPC/easystat)\n + numpy==2.3.2\n</code></pre>\n\n\n<p>Easystat dependencies toevoegen</p>\nopdrachtcheck\n\n\n<p>Je voegt <code>numpy</code> als dependency toe aan het project <code>easystat</code> met het commando <code>uv add numpy</code>. Je kijkt in de <code>pyproject.toml</code> en warempel daar staat <code>numpy</code> nu bij de dependencies! Je vraagt je af of <code>numpy</code> nu ook in het virtual environment <code>easystat</code> is ge\u00efnstalleerd en controleert dit met <code>uv pip list</code> en waarachtig <code>numpy</code> staat in de lijst . Weer ga je <code>shortcuts.py</code> draaien en ditmaal krijg geen foutmelding! Commit de wijzigingen.</p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Je hebt de juiste virtual environment geacitveerd.</li>\n<li> Je hebt <code>numpy</code> als dependency toegevoegd.</li>\n<li> Je krijgt geen foutmelding als je het bestand <code>shortcuts.py</code> runt.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Easystat uv project aanmaken</li>\n<li> Easystat virtual environment aanmaken</li>\n<li> Easystat <code>shortcuts.py</code>, <code>measurements.py</code> en <code>try_measurements.py</code> aanmaken</li>\n<li> Easystat <code>shortcuts.py</code> testen</li>\n<li> Easystat dependencies toevoegen</li>\n<li> Easystat package imports fixen</li>\n</ul>\n\n\n\n\n<p>Fijn! Het verwijderen van dependency <code>PACKAGE</code> gaat met <code>uv remove PACKAGE</code>. uv heeft NumPy nu toegevoegd aan de environment <code>easystat</code>. Gewone package managers als Pip en Conda zullen geen packages toevoegen aan je uv project als je <code>pip/conda install package</code> aanroept. Gebruik daarom altijd <code>uv add package</code> als je met uv aan een package werkt. Sterker nog, als je met Pip handmatig packages extra installeert zal <code>uv sync</code> deze packages als overbodig herkennen en ze prompt weer verwijderen.</p>\n\n<p>Info</p>\n<p>Als we de code in ons package aanpassen dan hoeven we het environment niet opnieuw te synchroniseren met <code>uv sync</code>, maar als we met de hand iets wijzigen in de <code>pyproject.toml</code> dan moet dat wel. Als je een <code>ImportError</code> of <code>ModuleNotFoundError</code> krijgt voor je eigen package \u2014 bijvoorbeeld als je nieuwe mappen of bestanden hebt aangemaakt \u2014 probeer dan eerst voor de zekerheid <code>uv sync</code>.</p>\n\n\nuv.lock"},{"location":"projects/#uvlock","title":"uv.lock","text":"<p>Na het toevoegen van NumPy is er ook een grote wijziging in het bestand <code>uv.lock</code> bijgekomen. Hierin staan de exacte versies van alle ge\u00efnstalleerde packages. Vaak wordt dit bestand gecommit zodat collega-ontwikkelaars exact dezelfde versies installeren zodra ze <code>uv sync</code> aanroepen. Ook als er nieuwere versies van NumPy bijkomen blijven alle ontwikkelaars precies dezelfde NumPy-versie gebruiken totdat <code>uv.lock</code> ge\u00fcpdatet wordt. Om dat te proberen maken we even een schone virtual environment:</p>\n\n<p>Schone environment</p>\n<ol>\n<li>Maak een schone virtual environment met <code>uv venv</code></li>\n<li>Kies voor ja als uv een waarschuwing geeft dat deze environment al bestaat en vraagt of je het bestaande environment wilt verwijderen.</li>\n<li>Draai <code>shortcuts.py</code> en bekijk de foutmelding.</li>\n</ol>\n\n<p>We krijgen meteen foutmeldingen. Immers, het virtual environment is nog leeg en we hebben geen dependencies ge\u00efnstalleerd.</p>\n\n<p>uv.lock</p>\n<ol>\n<li>Installeer de dependencies in \u00e9\u00e9n keer met <code>uv sync</code>.</li>\n<li>Waarvoor gebruikt uv de lock file (<code>uv.lock)</code>?</li>\n<li>Draai <code>shortcuts.py</code> en bekijk de uitkomst.</li>\n<li>Als je nieuwere versies wilt gebruiken die passen bij wat er in de <code>pyproject.toml</code> staat, dan kun je de lockfile updaten met <code>uv lock --upgrade</code>. Als er nieuwere versies beschikbaar zijn van dependencies dan worden die ge\u00efnstalleerd en verwerkt in de lockfile. Je college-ontwikkelaars installeren die nu ook automatisch zodra ze <code>uv sync</code> gebruiken.</li>\n</ol>"},{"location":"projects/#absolute-imports","title":"Absolute imports","text":"<p>We hebben een uv project, dependencies toegevoegd maar nog niet alle code getest. Dat gaan we nu doen!</p>\n\n\n<p>Easystat package testen</p>\nopdrachtcode\n\n\n<p>Je probeert nog een keer <code>shortcuts.py</code> te runnen en ziet dat dat gewoon werkt. Daarna probeer je <code>measurements.py</code>. Werkt ook, maar wel gek dat er golfjes onder <code>from measurements import result_with_uncertainty</code> staan, hij doet het toch gewoon? Je kijkt even welke waarschuwing daarbij gegeven wordt door je muiscursor op de golfjes te schuiven. Daarna probeer je <code>try_measurements.py</code>. Hier gaan dingen mis.</p>\n\n\n<p>Testcode\n<pre><code>(easystat) &gt; python tests/try_measurements.py \nTraceback (most recent call last):\nFile \"c:\\Users\\David\\Documents\\ECPC\\easystat\\tests\\try_measurements.py\", line 1, in \n    from measurements import result_with_uncertainty\nModuleNotFoundError: No module named 'measurements'\n\n\n\n\n\n<p>We willen dus de module <code>measurements</code> importeren, maar Python kan hem niet vinden. Dat is ook wel een klein beetje logisch, want <code>try_measurements.py</code> staat in de map <code>tests</code> maar <code>measurements.py</code> staat in de map <code>src/easystat</code>. Dus we moeten Python vertellen w\u00e1\u00e1r hij die module kan vinden, namelijk in ons nieuwe package <code>easystat</code>. Doordat we een package gemaakt hebben hoeven we dus niet precies te vertellen in welke map alles te vinden is, maar hoeven we alleen de naam van het package te gebruiken. Dus niet <code>map.op.computer.easystat.src.easystat</code> maar gewoon <code>easystat</code>. Wel zo makkelijk.</p>\n\n<p>Import aanpassen: easystat package gebruiken</p>\nopdrachtcode\n\n\n<p>Je past <code>from measurements ...</code> aan naar <code>from easystat.measurements ...</code>. Je test de code opnieuw. Verdorie, weer een error. Overleg met elkaar wat deze error betekent. Waarom kregen wie error niet toen we <code>measurements.py</code> testten?</p>\n\n\n<p>Testcode\n<pre><code>(easystat) &gt; python tests/try_measurements.py \nTraceback (most recent call last):\nFile \"c:\\Users\\David\\Documents\\ECPC\\easystat\\tests\\try_measurements.py\", line 1, in \n    from easystat.measurements import result_with_uncertainty\nFile \"C:\\Users\\David\\Documents\\ECPC\\easystat\\src\\easystat\\measurements.py\", line 2, in \n    from shortcuts import stdev_of_mean\nModuleNotFoundError: No module named 'shortcuts'\n\n\n\n\n\n<p>Het probleem is dat wanneer je met Python een script runt en je importeert iets, dat Python eerst in de map kijkt waar het script staat (hier <code>tests</code>) en daarna zoekt in de lijst met ge\u00efnstalleerde packages. De module <code>shortcuts</code> staat niet in <code>tests</code>. Toen we <code>measurements.py</code> draaiden kon hij die w\u00e9l vinden want <code>measurements.py</code> en <code>shortcuts.py</code> staan in dezelfde map. Dus afhankelijk van welk script we draaien kan hij de modules soms wel vinden, soms niet. Dat is natuurlijk niet zo handig. De oplossing: absolute imports: geef bij alle imports altijd de naam van je package op.</p>\n\n<p>Import aanpassen: absolute imports</p>\nopdrachtcodecheck\n\n\n<p>Je past in het bestand <code>measurements.py</code> de regel <code>from shortcuts ...</code> aan door de naam van het package toe te voegen en ziet dat de oranje kriebeltjes ook verdwijnen. Je test de code in <code>try_measurements.py</code> opnieuw. Gelukt! </p>\n\n\n<p>Testcode\n<pre><code>(easystat) &gt; python tests/try_measurements.py \nmeasurements=[1, 2, 2, 2, 3]\nResult of measurements is: 2.00 +- 0.28.\n</code></pre></p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Je hebt de import in <code>try_measurements.py</code> aangepast.</li>\n<li> Je hebt de import in <code>measurements.py</code> aangepast.</li>\n<li> Je krijgt geen foutmelding als je het bestand <code>try_measurements.py</code> runt.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Easystat uv project aanmaken</li>\n<li> Easystat virtual environment aanmaken</li>\n<li> Easystat <code>shortcuts.py</code>, <code>measurements.py</code> en <code>try_measurements.py</code> aanmaken</li>\n<li> Easystat <code>shortcuts.py</code> testen</li>\n<li> Easystat dependencies toevoegen</li>\n<li> Easystat package imports fixen</li>\n</ul>\n\n\n\n\n\nWheels"},{"location":"projects/#wheels","title":"Wheels","text":"<p>Wanneer we klaar zijn om ons package te delen met andere gebruikers gebruiken we het commando <code>build</code> om wheels te bouwen.</p>\n\n<p>Bouw een wheel</p>\n<ol>\n<li>Bouw het wheel van easystat met <code>uv build</code>.</li>\n<li>Bekijk de namen van de bestanden in de nieuwe map <code>easystat/dist</code>, welke extensie hebben ze?</li>\n</ol>\n\n<p><pre><code>(easystat) &gt; uv build \nBuilding source distribution (uv build backend)...\nBuilding wheel from source distribution (uv build backend)...\nSuccessfully built dist\\easystat-0.1.0.tar.gz\nSuccessfully built dist\\easystat-0.1.0-py3-none-any.whl\n</code></pre>\nEen <code>.tar.gz</code>-bestand is een soort zipbestand met daarin de broncode van ons pakket (een source distribution). De tests worden daar niet in meegenomen. Een wheel is een soort bestand dat direct ge\u00efnstalleerd kan worden met <code>pip</code>. Zogenaamde pure-python packages bevatten alleen Pythoncode \u2014 en geen C-code die gecompileerd moet worden voor verschillende besturingssystemen of hardwareplatforms. Je herkent ze aan <code>none-any</code> in de bestandsnaam. None voor niet-OS-specifiek en any voor draait op elk hardwareplatform. We kunnen dit bestand als download neerzetten op een website of aan anderen mailen. Zij kunnen het dan installeren met <code>pip install</code>.</p>\n\n<p>Test wheel</p>\n<p>Laten we het wheel uitproberen. We gaan straks een nieuw virtual environment aanmaken, installeren het wheel en proberen het testscript te runnen \u2014 \u00e9\u00e9n keer v\u00f3\u00f3r het installeren van het wheel en \u00e9\u00e9n keer n\u00e1 het installeren, als volgt:</p>\n<ol>\n<li>Maak een nieuw, leeg, virtual environment.</li>\n<li>Draai <code>tests/try_measurements.py</code> en bekijk de foutmelding.</li>\n<li>Installeer het wheel met <code>uv pip install .\\dist\\easystat-0.1.0-py3-none-any.whl</code>.</li>\n<li>Draai <code>tests/try_measurements.py</code> en bekijk de uitkomst.</li>\n</ol>\n\n<p>Het werkt! Je ziet dat <code>pip install</code> niet alleen ons package <code>easystat</code> installeert, maar ook de dependency <code>numpy</code>. Dat is precies wat we willen.</p>\n<p>Het is belangrijk om de wheels niet in je GitHub repository te committen. Je repository is voor broncode, waarmee wheels gebouwd kunnen worden. Als je de stappen voor het aanmaken van de repository netjes gevolgd hebt dan heb je een <code>.gitignore</code> toegevoegd met Python-specifieke bestandsnamen en directories die genegeerd worden door Git en GitHub.</p>"},{"location":"projects/#uv-gebruiken-voor-een-bestaand-project-pythondaq","title":"uv gebruiken voor een bestaand project: pythondaq","text":"<p>Natuurlijk willen we uv ook gaan gebruiken bij <code>pythondaq</code>. We maken nu alleen geen nieuw project, maar gaan uv toevoegen aan een bestaand project. Daarvoor moeten we twee dingen doen. Als eerste gaan we uv initialiseren in de <code>pythondaq</code> repository en dan moeten we de code in de <code>src</code>-structuur plaatsen.</p>\n\n<p>Pythondaq: uv</p>\nopdrachtcheck\n\n\n<ol>\n<li>Je project <code>pythondaq</code> is zo tof aan het worden dat je het met uv gaat beheren zodat jij en anderen het gemakkelijk kunnen installeren en gebruiken. Als eerste open je de repository in GitHub Desktop en Visual Studio Code en open je een nieuwe terminal. Je test voor de zekerheid <code>run_experiment.py</code> nog even uit zodat je zeker weet dat alles nu nog werkt. Vervolgens maak je een uv project . Dan kies je op twee plaatsen dat je Python 3.12 wilt gebruiken. Dan synchroniseer je je virtual environment en commit je je wijzigingen.</li>\n<li>Test <code>run_experiment.py</code> en voeg alle benodigde dependencies toe  totdat alles werkt en je opnieuw het lampje ziet gaan branden en de resultaten van je experiment krijgt. Commit je wijzigingen.</li>\n</ol>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Je hebt uv ge\u00efnitialiseerd in de Pythondaq projectmap.</li>\n<li> Na het initialiseren van uv is er een <code>pyproject.toml</code> en een <code>.python-version</code> in de projectmap aangemaakt.</li>\n<li> Wanneer met <code>uv sync</code> een nieuwe virtual environment met Python 3.12 wordt aangemaakt werkt <code>run_experiment.py</code> daarna in die nieuwe omgeving naar behoren. </li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Pythondaq: docstrings</li>\n<li> Pythondaq: uv</li>\n<li> Pythondaq: src-layout</li>\n<li> Pythondaq: test imports</li>\n<li> Pythondaq: applicatie</li>\n</ul>\n\n\n\n\n\n<p>Pythondaq: src-layout</p>\nopdrachtcheck\n\n\n<p>\n    \n    Nu de code in principe werkt, gaan we die in een src-layout zetten zoals hiernaast. Je test <code>run_experiment.py</code> en die moet werken.\n    \n    \n    <code>pythondaq</code>\n    \u251c\u2500\u2500<code>src</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u2500\u2500<code>pythondaq</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>__init__.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>arduino_device.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>diode_experiment.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u2500\u2500<code>run_experiment.py</code>\n    \u251c\u2500\u2500<code>.gitattributes</code>\n    \u251c\u2500\u2500<code>.gitignore</code>\n    \u251c\u2500\u2500<code>.python-version</code>\n    \u251c\u2500\u2500<code>pyproject.toml</code>\n    \u251c\u2500\u2500<code>README.md</code>\n    \u2514\u2500\u2500<code>uv.lock</code>\n    \n</p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Je 'oude' code staat nu allemaan in <code>src/pythondaq</code>.</li>\n<li> <code>run_experiment.py</code> draait zonder problemen.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Pythondaq: docstrings</li>\n<li> Pythondaq: uv</li>\n<li> Pythondaq: src-layout</li>\n<li> Pythondaq: test imports</li>\n<li> Pythondaq: applicatie</li>\n</ul>\n\n\n\n\n\nModel, view, controller packages\n<p>In grotere projecten is het gebruikelijk om model, view, controller niet alleen uit te splitsen in verschillende scripts, maar ook in aparte packages te zetten.</p>\n<ol>\n<li>Maak 3 extra packages in de <code>pythondaq</code> package. <code>models</code>, <code>views</code> en <code>controllers</code>.</li>\n<li>Zet de modules in de juiste packages.</li>\n<li>Test je code zodat alle imports weer werken.</li>\n</ol>"},{"location":"projects/#van-script-naar-applicatie","title":"Van script naar applicatie","text":"<p>Om onze python code te testen heb je tot nu toe waarschijnlijk op de <code>run</code>-knop in Visual Studio Code gedrukt. Of je hebt in de terminal aan python gevraagd om het <code>script.py</code> te runnen:\nTerminal<pre><code>python script.py\n</code></pre>\nJe moet dan wel in Visual Studio Code de juiste map geopend hebben zodat Python het bestand kan vinden. En als je de <code>run</code>-knop gebruikt moet wel het bestandje open staan dat je wilt runnen. Kortom, best een beetje gedoe. Maar als we programma's zoals uv, Conda of Python willen gebruiken hoeven we helemaal niet het juiste bestandje op te zoeken en te runnen. We hoeven alleen maar een commando in de terminal te geven \u2014 bijvoorbeeld <code>python</code> of <code>conda</code> \u2014 en de computer start automatisch het juiste programma op.</p>\n<p>Dat willen wij ook voor onze programma's! En omdat we uv gebruiken kunnen we dat heel eenvoudig doen. We gaan even in een andere test-repository een commando toevoegen om de module uit te voeren waarvan je de code in paragraaf Modules kunt vinden. De twee bestanden <code>square.py</code> en <code>count_count.py</code> hebben we voor jullie netjes in een package geplaats in de repository <code>AnneliesVlaar/just_count</code> met de volgende structuur:</p>\n<pre><code>just_count/\n    src/\n        just_count/\n            __init__.py\n            square.py\n            count_count.py\n    .python-version\n    pyproject.toml\n    README.md\n    uv.lock\n</code></pre>\n<p>De bestanden <code>square.py</code> en <code>count_count.py</code> zien er hetzelfde uit als in paragraaf Modules:</p>\nsquare.pycount_count.py\n\n\n<pre><code>def square(x):\n    return x**2\n\n\nif __name__ == \"__main__\":\n    print(f\"The square of 4 is {square(4)}\")\n</code></pre>\n\n\n<pre><code>import square\n\nprint(f\"The square of 5 is {square.square(5)}\")\n</code></pre>\n\n\n\n<p>We kunnen uv niet vragen om een script te runnen, maar wel om een functie in een module uit te voeren. Een nieuw uv project krijgt automatisch al een voorbeeldscript. Daar gaan we even naar kijken en daarna passen we het aan voor eigen gebruik.</p>\n\n<p>Voorbeeldscript</p>\nopdrachtcode\n\n\n<p>Je cloned de repository just_count in GitHub desktop en opent het daarna vanuit GitHub Desktop in Visual Studio Code. Je ziet een <code>pyproject.toml</code> en een <code>uv.lock</code> in de repository staan, dus je maakt meteen een virtual environment aan . Je opent een terminal en voert de opdracht <code>just-count</code> uit. De code hiervoor staat in <code>src/just_count/__init__.py</code>. Dit is overigens niet de beste plek, maar werkt prima als eenvoudig voorbeeld. Je bekijkt de code en ziet dat de bewuste code in een functie <code>main()</code> staat.</p>\n\n\n<p>Testcode\n __init__.py\n<pre><code>def main() -&gt; None:\n    print(\"Hello from just-count!\")\n</code></pre>\n<pre>\n<code>(just_count) &gt; just-count\nHello from just-count!\n</code></pre>        </p>\n\n\n\n\n<p>Als wij willen dat onze eigen code draait als we <code>just-count</code> intypen, dan moeten we zorgen dat onze code ook in een functie gezet wordt.</p>\n\n<p>Main functie toevoegen</p>\nopdrachtcodecheck\n\n\n<p>Je opent het hoofdbestand <code>count_count.py</code> en zet de body van de module in een functie <code>main()</code>. Daarna pas je het bestand aan zodat de functie nog steeds wordt uitgevoerd wanneer je het bestand <code>count_count.py</code> runt. </p>\n\n\n<p>Testcode\n count_count.py\n<pre><code>import square\n\ndef main():\n    print(f\"The square of 5 is {square.square(5)}\")\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<pre>\n<code>(just_count) &gt; python .\\src\\just_count\\count_count.py\nThe square of 5 is 25\n</code></pre></p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Er is een functie <code>main()</code> in het bestand <code>count_count.py</code></li>\n<li> Het runnen van het bestand <code>count_count.py</code> geeft de output <code>The square of 5 is 25</code></li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> main functie toevoegen </li>\n<li> commando toevoegen</li>\n<li> commando testen</li>\n</ul>\n\n\n\n\n<p>In <code>pyproject.toml</code> kunnen we nu het commando toe gaan voegen. In de <code>scripts</code>-sectie kunnen we aangeven met welk commando een functie uit een module wordt uitgevoerd. In <code>pyproject.toml</code> staat al zo'n kopje:\n<pre><code>[project.scripts]\njust-count = \"just_count:main\"\n</code></pre>\nDe vorm van die laatste regel is als volgt:\n<pre><code>naam_commando = \"package.module:naam_functie\"\n</code></pre>\nHier is <code>naam_commando</code> het commando dat je in moet typen in de terminal, <code>package</code> is de naam van het Python package waar de code staat, <code>module</code> is de naam van de module waar de code staat, en <code>naam_functie</code> is de naam van de functie waarin de code staat. Als je <code>module</code> weglaat, dan kijkt uv in <code>__init__.py</code>.</p>\n<p>Om de wijzigingen aan <code>pyproject.toml</code> door te voeren moet je je virtual environment wel opnieuw synchroniseren. uv installeert dan jouw package ook opnieuw.</p>\n\n<p>commando toevoegen</p>\nopdrachtcodecheck\n\n\n<p>Je voegt in de <code>pyproject.toml</code> onder het kopje <code>[project.scripts]</code> een nieuw commando <code>square</code> toe. Deze verwijst naar de functie <code>main()</code> welke in de module <code>count_count.py</code> staat die ondergebracht is in de package <code>just_count</code>. Omdat je handmatig het toml-bestand hebt aangepast synchroniseer je je virtual environment opnieuw .</p>\n\n\n<p>Pseudo-code\npyproject.toml<pre><code>[project.scripts]\nsquare = \"just_count.count_count:main\"\n</code></pre></p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> De naam van het commando is <code>square</code>.</li>\n<li> De verwijzing na het = teken begint met twee aanhalingstekens gevolgd door het package <code>just_count</code> gevolgt door een punt.</li>\n<li> Na de punt staat de naam van de module <code>count_count.py</code> zonder de extensie <code>.py</code> gevolgd door een dubbele punt.</li>\n<li> Na de dubbele punt staat de naam van de functie <code>main()</code> zonder haakjes <code>()</code>.</li>\n<li> Achter de functie staan weer dubble aanhalingstekens om de verwijzing te sluiten. </li>\n<li> Na het opslaan van de <code>pyproject.toml</code> is het pakket opnieuw ge\u00efnstalleerd. </li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> main functie toevoegen </li>\n<li> commando toevoegen</li>\n<li> commando testen</li>\n</ul>\n\n\n\n\n\n\n\n<p>Commando testen</p>\nopdrachtcodecheck\n\n\n<p>Nu je het commando <code>square</code> hebt aangemaakt ga je deze testen in een terminal. Er verschijnt een error <code>ModuleNotFoundError: No module named 'square'</code>. Je leest het info-blokje hieronder.\n\n\nJe runt het commando <code>square</code> opnieuw en je ziet de tekst <code>The square of 5 is 25</code> verschijnen. Je vraagt je af of het commando ook werkt als de terminal in een andere map zit. Met het commando <code>cd..</code> ga je naar een bovenliggende map. Je test het commando <code>square</code> en ziet weer de tekst <code>The square of 5 is 25</code> verschijnen. Je concludeert dat het commando nu overal werkt zolang het juiste virtual environment is geactiveerd. Dat test je uit door het virtual environment te deactiveren  en het commando <code>square</code> nogmaal te proberen. Je krijgt een error en hebt daarmee je vermoeden bewezen. Tevreden ga je door naar de volgende opdracht. </p>\n\n<p>ModuleNotFoundError: No module named 'square'</p>\n<p>Als je de Traceback leest zie je dat het probleem ontstaat in de module <code>count_count.py</code>. Zoiets hebben we al eerder gezien toen we werkten met het easystat package... Pas het import statement aan naar <code>from just_count import square</code>.  </p>\n\n\n\n<p>Pseudo-code\n<pre><code>(just-count) &gt; square \nTraceback (most recent call last):\nFile \"C:\\Users\\David\\AppData\\Roaming\\uv\\python\\cpython-3.10.18-windows-x86_64-none\\lib\\runpy.py\", line 196, in _run_module_as_main\n    return _run_code(code, main_globals, None,\nFile \"C:\\Users\\David\\AppData\\Roaming\\uv\\python\\cpython-3.10.18-windows-x86_64-none\\lib\\runpy.py\", line 86, in _run_code\n    exec(code, run_globals)\nFile \"C:\\Users\\David\\Documents\\ECPC\\just_count.venv\\Scripts\\square.exe__main__.py\", line 4, in \nFile \"C:\\Users\\David\\Documents\\ECPC\\just_count\\src\\just_count\\count_count.py\", line 1, in \n    import square\nModuleNotFoundError: No module named 'square'\n\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Het import statement in <code>count_count.py</code> is genoteerd beginnend vanuit de map <code>src</code>.</li>\n<li> Het commando <code>square</code> werkt als het juiste virtual environment is geactiveerd.</li>\n<li> Het commando <code>square</code> werkt nog steeds nadat je met het commando <code>cd..</code> naar een bovenliggende map bent gegaan.</li>\n<li> Het commando <code>square</code> werkt niet als het virtual environment is gedeactiveerd.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> main functie toevoegen </li>\n<li> commando toevoegen</li>\n<li> commando testen</li>\n</ul>\n\n\n\n\n\nError analysis\n<p>Als extra oefening gaan we met uv een commando maken om een ander script uit te laten voeren. De package is al aangemaakt, maar werkt nog niet naar behoren. Los in de volgende opdrachten de errors op om het script <code>data_analysis.py</code> te laten runnen.</p>\n<ol>\n<li>Ga naar GitHub en clone <code>AnneliesVlaar/erroranalysis</code> in GitHub Desktop en open de repository daarna in Visual Studio Code.</li>\n<li>Natuurlijk maak je gelijk een nieuw virtual environment aan , voordat we dit package gaan testen.</li>\n<li>Snuffel door de bestanden en mappen, en open <code>src/erroranalysis/data_analysis.py</code>. Dit is het script wat moet kunnen runnen.</li>\n<li>Run het script <code>data_analysis.py</code> en los de errors \u00e9\u00e9n voor \u00e9\u00e9n op.</li>\n</ol>\n<p>Om erachter te komen of de problemen die we hierboven hadden \u00e9cht zijn opgelost maak je een nieuw leeg virtual environment aan  en test je dat het script niet werkt. Dan installeer je het package en run je het script opnieuw. Werkt alles? Mooi! Dan gaan we nu een commando aanmaken om de functie <code>table()</code> aan te roepen.</p>\n<ol>\n<li>Open <code>pyproject.toml</code> en zoek het kopje voor scripts. Het formaat was:\n        <pre><code>[project.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre>\n        pas de regel aan zodat jouw commando de functie <code>table()</code> aanroept in <code>src/erroranalysis/data_analysis.py</code>. Je mag de naam van het commando zelf kiezen.</li>\n<li>Ga naar de terminal en kijk of het werkt!\n<pre><code>(erroranalysis) &gt; naam_commando \nArea of the kitchen table is: 1.8386 \u00b1 0.0049 m\n</code></pre></li>\n</ol>\n\n\n<p>Pythondaq: test imports</p>\nopdrachtcodecheck\n\n\n<p>\n    \n    Bij het uitbouwen van de applicatie ga je mogelijk onderdelen uit de pythonpackage importeren. Daarom is het verstandig om, net als met de opdracht Easystat package testen, het importeren uit de package te testen.\n    Maak daarvoor een <code>tests</code>-map met <code>test_imports.py</code> in de repository <code>pythondaq</code>. \n    test_imports.py<pre><code>import pythondaq.run_experiment\n</code></pre>\n    Je runt het bestand <code>test_imports.py</code> en lost de errors op. Daarna  werkt je package ook als je het aanroept van buiten de map met broncode. Je <code>pythondaq</code>-repository is nu een volledig project dat je met andere gebruikers van Python kunt delen, bijvoorbeeld via een wheel.\n    \n    \n    <code>pythondaq</code>\n    \u251c\u2500\u2500<code>src</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u2500\u2500<code>pythondaq</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>__init__.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>arduino_device.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u251c\u2500\u2500<code>diode_experiment.py</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u2500\u2500<code>run_experiment.py</code>\n    \u251c\u2500\u2500<code>tests</code>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u2500\u2500<code>test_imports.py</code>\n    \u251c\u2500\u2500<code>.python-version</code>\n    \u251c\u2500\u2500<code>pyproject.toml</code>\n    \u251c\u2500\u2500<code>README.md</code>\n    \u2514\u2500\u2500<code>uv.lock</code>\n    \n</p>\n\n\n<p>Pseudocode\nrun_experiment.py<pre><code># define from which package the module diode_experiment should be imported\n...\n</code></pre>\nTestcode\n test_imports.py\n<pre><code>import pythondaq.view\n</code></pre>\n<pre>\n<code>(ECPC) &gt; python test_imports.py\nTraceback (most recent call last):\nFile \"c:\\Users\\David\\Documents\\ECPC\\pythondaq\\tests\\test_imports.py\", line 1, in \n    import pythondaq.run_experiment\nFile \"C:\\Users\\David\\Documents\\ECPC\\pythondaq\\src\\pythondaq\\run_experiment.py\", line 5, in \n    from diode_experiment import DiodeExperiment, list_resources\nModuleNotFoundError: No module named 'diode_experiment'\n\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> Er is een map <code>tests</code> in de repository <code>pythondaq</code>.</li>\n<li> De import statements in de modules in het package <code>pythondaq</code> zijn aangepast zodat het bestand <code>test_imports</code> runt zonder problemen.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Pythondaq: docstrings</li>\n<li> Pythondaq: uv</li>\n<li> Pythondaq: src-layout</li>\n<li> Pythondaq: test imports</li>\n<li> Pythondaq: applicatie</li>\n</ul>\n\n\n\n\n\n<p>Pythondaq: applicatie</p>\nopdrachtcodecheck\n\n\n<p>Je maakt een commando om het script <code>run_experiment.py</code> uit de repository <code>pythondaq</code> te starten . Wanneer je het commando aanroept gaat het LED-lampje branden, en verschijnt er even later een IU-plot op het scherm. Je test of het commando ook buiten Visual Studio Code werkt door vanuit GitHub Menu &gt; Repository &gt; Open in Command Prompt een nieuwe terminal te openen. Je test het commando met <code>uv run</code>  en ook door het juiste virtual environment te activeren . Je ziet dat ook dan het commando werkt, zonder <code>uv run</code>. Wat een feest!  Je hebt nu een applicatie geschreven die een Arduino aanstuurt om een ledje te laten branden. En je kunt je applicatie gewoon vanuit de terminal aanroepen! </p>\n\n\n<p>Pseudo-code\nrun_experiment.py<pre><code># import statements\n\n# def function\n    # code to start a measurement\n</code></pre>\npyproject.toml<pre><code>[project.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre></p>\n\n\n<p>Checkpunten:</p>\n<ul>\n<li> De functie in <code>run_experiment.py</code> bevat alle code die uitgevoerd moet worden om een meting te starten.</li>\n<li> Het commando in de <code>pyproject.toml</code> verwijst op de correcte manier naar de functie in <code>run_experiment.py</code>.</li>\n<li> Het aanroepen van het commando zorgt ervoor dat een meting gestart wordt. </li>\n<li> Het commando werkt ook in een losse zolang het juiste virtual environment actief is, \u00f3f <code>uv run</code> wordt gebruikt.</li>\n</ul>\n<p>Projecttraject</p>\n<ul>\n<li> Pythondaq: docstrings</li>\n<li> Pythondaq: uv</li>\n<li> Pythondaq: src-layout</li>\n<li> Pythondaq: test imports</li>\n<li> Pythondaq: applicatie</li>\n</ul>\n\n\n\n\n\nVersie 2.0.0\n<p>In de <code>pyproject.toml</code> kan je ook de versie aangeven van je package. Maar wanneer hoog je nu welk cijfertje op? Wanneer wordt iets versie 2.0.0? Daar zijn conventies voor. Bug fixes gaan op het laatste cijfer, wijzigingen en nieuwe features gaan op het middelste cijfer. Wanneer de applicatie dusdanig verandert dat je bijvoorbeeld bestanden die je met oude versie hebt gemaakt niet met de nieuwe versie kunt openen, dan verander je het eerste cijfer. Je start vaak met versie 0.1.0 en blijft tijdens het bouwen van je project ophogen naar 0.2.0 en soms zelfs 0.83.0. Wanneer je project min of meer klaar is voor eerste gebruik, dan kies je er vaak voor om versie 1.0.0 te releasen.</p>\n\n\n\n<ol>\n<li>\n<p>Echt gebeurd: meerdere studenten leverden hun grafische applicatie in voor een beoordeling. We konden het niet draaien, want er misten bestanden. Bij de student werkte het wel, maar bij ons echt niet.\u00a0\u21a9</p>\n</li>\n<li>\n<p><code>more</code> is een programma die aangeleverde tekst per pagina laat zien, waar je met Space een volgende pagina te zien krijgt. Met Enter krijg je maar \u00e9\u00e9n regel extra en met Q sluit je het programma meteen af. Het <code>|</code> karakter stuurt output door. Dus <code>uv help | more</code> stuurt de output van <code>uv help</code> door naar het programma <code>more</code>.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Hint: lees de laatste regel.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Wanneer de repository op GitHub wordt geplaatst wordt deze README automatisch op de hoofdpagina van de repository getoond, onder de code.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Ja er is een map <code>easystat</code> met daarin een map <code>src</code> met daarin weer een map <code>easystat</code> \u2014 dat kan nog wel eens verwarrend zijn. Het is conventie om de projectmap dezelfde naam te geven als je package. Het pad is dus eigenlijk <code>project/src/package</code> en dat wordt dan, in ons geval, <code>easystat/src/easystat</code>.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Vroeger was er een <code>setup.py</code> maar Python schakelt nu langzaam over naar dit nieuwe bestand.\u00a0\u21a9</p>\n</li>\n<li>\n<p>In f-strings kunnen tussen de accolades variabelen of functieaanroepen staan. Voeg daar het <code>=</code>-teken aan toe en je krijgt niet alleen de waarde, maar ook de variabele of aanroep zelf te zien. Bijvoorbeeld: als je definieert <code>name = \"Alice\"</code>, dan geeft <code>print(f\"{name}\")</code> als uitkomst <code>Alice</code>. Maar voeg je het <code>=</code>-teken toe zoals in <code>print(f\"{name=\")}</code> wordt de uitvoer <code>name='Alice'</code>. Je ziet dan dus ook meteen de naam van de variabele en dat kan handig zijn.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Tom Preston-Werner, Pradyun Gedam, and others. Tom's obvious, minimal language. URL: https://github.com/toml-lang/toml.\u00a0\u21a9</p>\n</li>\n</ol>"},{"location":"terminal-adventure-game/","title":"Terminal Adventure Game","text":"<p>To play the Terminal Adventure Game, clone the repository or download and unpack the zip. Open the folder suitable for your operating system and preferred language in explorer. Go into the forest folder and open/run the 'start' file. Let yourself be guided through the adventure.</p> <p>Parrot Pokkie was taken from the girl by Snerk the Extremely Magnificent. Can you help her get Pokkie back?</p> <p></p>"},{"location":"terminal-adventure-game/#credits","title":"credits","text":"<p>This game was developed by Extra Nice in Leeuwarden in association with VU</p>"},{"location":"tui/","title":"Text-based user interfaces","text":"<p>De text-based user intefaces (TUI) of terminal user interface zijn de voorlopers van de graphical user interfaces die wel nog in een terminal worden uitgevoerd. Een populair framework waarmee je in Python een TUI kunt bouwen is Textual.</p> Textual installeren <p>Maak een nieuwe conda omgeving aan en installeer de benodigdheden voor Textual. Zie voor meer informatie de documentatie</p> Stopwatch <p>Volg de tutorial van Textual om een stopwatch applicatie te maken.</p> Pythondaq: TUI <p>Maak met behulp van Textual een TUI voor Pythondaq.</p>"},{"location":"vervolg-python/","title":"Uitgebreidere Python kennis","text":"<p>Python is een batteries included taal. Dat betekent dat als je 'kaal' Python installeert er al heel veel functionaliteit standaard meegeleverd wordt. Allereerst omdat de taal zelf al behoorlijk krachtig is, maar ook omdat de standaardbibliotheek zeer uitgebreid is. Met een eenvoudig <code>import</code>-statement haal je extra functionaliteit binnen, onder andere op het gebied van datatypes, wiskunde, toegang tot bestanden, een database, datacompressie, cryptografie, netwerktoegang, e-mail, multimedia, etc. Nog veel meer bibliotheken zijn beschikbaar via de Python Package Index<sup>17</sup>.</p> <p>In dit hoofdstuk behandelen we de kennis die nuttig kan zijn voor de rest van deze cursus<sup>1</sup>. Een deel van wat we hier behandelen kan al bekend zijn uit eerdere cursussen. Een ander deel is nieuw.<sup>2</sup></p> <p>In de cursus gaan we bibliotheken (modules, packages) en een applicatie ontwikkelen. Dat betekent dat we verder gaan dan het schrijven van scripts en dat we dus meer gaan doen dan functies schrijven. Uiteindelijk moet het mogelijk zijn de software te verspreiden op een wat meer professionele manier. Dus niet alleen via een zipje met wat Pythonbestanden waar uiteindelijk verschillende versies van rondslingeren en die lastig zijn te updaten. Wat er nodig is voor een goede distributie van software en om het mogelijk te maken met meerdere mensen software te (blijven) ontwikkelen zal in deze cursus aan bod komen.</p> <p>Een punt wat vaak onderschoven blijft is documentatie. Als je software schrijft die gebruikt (en doorontwikkeld) wordt in een onderzoeksgroep, dan is het heel belangrijk dat iedereen kan begrijpen wat je software doet en hoe die uitgebreid kan worden. Het is zonder hulp vaak heel moeilijk om de code van een iemand anders te begrijpen. En in de praktijk blijkt heel vaak dat als je code schrijft en daar een paar weken of maanden later op terugkijkt, jij z\u00e9lf die ander bent. Wat toen blijkbaar heel logisch leek, is dat later toch niet meer. Dus documentatie schrijf je heel vaak ook gewoon voor jezelf.</p> <p>Als je niet zo heel veel in Python geprogrammeerd hebt kan het helpen om de paragraaf Basiskennis Python<sup>18</sup> door te nemen. Een boek dat zeker bij natuurkundigen in de smaak kan vallen is Effective Computation in Physics<sup>19</sup>, maar deze is niet gratis verkrijgbaar. Een boek dat zowel op papier te bestellen is als in de vorm van een pdf of webpagina is te lezen is Think Python.<sup>20</sup></p>"},{"location":"vervolg-python/#visual-studio-code","title":"Visual Studio Code","text":"<p>Om Python scripts te schrijven maken we gebruik van Visual Studio Code.</p> <p>Visual Studio Code</p> <p>Visual Studio Code heeft heel veel opties, maar zorg ervoor dat je in ieder geval weet hoe je een map moet aanmaken en openen zie opdracht \"Open VSCode en maak de map ECPC\" en hoe je een bestand aanmaakt en opent. Daarnaast zullen we veel met de ingebouwde terminal in Visual Studio Code werken. Zorg dat je weet waar je die terminal kunt vinden, hoe je een nieuwe opent (Terminal &gt; New Terminal) en hoe je een terminal weggooit (klik op de ). </p> <p>Keyboard Shortcuts</p> <p>Er zijn heel veel toetscombinaties die je kunt gebruiken om sneller te werken (maar dan moet je ze natuurlijk wel onthouden). We hebben 8 handige toetscombinaties in de handleiding verstopt achter kleine ECPC paaseieren . Kijk hieronder welke je al hebt gevonden.</p> <ul> <li> Select+Ctrl+/</li> <li> Ctrl+Shift+N</li> <li> Alt+Up</li> <li> Up</li> <li> Alt+Left Button</li> <li> Select+F2</li> <li> Ctrl+Shift+A</li> <li> Select+Ctrl+D</li> </ul>"},{"location":"vervolg-python/#zen-of-python","title":"Zen of Python","text":"<p>Python is niet C (of iedere willekeurige andere programmeertaal). Er zit een gedachte achter die op een gegeven moment verwoord is door Tim Peters<sup>21</sup>.</p> <p>Je kunt het lezen middels een easter egg in Python zelf: <code>import this</code>.</p> <p>zen</p> <ol> <li>Open Visual Studio Code.</li> <li>Open de map <code>ECPC</code>).</li> <li>Maak een bestand <code>zen-of-python.py</code> met daarin de onderstaande code: <pre><code>import this\n</code></pre> <code>ECPC</code> \u251c\u2500\u2500  <code>zen-of-python.py</code> \u2514\u2500\u2500 \u2022\u2022\u2022</li> <li>Run het script en lees de output. </li> </ol> <p>Deze tekst kan nog behoorlijk cryptisch overkomen, maar een paar dingen worden snel duidelijk: code moet mooi zijn (regel 1) en duidelijk (regels 2, 3 en 6). Er bestaan prachtige programmeertrucs in \u00e9\u00e9n of twee regels, maar onleesbaar is het wel. Een voorbeeld <sup>22</sup>: <pre><code>print('\\n'.join(\"%i bytes = %i bits which has %i possible values.\" %\n      (j, j*8, 256**j) for  j in (1 &lt;&lt; i for i in range(4))))\n</code></pre></p> <p>Kun je zien wat de uitvoer van dit programma moet zijn? Misschien als we het op deze manier uitschrijven:</p>  zen.py <pre><code>for num_bytes in [1, 2, 4, 8]:\n    num_bits = 8 * num_bytes\n    num_possible_values = 2 ** num_bits\n    print(\n        f\"{num_bytes} bytes = {num_bits} bits which has {num_possible_values} possible values.\"\n    )\n</code></pre> <pre>\n<code>(ECPC) &gt; python zen.py\n1 bytes = 8 bits which has 256 possible values.\n2 bytes = 16 bits which has 65536 possible values.\n4 bytes = 32 bits which has 4294967296 possible values.\n8 bytes = 64 bits which has 18446744073709551616 possible values.\n</code></pre> <p>De code is langer, met duidelijkere namen van variabelen en zonder bitshifts of joins.</p> <p>Moraal van dit verhaal: we worden gelukkiger van code die leesbaar en begrijpelijk is, dan van code die wel heel slim in elkaar zit maar waar bijna niet uit te komen is. Overigens komt het regelmatig voor dat de programmeur z\u00e9lf een paar weken later al niet zo goed meer weet hoe de code nou precies in elkaar zat.</p> <p>Als je samenwerkt aan software kan het andere Pythonprogrammeurs erg helpen om dingen 'op de Python-manier te doen'. Een C-programmeur herken je vaak aan het typische gebruik van lijsten of arrays in <code>for</code>-loops. Als je een lijst hebt: <code>names = ['Alice', 'Bob', 'Carol']</code>, doe dan niet: <pre><code>names = ['Alice', 'Bob', 'Carol']\ni = 0\nwhile i &lt; len(names):\n    print(\"Hi,\", names[i])\n    i = i + 1\n</code></pre> en ook niet: <pre><code>names = ['Alice', 'Bob', 'Carol']\nfor i in range(len(names)):\n    print(\"Hi,\", names[i])\n</code></pre> waarbij je loopt over een index <code>i</code>. Gebruik liever het feit dat een lijst al een iterator is: <pre><code>names = ['Alice', 'Bob', 'Carol']\nfor name in names:\n    print(\"Hi,\", name)\n</code></pre> Deze code is bovendien veel korter en gebruikt minder variabelen.</p> <p>Itereren op de python-manier</p> <ol> <li>Neem het onderstaande script over.</li> <li>Itereer over de lijst <code>voltages</code> op de python-manier.</li> <li>Print voor elk item in de lijst de waarde in mV. Bijvoorbeeld: \"The voltage is set to 0 mV.\"</li> </ol> <pre><code>voltages = [0, 50, 100, 150, 200, 250, 300] #mV\n</code></pre> Uitwerkingen <p> iterator.py <pre><code>voltages = [0, 50, 100, 150, 200, 250, 300] #mV\n\nfor voltage in voltages:\n    print(f\"The voltage is set to {voltage} mV.\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python iterator.py\nThe voltage is set to 0 mV.\nThe voltage is set to 50 mV.\nThe voltage is set to 100 mV.\nThe voltage is set to 150 mV.\nThe voltage is set to 200 mV.\nThe voltage is set to 250 mV.\nThe voltage is set to 300 mV.\n</code></pre></p>"},{"location":"vervolg-python/#enumerate","title":"Enumerate","text":"<p>Soms is het nodig om de index te hebben, bijvoorbeeld wanneer je een namenlijstje wilt nummeren: Terminal<pre><code>1. Alice\n2. Bob\n3. Carol\n</code></pre></p> <p>Dit kan dan in Python-code het makkelijkst als volgt: <pre><code>for idx, name in enumerate(names, 1):\n    print(f\"{idx}. {name}\")\n</code></pre> Hier maken we gebruik van de <code>enumerate(iterable, start=0)</code>-functie en f-strings. Er zijn dus veel manieren om programmeerproblemen op te lossen, maar het helpt om het op de `Pythonmanier' te doen. Andere programmeurs zijn dan veel minder tijd en energie kwijt om jouw code te begrijpen -- \u00e9n andersom wanneer jij zelf op internet zoekt naar antwoorden op problemen. Immers, je herkent dan veel makkelijker en sneller hoe andermans code werkt.</p>"},{"location":"vervolg-python/#datatypes","title":"Datatypes","text":"<p>Gehele getallen, kommagetallen, strings: allemaal voorbeelden van datatypes. Veel zullen jullie al wel bekend voorkomen, zoals strings, lists en NumPy arrays. Andere zijn misschien alweer wat weggezakt, zoals dictionaries of booleans. Weer andere zijn misschien wat minder bekend, zoals complexe getallen of sets. En als laatste voegt Python af en toe nieuwe datatypes toe, zoals f-strings in Python 3.6 of data classes sinds Python 3.7.</p> <p>Info</p> <p>De python-standard-library documentatie <sup>23</sup> bevat een mooi overzicht van alle datatypes met een beschrijving van operaties en eigenschappen. Voor uitgebreidere tutorials kun je vaak terecht bij real-python <sup>24</sup>. Het kan makkelijk zijn om in een zoekmachine bijvoorbeeld <code>real python dict</code> te typen als je een tutorial zoekt over Python dictionaires.</p> <p>Om nog even te oefenen met de datatypes volgt er een aantal korte opdrachten.</p>"},{"location":"vervolg-python/#list","title":"List","text":"<p>list</p> <p>Schrijf een kort scriptje.</p> <ol> <li>Maak een <code>list</code> van de wortels van de getallen 1 tot en met 10. Dus de rij $\\left(\\sqrt{1}, \\sqrt{2}, \\sqrt{3}, \\ldots, \\sqrt{10}\\right)$.</li> <li>Print die rij onder elkaar (\u00e9\u00e9n getal per regel, met drie decimalen).</li> <li>Geef weer of het getal 3 voorkomt in die rij en geef weer of het getal 4 voorkomt in die rij.</li> </ol> Uitwerkingen <p> list.py <pre><code>import math\n\nsquares = []\nfor n in range(1, 11):\n    squares.append(math.sqrt(n))\n\n# print the list below each other with three decimal places\nprint(\"Square of range 1 to 10 with three decimal places: \")\nfor square in squares:\n    print(f\"{square:.3f}\")\n\n# State if number 3 or 4 appears in the list of squares\nfor number in [3, 4]:\n    print(f\"does number {number} appears in the list of squares?\", number in squares)\n</code></pre> <pre>\n<code>(ECPC) &gt; python list.py\nSquare of range 1 to 10 with three decimal places: \n1.000\n1.414\n1.732\n2.000\n2.236\n2.449\n2.646\n2.828\n3.000\n3.162\ndoes number 3 appears in the list of squares? True\ndoes number 4 appears in the list of squares? False\n</code></pre></p>"},{"location":"vervolg-python/#numpy-array","title":"NumPy array","text":"<p>Je kunt op verschillende manieren een NumPy array maken (na <code>import numpy as np</code>):</p> <ul> <li>Door een Python lijst te converteren: <code>np.array([0, 0.5, 1, 1.5, 2])</code>.</li> <li>Door een array aan te maken met een stapgroote: <code>np.arange(0, 3, 0.5) # start, stop, step</code></li> <li>Door een array aan te maken met getallen gelijkmatig verdeeld over een interval: <code>np.linspace(0, 2.5, 6) #start, stop, number</code></li> </ul> NumPy arrays <p>NumPy arrays zijn vaak handiger dan lists. Als je een array hebt van 20 $x$-waardes in het domein $[0, \\pi]$ kun je in \u00e9\u00e9n keer alle waardes van $\\sin x$ uitrekenen. Bijvoorbeeld: <pre><code>import numpy as np\nfrom numpy import pi\n\nx = np.linspace(0, pi, 20)\ny = np.sin(x)\n</code></pre> NumPy voert de berekeningen uit binnen een C-bibliotheek<sup>3</sup> en is daarmee veel sneller dan een berekening in Python zelf:</p> <p><pre><code>import math\nx = [0.00, 1.05, 2.09, 3.14, 4.19, 5.24, 6.28]\ny = []\nfor u in x:\n    y.append(math.sin(u))\n</code></pre> Niet alleen is NumPy zo'n honderd keer sneller,<sup>4</sup> het is ook veel korter op te schrijven. Het nadeel van NumPy arrays is dat je geen elementen kunt toevoegen.<sup>5</sup> Python lijsten hebben dus voordelen, zeker als rekentijd geen probleem voor je is.</p> <p>Als je veel functies uit NumPy gebruikt is het handig \u2013 en gebruikelijk \u2013 om je import-statements kort te houden en duidelijk te maken dat je de <code>sin()</code>-functie uit NumPy gebruikt en niet uit de <code>math</code> module. Constantes worden wel vaak los ge\u00efmporteerd. Daarom is dit dus gebruikelijk: <pre><code>import numpy as np\nfrom numpy import pi\n\nx = np.linspace(0, pi, 100)\ny = np.sin(x)\n</code></pre></p> <p>np.array</p> <p>Doe hetzelfde als de vorige opdracht met lists, maar nu met NumPy arrays:</p> <ol> <li>Maak een <code>np.array</code> van de wortels van de getallen 1 tot en met 10. Dus de rij $\\left(\\sqrt{1}, \\sqrt{2}, \\sqrt{3}, \\ldots, \\sqrt{10}\\right)$.</li> <li>Print die rij onder elkaar (\u00e9\u00e9n getal per regel, met drie decimalen).</li> <li>Geef weer of het getal 3 voorkomt in die rij en geef weer of het getal 4 voorkomt in die rij.</li> </ol> Uitwerkingen <p> np_array.py <pre><code>import numpy as np\n\n# Make an array from 1 to 10\nnumbers = np.arange(1, 11, 1)\n\n# Take the squareroot of each number\nsquareroot = np.sqrt(numbers)\n\n# Print the list of squareroots below each other with three decimal places\nfor root in squareroot:\n    print(f\"{root:.3f}\")\n\n# State if number 3 or 4 appears in the list of squares\nprint(\"does number 3 appears in the list of squares?\", 3 in squareroot)\nprint(\"does number 4 appears in the list of squares?\", 4 in squareroot)\n</code></pre> <pre>\n<code>(ECPC) &gt; python np_array.py\n1.000\n1.414\n1.732\n2.000\n2.236\n2.449\n2.646\n2.828\n3.000\n3.162\ndoes number 3 appears in the list of squares? True\ndoes number 4 appears in the list of squares? False\n</code></pre></p> Dictionaries Tuples, * args, ** kwargs Set"},{"location":"vervolg-python/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries zijn een bijzonder handige manier om informatie op te slaan. Een dictionary bestaat uit een of meerdere key-value tweetallen. Met een handige gekozen naam voor de key kan je betekenis geven aan een value. </p> <p>dict</p> <p>Schrijf een kort scriptje:</p> <ol> <li>Maak een dictionary <code>constants</code> met de waardes van de (natuur)constantes $\\pi$, de valversnelling $g$, de lichtsnelheid $c$ en het elementaire ladingskwantum $e$.</li> <li>Print de namen -- niet de waardes -- van de constantes die zijn opgeslagen in <code>constants</code>.</li> <li>Bereken de zwaartekracht $F_\\text{z} = mg$ voor een voorwerp met een massa van 14 kg door gebruik te maken van de waarde van $g$ uit de dictionary.</li> <li>Maak een dictionary <code>measurement</code> die de resultaten van een meting bevat: een spanning van 1.5 V bij een stroomsterkte van 75 mA.</li> <li>Bereken de weerstand van de schakeling op basis van de voorgaande meting en bewaar het resultaat in dezelfde dictionary.</li> </ol> Uitwerkingen <p> dictionaries.py <pre><code>import numpy as np\n\n# Dictionary of constants pi, gravitational acceleration (g), the speed of light (c) and elementary charge (e)\nconstants = {\"pi\": np.pi, \"g\": 9.81, \"c\": 3e8, \"e\": 1.6e-19}\n\n# print de names -not the values- of the constants in the dictionary\nprint(constants.keys())\n\n# Calculate gravity of an object with mass of 14 kg\nmass = 14  # kg\nF_z = mass * constants[\"g\"]\nprint(f\"Gravity of an object with {mass} kg is: {F_z} N\")\n\n# Dictionary with results of a measurement \nmeasurement = {\"U\": 1.5, \"I\": 75e-3}  # U in V, I in A\n\n# Add resistance to dictionary\nmeasurement[\"R\"] = measurement[\"U\"] / measurement[\"I\"]\n\nprint(f'The resistance was: {measurement[\"R\"]:.2f} \\u03A9')\n</code></pre> <pre>\n<code>(ECPC) &gt; python dictionaries.py\ndict_keys(['pi','g', 'c', 'e'])\nGravity of an object with 14kg is: 137.34 N\nThe resistance was: 20.00 \u03a9\n</code></pre></p>"},{"location":"vervolg-python/#tuples-args-kwargs","title":"Tuples, * args, ** kwargs","text":"<p>In Python zijn <code>tuple</code>'s een soort alleen-lezen <code>list</code>'s. Een tuple is een immutable<sup>6</sup> object. Daarom worden ze vaak gebruikt wanneer lijstachtige objecten altijd dezelfde vorm moeten hebben. Bijvoorbeeld een lijst van $(x, y)$-co\u00f6rdinaten zou je zo kunnen defini\u00ebren:</p> <p><pre><code>coords = [(0, 0), (1, 0), (0, 1)]\n</code></pre> Hier is <code>coords[0]</code> gelijk aan <code>(0, 0)</code>. Je kunt nu niet dit co\u00f6rdinaat uitbreiden naar drie dimensies met <code>coords[0].append(1)</code> en dat is waarschijnlijk precies wat je wilt voor een lijst met tweedimensionale co\u00f6rdinaten. Ook is dit object veel compacter dan een <code>dict</code>: <pre><code>coords = [{\"x\": 0, \"y\": 0}, {\"x\": 1, \"y\": 0}, {\"x\": 0, \"y\": 1}]\n</code></pre> Hier zijn tuples dus best handig, al moet je dus wel onthouden in welke volgorde de elementen staan. Dat is voor $(x, y)$-co\u00f6rdinaten niet zo'n probleem maar kan in andere situaties lastiger zijn.<sup>7</sup> Tuples ondersteunen tuple unpacking. Je kunt het volgende doen:</p> <p><pre><code>(x, y, z) = (2, 3, 4)\n</code></pre> Na deze operatie geldt $x = 2$, $y = 3$ en $z = 4$. Je mag zelfs de haakjes weglaten voor nog compactere notatie: <pre><code>x, y, z = 2, 3, 4\n</code></pre> Op deze manier kan een functie ook meerdere argumenten teruggeven die je vervolgens uit elkaar plukt: <pre><code>def get_measurement():\n    ...  # perform measurement\n    return voltage, current\n\n\nvoltage, current = get_measurement()\n</code></pre> Het uit elkaar plukken van argumenten kan zelfs als je een functie aanroept: <pre><code>def power(a, b):\n    return a ** b\n\n\n# regular function call\npower(2, 7)\n\n# function call with tuple unpacking\nargs = 2, 7\npower(*args)\n</code></pre> Wat zelfs werkt is dictionary unpacking. Je kunt aan functies ook argumenten bij naam meegeven -- de volgorde maakt dan niet uit en je maakt in je programma expliciet duidelijk welke argumenten je meegeeft. Dat werkt zo: <pre><code># regular function call\npower(b=7, a=2)\n\n# function call with dictionary unpacking\nkwargs = {\"b\": 7, \"a\": 2}\npower(**kwargs)\n</code></pre></p> <p>args</p> <p>Gegeven de lijst <code>odds = [1, 3, 5, 7, 9]</code>, print de waardes uit deze lijst op \u00e9\u00e9n regel, zoals hieronder weergegeven: Terminal<pre><code>1 3 5 7 9\n</code></pre> Je mag er niet vanuit gaan dat de lijst altijd 5 elementen bevat.</p> Uitwerkingen <pre><code>odds = [1, 3, 5, 7, 9]\n\n# What is the difference between printing with and without a star?\nprint(*odds)\n\nprint(odds)\n</code></pre>"},{"location":"vervolg-python/#set","title":"Set","text":"<p>Als laatste willen we nog de aandacht vestigen op <code>set</code>'s: een unieke verzameling van objecten. Ieder element komt maar \u00e9\u00e9n keer voor in een set: <pre><code>l = [1, 2, 2, 3, 5, 5]\nset(l)\n# {1, 2, 3, 5}\n</code></pre> Je moet even oppassen: de <code>{}</code>-haakjes worden gebruikt voor zowel sets als dictionaries. Omdat een dictionary (key: value) paren heeft en een set losse elementen kan Python het verschil wel zien: <pre><code>is_set = {1, 2, 3, 4}\nis_dict = {1: 1, 2: 4, 3: 9, 4: 16}\n</code></pre> Dat gaat alleen mis als je een lege set wilt maken. Daarvoor zul je expliciet de <code>set()</code>-constructor moeten gebruiken: <pre><code>is_dict = {}\nis_set = set()\n</code></pre> Je kunt elementen toevoegen aan een set met <code>.add()</code> en sets gebruiken om verzamelingen met elkaar te vergelijken. Komen er elementen wel of niet voor in een set? Is de ene set een subset van de andere set? Enzovoorts. Zie daarvoor verder de documentatie.</p>"},{"location":"vervolg-python/#comprehension","title":"Comprehension","text":"<p>Door gebruik te maken van een list comprehension kun je de for-loop in \u00e9\u00e9n regel opschrijven: <pre><code>from math import sin\nx = [0.00, 1.05, 2.09, 3.14, 4.19, 5.24, 6.28]\ny = [sin(u) for u in x]\n</code></pre> Er is in veel gevallen tegenwoordig geen groot verschil met een for-loop qua snelheid. In andere gevallen is de list comprehension net wat sneller. Als je lijsten niet te lang zijn is het makkelijker (en sneller) om een list comprehension te gebruiken in plaats van je lijst \u00e9\u00e9rst naar een array te veranderen en er dan mee verder te rekenen. Als je lijst w\u00e9l lang is of je weet al dat je meerdere berekeningen wilt uitvoeren kan dat wel: <pre><code>import numpy as np\nx = [0.00, 1.05, 2.09, 3.14, 4.19, 5.24, 6.28]\nx = np.array(x)\ny = np.sin(x)\n</code></pre></p> <p>Kortom: berekeningen met arrays zijn sneller, maar for-loops (en list comprehensions) zijn veelzijdiger. Het is zelfs mogelijk om een <code>if</code>-statement op te nemen in je list comprehension. Bijvoorbeeld:</p>  pdf.py <pre><code>filenames = [\"test.out\", \"text.pdf\", \"manual.pdf\", \"files.zip\"]\npdfs = [name for name in filenames if name.endswith(\".pdf\")]\nprint(f\"{pdfs=}\")\n</code></pre> <pre><code>(ECPC) &gt; python pdf.py\npdfs=['text.pdf', 'manual.pdf']\n</code></pre> <p>In een for-loop heb je daar meer ruimte voor nodig. Naast list comprehensions heb je ook set comprehensions<sup>8</sup> en dict comprehensions.</p> <p>array, for-loops en comprehensions</p> <p>Voer, door een script te schrijven, de volgende opdrachten uit:</p> <ol> <li>Maak een lijst van de getallen 1 tot en met 10.</li> <li>Gebruik een 'gewone' for-loop om een lijst te maken van de derdemachtswortel van de getallen.</li> <li>Maak nogmaals een lijst van de derdemachtswortel van de getallen maar gebruik nu list comprehension.</li> <li>Gebruik tot slot arrays om de lijst met derdemachtswortels van de getallen te maken. </li> </ol> Uitwerkingen <p> for_loop.py <pre><code>import numpy as np\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# use a for loop to create a list with cube root of numbers\ncube_root = []\nfor number in numbers:\n    answer = number ** (1 / 3)\n    cube_root.append(answer)\n\n\n# use list comprehension to create a list with cube root of numbers\ncube_root_comprehension = [n ** (1 / 3) for n in numbers]\n\n# use numpy arrays to create a list with cube root of numbers\nnumbers = np.array(numbers)\ncube_root_array = numbers ** (1 / 3)\n\nprint(cube_root)\nprint(cube_root_comprehension)\nprint(cube_root_array)\n</code></pre> <pre>\n<code>(ECPC) &gt; python for_loop.py\n[1.0, 1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968, 1.8171205928321397, 1.912931182772389, 2.0, 2.0800838230515904, 2.154434690031884]\n[1.0, 1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968, 1.8171205928321397, 1.912931182772389, 2.0, 2.0800838230515904, 2.154434690031884]\n[1.         1.25992105 1.44224957 1.58740105 1.70997595 1.81712059 1.91293118 2.        2.08008382 2.15443469]\n</code></pre></p> Lambda functions Generators Dunder methods Decorators"},{"location":"vervolg-python/#lambda-functions","title":"Lambda functions","text":"<p>In Python zijn functies ook objecten. Je kunt ze bewaren in een lijst of dictionary, of je kunt ze meegeven als parameter aan een andere functie. Dat kan heel handig zijn! Stel je hebt een lijst met verschillende soorten fruit die je wilt sorteren op alfabet: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\nprint(sorted(a))\n</code></pre> <pre><code>(ECPC) &gt; python sort.py \n['apple', 'banana', 'kiwi']\n</code></pre> Dat gaat heel makkelijk met de ingebouwde <code>sorted()</code>-functie. Je kunt aan deze functie ook een <code>key</code>-parameter meegeven; een \u00e1ndere functie die gebruikt wordt om te bepalen waarop gesorteerd moet worden. Zo kun je sorteren op de lengte van de fruitnamen door simpelweg de <code>len()</code>-functie als parameter mee te geven: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\n\nprint(len(\"apple\"))\nprint(sorted(a, key=len))\n</code></pre> <pre><code>(ECPC) &gt; python length.py \n5\n['kiwi', 'apple', 'banana']\n</code></pre> Als je wilt sorteren op de tweede letter van de naam -- waarom niet? -- dan kun je zelf een functie defini\u00ebren en gebruiken: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\n\ndef second_letter(value):\n    return value[1]\n\nprint(second_letter(\"lemon\"))\nprint(sorted(a, key=second_letter))\n</code></pre> <pre><code>(ECPC) &gt; python second_letter.py \ne\n['banana', 'kiwi', 'apple']\n</code></pre> Lambdafuncties zijn bedacht om je een hoop typewerk te besparen. Je kunt korte functies in \u00e9\u00e9n regel opschrijven en gebruiken, zolang het maar een geldige expression is. G\u00e9\u00e9n if-then-else, maar de meeste andere dingen mogen wel. Bijvoorbeeld: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\n\nsquared = lambda x: x ** 2\nprint(squared(4))\n\nsecond_letter = lambda value: value[1]\nprint(sorted(a, key=second_letter))\n</code></pre> <pre><code>(ECPC) &gt; python lamda.py \n16\n['banana', 'kiwi', 'apple']\n</code></pre> Aangezien de definitie van een lambdafunctie zelf ook een expression is kun je het sorteren op de tweede letter zelfs in \u00e9\u00e9n regel doen: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\n\nprint(sorted(a, key=lambda value: value[1]))\n</code></pre> <pre><code>(ECPC) &gt; python one_line.py \n['banana', 'kiwi', 'apple']\n</code></pre></p> <p>Lambdafuncties kun je ook gebruiken om te fitten aan een bepaald model. Je definieert je model dan in \u00e9\u00e9n regel met een lambdafunctie:</p> <p><pre><code># from lmfit import models\nf = lambda x, a, b: a * x + b\nmodel = models.Model(f)\nfit = model.fit(y, x=x)\n</code></pre> Het is hierbij wel belangrijk dat <code>lmfit</code> er vanuit gaat dat de eerste variabele in de functiedefinitie de onafhankelijke variabele ($x$-as) is. Dit is verder geen Pythonlimitatie.</p> <p>Je kunt de functies ook bewaren in een dictionary voor later gebruik.</p> <p>lambda</p> <p>Maak een dictionary <code>models</code> met functies voor een lineaire functie <code>linear</code> gegeven door $y = ax + b$, een kwadratische functie <code>quadratic</code> gegeven door $y = ax^2 + bx + c$ en een sinusfunctie <code>sine</code> gegeven door $a + b\\sin(cx + d)$. Hierna moet de volgende code werken: <pre><code>f = models['linear']\nf(5, a=2, b=3)\n# 13\n</code></pre> Maak een grafiek van de sinusfunctie op het domein $[0,\\, 2\\pi]$ met parameters $a=1$, $b=2$, $c=2$ en $d=\\frac{\\pi}{2}$.</p> Uitwerkingen <pre><code>import numpy as np\nfrom numpy import pi\nimport matplotlib.pyplot as plt\n\n# dictionary with linear, quadratic and sine function\nmodels = {\n    \"linear\": lambda x, a, b: a * x + b,\n    \"quadratic\": lambda x, a, b, c: a * x ** 2 + b * x + c,\n    \"sine\": lambda x, a, b, c, d: a + b * np.sin(c * x + d),\n}\n\n# test the next piece of code\nf = models[\"linear\"]\nprint(f(5, a=2, b=3))\n\n# Graph of sine function on domain [0, 2pi] with parameters a=1, b=2, c=2, d=0.5pi\nx = np.linspace(0, 2 * pi, 100)\nf = models[\"sine\"]\n\nplt.plot(x, f(x, a=1, b=2, c=2, d=0.5 * pi))\nplt.show()\n</code></pre>"},{"location":"vervolg-python/#generators","title":"Generators","text":"<p>Als een functie een serie metingen verricht kan het lang duren voordat de functie de resultaten teruggeeft. Laten we die functie even <code>perform_measurements()</code> noemen. Het is soms lastig als de rest van het programma daarop moet wachten voordat een analyse kan worden gedaan, of een melding aan de gebruiker kan worden gegeven. Het kan dan gebeuren dat je je programma draait en je dan afvraagt: doet hij het, of doet hij het niet? Je kunt dit oplossen door <code>print()</code>-statements in je programma op te nemen, maar dit is niet zo netjes. Als je <code>perform_measurements()</code> inbouwt in een tekstinterface die ook stil moet kunnen zijn? Of als je de functie gaat gebruiken vanuit een grafisch programma waarin je geen tekst wilt printen, maar een grafiek wilt opbouwen? Je moet dan steeds <code>perform_measurements()</code> gaan aanpassen. Een ander probleem kan optreden wanneer je langdurige metingen doet die ook veel geheugen innemen. Wachten op de hele meetserie betekent dat het geheugen vol kan lopen. Lastig op te lossen!</p> <p>Of\u2026 je maakt gebruik van een generator function: een functie die tussendoor resultaten teruggeeft. Dat kan door gebruik te maken van <code>yield</code> in plaats van <code>return</code>. De rest gaat automatisch. Maar: je moet wel even weten hoe je omgaat met de generator. Stel, we willen de kwadraten berekenen van een reeks getallen tot een bepaald maximum: <pre><code>def calculate_squares_up_to(max_number):\n    \"\"\"Calculate squares of all integers up to a maximum number\"\"\"\n    squares = []\n    for number in range(max_number):\n        squares.append(number ** 2)\n    return squares\n\nprint(calculate_squares_up_to(5))\n</code></pre> <pre><code>(ECPC) &gt; python squares.py \n[0, 1, 4, 9, 16]\n</code></pre></p> <p>De functie berekent eerst alle kwadraten, voegt ze toe aan een lijst en geeft vervolgens de lijst met uitkomsten terug. Een generator definieer je als volgt: <pre><code>def calculate_squares_up_to(max_number):\n    \"\"\"Generate squares of all integers up to a maximum number\"\"\"\n    for number in range(max_number):\n        yield number ** 2\n</code></pre> Lekker kort, want we hoeven geen lijst bij te houden! Als je de functie aanroept krijg je geen resultaat terug, maar een generator. Als je de waardes wil zien dan gebruik je <code>next()</code>, als volgt: <pre><code>square_generator = calculate_squares_up_to(5)\nnext(square_generator)\n# 0\nnext(square_generator)\n# 1\n...\nnext(square_generator)\n# 16\nnext(square_generator)\n# StopIteration\n</code></pre> Als de generator is uitgeput (de for-loop is afgelopen, de functie sluit af) dan geeft Python een <code>StopIteration</code> exception en crasht het programma -- tenzij je de exception afvangt. Het werkt, maar het is niet helemaal ideaal. Makkelijker is om de generator te gebruiken in een loop: <pre><code>for square in calculate_squares_up_to(5):\n    print(\"Still calculating...\")\n    print(square)\n</code></pre> <pre><code>(ECPC) &gt; python squares.py \nStill calculating...\n0\nStill calculating...\n1\nStill calculating...\n4\nStill calculating...\n9\nStill calculating...\n16\n</code></pre></p> <p>Dit kan ook in list comprehensions. En als je toch wilt wachten op alle resultaten, dan kan dat eenvoudig met <code>squares = list(calculate_squares_up_to(5))</code>.</p> <p>generators</p> <p>Schrijf een generator function die het vermoeden van Collatz illustreert. Dat wil zeggen: beginnend bij een getal $n$, genereer het volgende getal als volgt: is het getal even, deel het dan door twee; is het getal oneven, vermenigvuldig het met 3 en tel er 1 bij op. Enzovoorts. Sluit de generator af als de uitkomst gelijk is aan 1. Dat is het vermoeden van Collatz: ongeacht met welk geheel getal je begint, je komt altijd op 1 uit. Als voorbeeld, beginnend bij het getal 3 krijg je de reeks 3, 10, 5, 16, 8, 4, 2, 1.</p> Uitwerkingen <p> collatz.py <pre><code>def Collatz(x):\n    \"\"\"Illustrates Collatz's conjecture\n\n    Starts with x generates next number when x is not equal to 1.\n    Next number is x devided by 2 if x is even and x times 3 + 1 if x is odd.\n    Collatz suspects that you always end with number 1 despite of the starting value.\n\n    Args:\n        x (int): starting value\n\n    Yields:\n        int: next number in the sequence\n    \"\"\"\n    yield x\n    while x != 1:\n        if x % 2 == 0:\n            # x is even and is divided by 2\n            x = x // 2  # dubble // makes it an integer\n        else:\n            # x is odd, multiply by 3 and add 1\n            x = 3 * x + 1\n        yield x\n\n\nprint(\"print the values of generator with next:\")\ncollatz_generator = Collatz(3)\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\nprint(next(collatz_generator))\n# print(next(collatz_generator)) # gives StopIteration exception\n\nprint(\"print values of generator without next:\")\nfor number in Collatz(28):\n    print(number)\n</code></pre> <pre>\n<code>(ECPC) &gt; python collatz.py\nprint the values of generator with next:\n3\n10\n5\n16\n8\n4\n2\n1\nprint the values of generator without next:\n28\n14\n7\n22\n11\n34\n17\n52\n26\n13\n40\n20\n10\n5\n16\n8\n4\n2\n1\n</code></pre></p>"},{"location":"vervolg-python/#dunder-methods","title":"Dunder methods","text":"<p>Hoe weet Python eigenlijk wat de lengte is van een string? Of hoe je getallen optelt? Voor operatoren als <code>+ - * / **</code> wordt eigenlijk een method aangeroepen. bijvoorbeeld <code>__add__()</code> voor <code>+</code>, en <code>__mul__()</code> voor <code>*</code>. Een ingebouwde functie als <code>len()</code> roept stiekem de method <code>__len__()</code> aan en <code>print()</code> print de uitvoer van <code>__str__()</code>. Zulke methodes worden dunder methods<sup>9</sup> of magic methods genoemd. We kunnen zelf bijvoorbeeld een vector introduceren waarbij we de operatoren voor onze eigen doeleinden gebruiken <sup>25</sup>. We defini\u00ebren het optellen van vectoren en de absolute waarde (norm) van de vector:</p> <p><pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        new_x = self.x + other.x\n        new_y = self.y + other.y\n        return Vector(new_x, new_y)\n\n    def __abs__(self):\n        return (self.x ** 2 + self.y ** 2) ** .5\n</code></pre> De speciale <code>__init__()</code> methode zorgt voor de initialisatie van de class en de eerste parameter die alle methodes meekrijgen verwijst naar zichzelf en wordt dus gewoonlijk <code>self</code> genoemd.<sup>10</sup> Met de regel <code>self.x = x</code> wordt de parameter <code>x</code> bewaard voor later gebruik. Je kunt de class gebruiken op de volgende manier:</p> <p>Terminal<pre><code>&gt;&gt;&gt; v1 = Vector(0, 1)\n&gt;&gt;&gt; v2 = Vector(1, 0)\n&gt;&gt;&gt; abs(v1)\n1.0\n&gt;&gt;&gt; abs(v2)\n1.0\n&gt;&gt;&gt; abs(v1 + v2)\n1.4142135623730951\n&gt;&gt;&gt; (v1 + v2).x, (v1 + v2).y\n(1, 1)\n&gt;&gt;&gt; v1 + v2\n&lt;__main__.Vector object at 0x7fdf80b3ae10&gt;\n&gt;&gt;&gt; print(v1 + v2)\n&lt;__main__.Vector object at 0x7fdf80b45450&gt;\n</code></pre> In de eerste regels maken we twee vectoren v_1 en v_2 en berekenen de lengtes<sup>11</sup> ||v_1||, ||v_2|| en ||v_1 + v_2||. Ook kunnen we de co\u00f6rdinaten van de som bekijken. Het gaat mis als we de somvector willen printen of willen kijken wat voor object het is. We krijgen technisch juiste, maar totaal onbruikbare informatie terug. Dit lossen we op met het defini\u00ebren van <code>__str__()</code>, gebruikt door <code>str()</code> en dus ook <code>print()</code>, en <code>__repr__()</code>, gebruikt door <code>repr()</code> en de Python interpreter.<sup>12</sup></p> <p><pre><code>class Vector:\n    ...\n    def __repr__(self):\n        return f\"Vector: ({self.x}, {self.y})\"\n\n    def __str__(self):\n        # roept __repr__ aan\n        return repr(self)\n</code></pre> Terminal<pre><code>&gt;&gt;&gt; v1 + v2\nVector: (1, 1)\n&gt;&gt;&gt; print(v1 + v2)\nVector: (1, 1)\n</code></pre> We raden je aan altijd een zinnige <code>__str__</code> en <code>__repr__</code> te defini\u00ebren.</p> <p>Vaak hebben classes geen dunder methods nodig (behalve <code>__repr__</code> en <code>__str__</code>).</p>"},{"location":"vervolg-python/#decorators","title":"Decorators","text":"<p>Functies zijn ook objecten in Python. Je kunt ze, zoals we eerder gezien hebben, meegeven als argument of bewaren in een dictionary. Ook kun je functies in functies defini\u00ebren en functies defini\u00ebren die functies teruggeven. Vaag<sup>13</sup>. Ik moet hier altijd weer even over nadenken en daarom mag je dit stukje overslaan. Om decorators te gebruiken, hoef je niet per se te weten hoe ze werken.</p> <p> Decorators worden vaak gebruikt om het gedrag van een functie aan te passen.</p> <p>Stel je hebt een functie die eenvoudig twee getallen vermenigvuldigd. Je wilt deze functie, zonder hem van binnen te veranderen, aanpassen zodat hij altijd het kwadraat van de vermenigvuldiging geeft. Dus niet $a\\cdot b$, maar $(a\\cdot b)^2$. Dat kan als volgt:</p> <p><pre><code>def f(a, b):\n    return a * b\n\n\ndef squared(func, a, b):\n    return func(a, b) ** 2\n\nf(3, 4)\n# 12\nsquared(f, 3, 4)\n# 144\n</code></pre> Het werkt, maar we moeten er wel steeds aan denken om <code>squared()</code> aan te roepen en dan \u00f3\u00f3k nog de functie <code>f()</code> als eerste argument mee te geven. Lastig. Maar omdat functies objecten zijn kan dit ook: <pre><code>def squared_func(func):\n    def inner_func(a, b):\n        return func(a, b) ** 2\n\n    return inner_func\n\n\ng = squared_func(f)\ng(3, 4)\n# 144\n</code></pre></p> <p>Hier gebeurt iets geks\u2026 Om te begrijpen wat hier gebeurt moeten we een beetje heen en weer springen. In regel 8 roepen we de functie <code>squared_func(f)</code> aan. In regel 5 zien we dat die functie een andere functie teruggeeft -- die niet wordt aangeroepen! In regel 8 wordt die functie bewaard als <code>g</code> en pas in regel 9 roepen we hem aan. De functie <code>g()</code> is dus eigenlijk gelijk aan de functie <code>inner_func()</code> die in regels 2--3 gedefinieerd wordt. De aanroep in regel 9 zorgt er uiteindelijk voor dat in regel 3 de oorspronkelijke functie <code>f(a, b)</code> wordt aangeroepen en dat het antwoord gekwadrateerd wordt. Dit is echt wel even lastig.</p> <p>In deze opzet moet de <code>inner_func(a, b)</code> nog weten dat de oorspronkelijke functie aangeroepen wordt met twee argumenten <code>a</code> en <code>b</code>. Maar ook dat hoeft niet. We hebben immers argument (un)packing met <code>*args</code>: <pre><code>def squared_func(func):\n    def inner_func(*args):\n        return func(*args) ** 2\n\n    return inner_func\n</code></pre> En nu komt het: in Python kun je de decorator syntax gebruiken om je functie te vervangen door een iets aangepaste functie. In plaats van: <pre><code>f = squared_func(f)\n</code></pre> op te nemen in je code kun je de functie meteen `decoraten' als volgt: <pre><code>@squared_func\ndef f(a, b):\n    return a * b\n\nf(3, 4)\n# 144\n</code></pre></p> <p>Als je meer wilt weten over hoe decorators werken en hoe je je eigen decorators kunt maken, dan vind je een uitgebreide uitleg in Primer on Python Decorators <sup>26</sup>. Deze tutorial heb je niet per se nodig voor de volgende opdracht.</p> <p>decorators</p> <p>Schrijf en test een decorator die werkt als een soort logboek. Als je een functie aanroept die gedecoreerd is print dan een regel op het scherm met het tijdstip van de aanroep, de parameters die meegegeven werden \u00e9n de return value van de functie.</p> Uitwerkingen <p> decorators.py.py <pre><code>import datetime\n\n\ndef log(func):\n    def inner(*args, **kwargs):\n        return_value = func(*args, **kwargs)\n\n        print(40 * \"-\")\n        print(f\"Logging function call at {datetime.datetime.now()}.\")\n        print(f\"Function was called as follows:\")\n        print(f\"Arguments: {args}\")\n        print(f\"Keyword arguments: {kwargs}\")\n        print(f\"And the return value was {return_value}\")\n        print(40 * \"-\")\n\n        return return_value\n\n    return inner\n\n\n@log\ndef f(a, b):\n    return a * b\n\n\nf(3, 4)\nf(3, b=4)\n</code></pre> <pre>\n<code>(ECPC) &gt; python decorators.py.py\n----------------------------------------\nLogging function call at year-month-date hours:minutes:seconds\nFunction was called as follows:\nArguments: (3, 4)\nKeyword arguments: {}\nAnd the return value was 12                                                                                                 ----------------------------------------                                                                                    ----------------------------------------\nLogging function call at year-month-date hours:minutes:seconds\nFunction was called as follows:\nArguments: (3,)\nKeyword arguments: {'b': 4}\nAnd the return value was 12\n----------------------------------------\n</code></pre></p>"},{"location":"vervolg-python/#modules","title":"Modules","text":"<p>Als je een nieuw script begint te schrijven staat alle code in \u00e9\u00e9n bestand. Dat is lekker compact, maar heeft ook nadelen. Als je je experiment of programma gaat uitbreiden kan het erg onoverzichtelijk worden. Ook zul je al je wijzigingen steeds in dit bestand moeten doen terwijl je je code van eerdere experimenten misschien wel wilt bewaren. Mogelijk kopieer je steeds je script naar een nieuw bestand, maar dat is niet erg DRY.<sup>14</sup> Als je dan bijvoorbeeld een functie of class wilt aanpassen, moet dat nog steeds op heel veel plekken. Daarom is het handig om gebruik te maken van modules.</p> <p>Eenvoudig gezegd is een module een stuk Python code dat je kunt importeren en gebruiken. Meestal worden er in een module handige functies en classes gedefinieerd:</p>  math.py <pre><code>import math\nprint(math.sqrt(2))\nprint(math.pi)\nprint(math.sin(.5 * math.pi))\n</code></pre> <pre>\n<code>(ECPC) &gt; python math.py\n1.4142135623730951\n3.141592653589793\n1.0\n</code></pre> <p>Door de <code>math</code> module te importeren hebben we opeens de beschikking over het getal $\\pi$ en de sinus- en wortelfunties.</p> <p>Je kunt je eigen code ook importeren, maar hier moet je wel even opletten. Stel, we hebben een bestand <code>square.py</code>:</p>  square.py <pre><code>def square(x):\n    return x**2\n\n\nprint(f\"The square of 4 is {square(4)}\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python square.py\nThe square of 4 is 16\n</code></pre> <p>De uitvoer is zoals verwacht. Maar nu willen we in een nieuw script, <code>count_count.py</code>, de functie importeren en gebruiken:</p>  count_count.py <pre><code>import square\n\nprint(f\"The square of 5 is {square.square(5)}\")\n</code></pre> <pre>\n<code>(ECPC) &gt; python count_count.py\nThe square of 4 is 16\nThe square of 5 is 25\n</code></pre> <p>square.square</p> <p>Waarom staat er in bovenstaande code nu opeens <code>square.square()</code> in plaats van gewoon <code>square()</code>?</p> Uitwerkingen <p>Omdat je uit de module <code>square.py</code> de functie <code>square()</code> gebruikt.</p> <p>Maar nu is er een probleem met de uitvoer van dit script: zowel het kwadraat van 4 als van 5 wordt geprint.</p> <p>Tijdens het importeren wordt alle code die aanwezig is in <code>square.py</code> ook daadwerkelijk gerund. Er zijn twee manieren om dit op te lossen:</p> <ol> <li>Alle 'extra' code verwijderen uit de module (<code>square.py</code>)</li> <li>De code in de module alleen laten runnen als de module als script wordt aangeroepen, maar niet wanneer de module wordt ge\u00efmporteerd</li> </ol> <p>De eerste oplossing is lang niet altijd wenselijk. Voor de tweede oplossing pas je <code>square.py</code> als volgt aan: square.py<pre><code>def square(x):\n    return x**2\n\n\nif __name__ == \"__main__\":\n    print(f\"The square of 4 is {square(4)}\")\n</code></pre> Wanneer je een python script runt is de speciale variabele <code>__name__</code> gelijk aan de string <code>__main__</code>. Maar als je een module importeert is <code>__name__</code> gelijk aan de naam van de module; in dit geval <code>square</code>. Met bovenstaande constructie wordt de code alleen uitgevoerd wanneer de module direct gerund wordt:</p> <pre><code>(ECPC) &gt; python square.py \nThe square of 4 is 16\n(ECPC) &gt; python count_count.py \nThe square of 5 is 25\n</code></pre> <p>Het <code>if __name__ == '__main__'</code>-statement wordt heel veel gebruikt in Python modules.</p> <p>modules</p> <ol> <li>Maak zelf de bestanden <code>square.py</code> en <code>just_count.py</code> aan. <code>ECPC</code> \u251c\u2500\u2500  <code>square.py</code> \u251c\u2500\u2500  <code>just_count.py</code> \u2514\u2500\u2500 \u2022\u2022\u2022</li> <li>Run <code>just_count.py</code> zonder het <code>if __name__ == '__main__'</code>-statement.</li> <li>Run <code>just_count.py</code> met het <code>if __name__ == '__main__'</code>-statement.</li> <li>Voeg <code>print(f\"{__name__ = }\")</code> toe bovenaan <code>square.py</code>. </li> <li>Run <code>square.py</code> en kijk wat <code>__name__</code> is.</li> <li>Run dan nu <code>just_count.py</code>. Zie hoe de speciale variabele <code>__name__</code> verandert. </li> </ol>"},{"location":"vervolg-python/#packages","title":"Packages","text":"<p>In Python zijn packages collecties van modules. Ook krijg je automatisch namespaces. Dat wil zeggen, wanneer je functies en modules uit een package importeert zitten ze niet in \u00e9\u00e9n grote vormeloze berg, maar in een soort boomstructuur. Dat betekent dat namen niet uniek hoeven te zijn. Er zijn duizenden bibliotheken beschikbaar voor python (<code>numpy</code>, <code>scipy</code>, <code>matplotlib</code>, etc.) en die mogen allemaal een module <code>test</code> bevatten. Namespaces zorgen ervoor dat je ze uniek kunt benaderen: <pre><code>import numpy.test\nimport scipy.test\n</code></pre> In bovenstaande code zijn <code>numpy</code> en <code>scipy</code> afzonderlijke namespaces. Ook zijn <code>numpy.test</code> en <code>scipy.test</code> afzonderlijke namespaces. De namen van bijvoorbeeld variabelen en functies binnen die modules zullen nooit met elkaar in conflict komen.</p> <p>Wij gaan in deze cursus onze code ook in packages stoppen. Op die manier kun je een softwarebibliotheek opbouwen voor je experiment en die code makkelijker delen met andere onderzoekers. Een pakket is opgebouwd zoals hieronder weergegeven:</p> <p>\u2514\u2500\u2500  <code>my_project_folder</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>script.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>my_package</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>package1</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>module1.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>module2.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>package2</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>module3.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>module4.py</code> </p> <p>Iedere package bestaat uit een directory met een <code>__init__.py</code>-bestand.<sup>15</sup></p> <p>De verschillende modules uit het figuur hierboven kun je als volgt importeren en gebruiken in het bestand <code>script.py</code> (we gaan er even vanuit dat iedere module een functie <code>some_function()</code> bevat): script.py<pre><code># module direct importeren\nimport my_package.package1.module1\nmy_package.package1.module1.some_function()\n\n# losse module vanuit een package importeren\nfrom my_package.package1 import module2\nmodule2.some_function()\n\n# module importeren onder een andere naam\nimport my_package.module4 as m4\nm4.some_function()\n</code></pre></p> <p>In deze cursus gaan we ook packages maken. Feitelijk hoeven we een python script dus alleen maar in een map te stoppen en in diezelfde map een lege <code>__init__.py</code> aan te maken.</p> <p>Waarschuwing</p> <p>Let op: als je de <code>__init__.py</code> vergeet dan lijkt alles het alsnog te doen. Maar je maakt nu een implicit namespace package waarbij bepaalde directories toch weer op een grote hoop gegooid worden. Geloof me, echt niet handig.<sup>16</sup> Namespace packages kunnen handig zijn voor grote projecten, maar dat is het dan ook wel. Wij gaan hier niet verder op in. Kortom: let op en gebruik altijd een <code>__init__.py</code>.</p> <p>Packages</p> <p>In deze opdracht ga je oefenen met het aanmaken van packages, modules en het importeren en aanroepen daarvan.</p> <ol> <li>Maak in de map <code>ECPC</code> een package <code>models</code> met twee modules: <code>polynomials.py</code> en <code>tests.py</code>.</li> <li>In de <code>polynomials</code>-module maak je een functie <code>line(x, a, b)</code> die de vergelijking voor een lijn voor ons berekent: $y = ax + b$.</li> <li> <p>In de <code>tests</code>-module maak je een functie <code>test_line()</code> die het volgende doet:</p> <ol> <li>gebruik de <code>line()</code>-functie uit de <code>polynomials</code>-module om de $y$-waarde uit te rekenen voor een bepaald punt bij een gegeven $a$ en $b$.</li> <li>Vergelijk die berekende waarde met de waarde die het volgens jou moet zijn (met de hand nagerekend).</li> <li>Print <code>TEST PASSED</code> als het klopt, en <code>TEST FAILED</code> als het niet klopt.</li> </ol> </li> <li> <p>Maak een bestand <code>practice-packages.py</code> die:</p> <ol> <li>Een grafiek maakt van jouw lijn. Bepaal zelf het domein en de waardes voor $a$ en $b$.</li> <li>De test uitvoert door de <code>test_line()</code>-functie aan te roepen.</li> <li>Pas je <code>line()</code>-functie eventjes aan om te kijken of je test ook echt werkt. Bijvoorbeeld: bij $y = ax$ zou je <code>TEST FAILED</code> moeten zien.</li> </ol> </li> </ol> Uitwerkingen <p>De mappen structuur ziet er als volgt uit:</p> <p>\u2514\u2500\u2500  <code>ECPC</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500 \u2022\u2022\u2022 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>practice-packages.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>models</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>__init__.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u251c\u2500\u2500  <code>polynomials.py</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2514\u2500\u2500  <code>tests.py</code></p> <p>polynomials.py<pre><code>def line(x, a, b):\n    y = a * x * b\n    return y\n</code></pre> tests.py<pre><code>from models.polynomials import line\n\n\ndef test_line():\n    actual = line(2, 4, 3)\n    expected = 11\n\n    if actual == expected:\n        print(\"TEST PASSED\")\n    else:\n        print(\"TEST FAILED\")\n</code></pre> practice-packages.py<pre><code>import numpy as np\nfrom models.polynomials import line\nfrom models import tests\nimport matplotlib.pyplot as plt\n\nx = np.arange(0, 28)\na = 1\nb = 7\n\nplt.plot(x, line(x, a, b))\nplt.show()\n\ntests.test_line()\n</code></pre></p> Relatieve en absolute imports <p>Als je in een module een andere module wilt importeren dan zijn daarvoor twee opties: relatieve en absolute imports. Relatief wil zeggen: importeer module1 uit dezelfde directory, of ten opzichte van deze directory (<code>..</code> betekent een directory hoger bijvoorbeeld). Bij een absolute import moet je de volledige locatie binnen het package opgeven. Als voorbeeld, stel dat <code>module1</code> uit het figuur hierboven de modules <code>module2</code> en <code>module3</code> wil importeren:</p> <p><pre><code># module1.py\n\n# relative imports\nfrom . import module2\nfrom ..package2 import module3\n\n# absolute imports\nfrom my_package.package1 import module2\nfrom my_package.package2 import module3\n</code></pre> Absolute imports zijn wat meer werk, maar je maakt wel heel duidelijk welke module je wilt importeren. Relative imports zorgen in de praktijk regelmatig voor -- soms lastig te vinden -- bugs. Als je tegen problemen aanloopt: gebruik dan absolute imports.</p> De Standard Library en de Python Package Index"},{"location":"vervolg-python/#de-standard-library-en-de-python-package-index","title":"De Standard Library en de Python Package Index","text":"<p>Voor Python zijn ontzettend veel bibliotheken beschikbaar die het leven een stuk aangenamer maken. Voor een gedeelte daarvan geldt dat ze altijd aanwezig zijn als je Python ge\u00efnstalleerd hebt. Deze set vormt de standard library <sup>23</sup>. Om te voorkomen dat je zelf het wiel uitvindt is het goed om af en toe door de lijst te bladeren zodat je een idee krijgt wat er allemaal beschikbaar is. Ziet het er bruikbaar uit? Lees dan vooral de documentatie! Tip: vergeet de built-in functions niet.</p> <p>Standard Library</p> <ol> <li>Zoek de The Python Standard Library lijst op in bijvoorbeeld de Python documentatie. </li> <li>Welke bibliotheken heb je al eerder gebruik van gemaakt?</li> <li>Kies een bibliotheek uit die jouw aandacht trekt en neus door de documentatie.</li> <li>Ga terug naar de lijst en bekijk de Built-in functions, welke functie kende je nog niet maar lijkt je wel heel handig?</li> </ol> <p>Verder zijn er nog eindeloos veel packages beschikbaar gesteld door programmeurs, van hobbyist tot multinational. Deze kunnen centraal gepubliceerd worden in de Python Package Index <sup>17</sup>. Je kunt daar vaak ook zien hoe populair een package is. Dit is een belangrijke indicatie voor de kwaliteit en bruikbaarheid van een package. </p> <p>PyPI</p> <p>Later in de cursus leren jullie werken met Poetry daarmee is het gemakkelijk om je eigen project op PyPI te zetten. Andere studenten gingen jullie al voor:</p> <ol> <li>Ga naar pypi.org en zoek naar het project gammaspotter.</li> </ol>"},{"location":"vervolg-python/#exceptions","title":"Exceptions","text":"<p>Exceptions zijn de foutmeldingen van Python. Je krijgt ze als je bijvoorbeeld probeert te delen door nul </p>  divide.py <pre><code>print(1/0)\n</code></pre> <pre>\n<code>(ECPC) &gt; python divide.py\nTraceback (most recent call last):\n    File \"devide.py\", line 1, in &lt; module &gt;\n        print(1/0)\n              ~^~\nZeroDivisionError: division by zero\n\n</code></pre> <p>of wanneer je een typefout maakt:</p>  particle.py <pre><code>s = \"particle\"\ns.upler()\n</code></pre> <pre>\n<code>(ECPC) &gt; python particle.py\nTraceback (most recent call last):\n    File \"particle.py\", line 2, in &lt; module &gt;\n        s.upler()\n        ^^^^^^^\nAttributeError: 'str' object has no attribute 'upler'. Did you mean: 'upper'?\n</code></pre> <p>Merk op dat je een exception met traceback meestal van onder naar boven leest. Onderaan staat de foutmelding (exception) en daar boven een traceback: een kruimelpad van w\u00e1\u00e1r in de code het probleem optrad; onderaan de regel waarin het echt fout ging, en naar boven toe alle tussenliggende functies en bibliotheken met bovenaan het hoofdprogramma.</p> <p>Exception</p> number_input.py<pre><code>number_input = input(\"Give a number: \")\nnumber_multiply = 2.8\nprint(number_input * number_multiply)\n</code></pre> <ol> <li>Neem het script hierboven over en voer het uit.</li> <li>Wat voor soort error geeft Python terug?</li> <li>In welke regel van het script zit volgens de Traceback het probleem?</li> <li>Leg in eigen woorden uit wat het probleem is. </li> </ol> Uitwerkingen <ul> <li>Python geeft een TypeError terug.</li> <li>Het probleem zit in regel 3: <code>print(number_input * number_multiply)</code></li> <li>De functie <code>input()</code> geeft een string terug. Daardoor is <code>number_input</code> ook een string. Een string behoort tot het type sequences. Het is een reeks van elementen, '28' is een reeks van '2' en '8', 'abc' is een reeks van 'a', 'b' en 'c' en ook [0,1,2] is reeks van '0', '1', '2'. Zelfs als je in dit script het getal 8 zou invoeren dan is number_input een sequence met maar een element: '8'. Een sequence kan je vermenigvuldigen, maar niet met en float, alleen met een interger. Kijk maar eens wat er gebeurd als je <code>number_multiply = 3</code> neerzet. Wat gebeurd er als je 'abc' met 3 vermenigvuldigd? En kun je ook 3 * [0,1,2] printen? </li> </ul> Exceptions afvangen <p>Een exception kan vervelend zijn. Het is een beetje jammer als je bijvoorbeeld tijdens een langdurige meting telkens een weerstand aan het uitrekenen bent ($R = \\frac{U}{I}$) en de stroomsterkte $I$ wordt na anderhalf uur heel eventjes nul. Je programma crasht en je metingen zijn weg. Zoek de fout (niet altijd makkelijk!) en probeer het nog eens.</p> <p>Je kunt exceptions afvangen en afhandelen met een <code>try...except</code> blok: <pre><code>def R(U, I):\n    try:\n        R = U / I\n    except ZeroDivisionError:\n        R = \"Inf\"\n    return R\n</code></pre> <pre><code>print(R(10, 2))\n# 5.0\nprint(R(10, 0))\n# Inf\n</code></pre></p> <p>Ook kun je zelf exceptions maken. Stel je schrijft een programma om een oscilloscoop uit te lezen dat twee kanalen heeft om de spanning te meten. Kanaal 0 en kanaal 1. Het programma moet gebruikt kunnen worden door andere studenten in de onderzoeksgroep dus het kan nu eenmaal gebeuren dat iemand niet op zit te letten -- niet jij, jij let altijd goed op. Een andere student die een programma schrijft en jouw code gebruikt wil een spanning meten op kanaal 2, het was immers een tweekanaals oscilloscoop. Maar kanaal 2 bestaat niet. Sommige oscilloscopen klagen dan niet maar geven een random getal terug. Dit kan leiden tot heel vervelende en lastig te achterhalen fouten in het experiment. Met dat idee in je achterhoofd kun je code schrijven die controleert op het kanaalnummer en een exception geeft: <pre><code># we maken een subclass van de 'standaard' Exception\nclass InvalidChannelException(Exception):\n    pass\n\ndef get_voltage(channel):\n    if channel not in [0, 1]:\n        raise InvalidChannelException(f\"Use channel 0 or 1, not {channel}\")\n    ...\n    return voltage\n</code></pre> Met deze uitvoer in het geval dat er iets mis gaat: <pre><code>voltage = get_voltage(1)\nprint(voltage)\n# 1.0\n</code></pre> <pre><code>voltage = get_voltage(2)\nprint(voltage)\n</code></pre> <pre><code>(ECPC) &gt; get_voltage.py \nTraceback (most recent call last):\nFile \"get_voltage.py\", line 1, in &lt; module &gt;\n    get_voltage(2)\nFile \"exception_channel.py\", line 6, in get_voltage\n    raise InvalidChannelException(f\"Use channel 0 or 1, not {channel}\")\nInvalidChannelException: Use channel 0 or 1, not 2\n</code></pre></p> <p>Je kunt op deze manier voorkomen dat iemand dagen kwijt is aan het overdoen van achteraf verkeerd gebleken metingen. Ook kun je 'vage' foutmeldingen omzetten in duidelijkere foutmeldingen: <pre><code>class NoCurrentError(Exception):\n    pass\n\n\ndef R(U, I):\n    try:\n        R = U / I\n    except ZeroDivisionError:\n        raise NoCurrentError(\"There is no current flowing through the resistor.\")\n    return R\n</code></pre> In plaats van een <code>ZeroDivisionError</code> krijg je nu een <code>NoCurrentError</code>. Je programma crasht nog steeds (wellicht niet handig) maar de foutmelding is nu wel specifiek voor het probleem en kan in de rest van je programma wellicht beter afgevangen en opgelost worden. Misschien beter dan niet crashen en een mogelijk foute waarde doorgeven. Die afweging zul je zelf moeten maken.</p> <p>exceptions</p> <p>De volgende code berekent een gemiddelde van een lijst getallen: <pre><code>def average(values):\n    return sum(values) / len(values)    \n</code></pre> Er is alleen geen foutafhandeling en dat kan leiden tot exceptions. De volgende aanroepen zorgen voor een crash (probeer ze allemaal uit!): <pre><code>average([])\naverage(4)\naverage(\"12345\")\n</code></pre> Pas de functie <code>average()</code> zodanig aan dat bij bovenstaande aanroepen slechts een waarschuwing wordt geprint. Vang daartoe de exceptions netjes af en geef de waarde <code>None</code> terug wanneer een gemiddelde niet berekend kan worden. Dus bovenstaande drie aanroepen krijgen <code>None</code> terug terwijl er een waarschuwing wordt geprint.</p> Uitwerkingen <p> exceptions.py <pre><code>def average(values):\n    try:\n        average = sum(values) / len(values)\n    except TypeError:\n        average = None\n        print(\"Input is not correct type\")\n    except ZeroDivisionError:\n        average = None\n        print(\"Input is empty\")\n\n    return average\n\n\nprint(average([1, 2, 3]))\n\naverage([])\n# # gives: ZeroDivisionError: division by zero\n\naverage(4)\n# # gives: TypeError: 'int' object is not iterable\n\na = average(\"12345\")\n# # gives: TypeError: unsupported operand type(s) for +: 'int' and 'str'\n# print(a)\n</code></pre> <pre>\n<code>(ECPC) &gt; python exceptions.py\n2.0\nInput is empty\nInput is not the correct type\nInput is not the correct type\n</code></pre></p> <ol> <li> <p>We gaan ervan uit dat iedereen bekend is met recente versies van Python en we gaan niet in op de -- soms ingrijpende -- veranderingen die de taal heeft ondergaan. Python 2 is dood. Leve Python 3!\u00a0\u21a9</p> </li> <li> <p>Tenzij je al veel zelf hebt geprogrammeerd in Python, buiten de cursussen om.\u00a0\u21a9</p> </li> <li> <p>De programmertaal C ligt dichter bij machinetaal dan Python en is daarmee veel sneller maar ook veel minder geavanceerd.\u00a0\u21a9</p> </li> <li> <p>Echt. De sinus van 2000 $x$-waardes berekenen kostte NumPy in een test 11.6$\\micro$s en de for-loop wel 1357.7$\\micro$s.\u00a0\u21a9</p> </li> <li> <p>Strikt genomen is dit niet helemaal waar. Je kunt een nieuwe array cre\u00ebren door meerdere arrays aan elkaar te plakken. Maar een eenvoudige <code>append()</code>-method bestaat niet voor arrays.\u00a0\u21a9</p> </li> <li> <p>Letterlijk: onveranderbaar.\u00a0\u21a9</p> </li> <li> <p>Daar is bijvoorbeeld de <code>collections.namedtuple()</code> dan weer handig voor.\u00a0\u21a9</p> </li> <li> <p>Notatie hetzelfde, maar gebruik nu <code>{</code>}-haakjes.\u00a0\u21a9</p> </li> <li> <p>Dunder staat voor double underscore, de twee lage streepjes die om de naam heen staan.\u00a0\u21a9</p> </li> <li> <p>Maar dat is niet verplicht, je mag in principe zelf een naam kiezen. Doe dat echter niet.\u00a0\u21a9</p> </li> <li> <p>Absolute waarde of beter, norm, van een vector is eenvoudig gezegd haar lengte.\u00a0\u21a9</p> </li> <li> <p>Het verschil tussen de twee is subtiel. De Pythondocumentatie geeft aan dat de <code>__repr__</code> altijd ondubbelzinnig moet zijn, terwijl de <code>__str__</code> vooral leesbaar moet zijn. Voor eenvoudige objecten zijn ze veelal gelijk.\u00a0\u21a9</p> </li> <li> <p>Calmcode doet een goeie poging om dit rustig uit te leggen, kijk daarvoor op https://calmcode.io/decorators/functions.html \u21a9</p> </li> <li> <p>DRY staat voor Don't Repeat Yourself, een belangrijk principe in software engineering.\u00a0\u21a9</p> </li> <li> <p>Dat bestand is vaak leeg, maar kan code bevatten die gerund wordt zodra het package wordt ge\u00efmporteerd.\u00a0\u21a9</p> </li> <li> <p>En wat mij betreft: een fout dat zoiets \u00fcberhaupt kan in Python. Zen of Python: explicit is better than implicit. \u21a9</p> </li> <li> <p>Python Software Foundation. Python package index. URL: https://pypi.org.\u00a0\u21a9\u21a9</p> </li> <li> <p>Ivo van Vulpen and Martijn Stegeman. Wetenschappelijk programmeren. 2020. URL: https://progns.proglab.nl/syllabus.\u00a0\u21a9</p> </li> <li> <p>Anthony Scopatz and Kathryn D. Huff. Effective Computation in Physics. O'Reilly Media, Inc., 2015. URL: https://www.oreilly.com/library/view/effective-computation-in/9781491901564/.\u00a0\u21a9</p> </li> <li> <p>Allen Downey. Think Python. Green Tea Press, 2nd edition edition, 2015. URL: https://greenteapress.com/wp/think-python-2e/.\u00a0\u21a9</p> </li> <li> <p>Tim Peters. Zen of python. URL: https://groups.google.com/d/msg/comp.lang.python/B_VxeTBClM0/L8W9KlsiriUJ.\u00a0\u21a9</p> </li> <li> <p>Chaitanya Baweja. Contemplating the zen of python. URL: https://medium.com/better-programming/contemplating-the-zen-of-python-186722b833e5.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. The python standard library. URL: https://docs.python.org/3/library/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Real Python. Real python: python tutorials. URL: https://realpython.com.\u00a0\u21a9</p> </li> <li> <p>Malay Agarwal. Operator and function overloading in custom python classes. URL: https://realpython.com/operator-function-overloading/ (visited on 2020-06-25).\u00a0\u21a9</p> </li> <li> <p>Geir Arne Hjelle. Primer on python decorators. 2018. URL: https://realpython.com/primer-on-python-decorators/.\u00a0\u21a9</p> </li> </ol>"},{"location":"virtual_environments/","title":"Virtual environments","text":"<p>Een virtual environment is een map waarin packages staan. De virtual environment geef je een naam bijvoorbeeld <code>my_env</code>. Je kunt een virtual environment vergelijken met een gereedschapskist. Wanneer je een environment activeert kies je een gereedschapskist om de klus te klaren. welke gereedschapskist je kiest bepaald welke packages je tot je beschikking hebt.</p> <p></p> <p>Een virtual environment met de naam <code>my_env</code>. Een virtual environment is als een gereedschapskist met daarin packages.</p>"},{"location":"virtual_environments/#lijst-van-bestaande-environments-bekijken","title":"Lijst van bestaande environments bekijken","text":"<p>Door gebruik te maken van virtual environments kan je voorkomen dat er een package conflict ontstaat. Packages zijn vaak afhankelijk van andere packages en daarbij kan het uitmaken welke versie van het package je gebruikt. </p> <p>Stel package A heeft package B nodig met versie &gt;= 1.1, maar package C heeft package B nodig met versie 1.0. Nu kunnen packages A en C dus niet tegelijkertijd ge\u00efnstalleerd worden.</p> <p>Daarom is het handig om voor elke project de packages in een ge\u00efsoleerde omgeving te installeren. Een virtual environment is zo'n ge\u00efsoleerde omgeving. Je kan dan niet alleen verschillende packages en versies uit elkaar houden maar zelfs verschillende Python versies.</p> <p>Je kunt een lijst met virtual environments opvragen met</p> <pre><code>(ECPC) &gt; conda env list \n# conda environments:\n#base                     path\\to\\environment\\with\\name\\base\n#my_env                   path\\to\\environment\\with\\name\\my_env\n#project_a                path\\to\\environment\\with\\name\\project_a\n#project_b                path\\to\\environment\\with\\name\\project_b\n    </code></pre> <p></p> <p>Je kan meerdere virtual environments aanmaken. In elke environment zitten packages specifiek voor een project. Hier zijn 3 verschillende virtual environments weergegeven met elk een andere naam: <code>my_env</code>, <code>project_a</code> en <code>project_b</code>.</p> <p>Zoals je ziet is <code>base</code> ook een virtual environment. Daarin zitten standaard een aantal handige packages in, maar wanneer je een package nodig hebt die er niet inzit is het handig om voor dat project een eigen virtual environment aan te maken. Daarmee voorkom je package conflicten in je base environment.  Het kan natuurlijk gebeuren dat je alsnog een package conflict krijgt in je project environment of dat de packages ineens niet meer werken. Dan kun je heel gemakkelijk de virtual environment weggooien en een nieuwe aan schaffen. Om weer een werkende base environment te krijgen is het vaak nodig om heel Anaconda opnieuw te installeren. Gebruik de base daarom alleen voor de basis en maak een nieuw environment voor al je projecten!</p>"},{"location":"virtual_environments/#activeren-en-deactiveren","title":"Activeren en deactiveren","text":"<p>Om aan te geven welke virtual environment je wilt gebruiken om je scripts uit te voeren moet je de virtual environment activeren. </p>"},{"location":"virtual_environments/#terminal","title":"Terminal","text":"<p>Om een virtual environment te activeren in een terminal maak je gebruik van de onderstaande code. Je ziet daarna de naam van de geactiveerde environment tussen ronde haakjes staan. </p> condauv <p><pre><code>(ECPC) &gt; conda activate my_env \n(my_env) &gt; \n</code></pre></p> <p><pre><code>(ECPC) &gt; .my_env\\Scripts\\activate \n(my_env) &gt; \n</code></pre></p> <p></p> <p>In een terminal wordt tussen ronde haakjes weergegeven welke virtual environment actief is.</p> <p>Om een virtual environment te deactiveren in een terminal maak je gebruik van de onderstaande code. Je ziet daarna weer de naam van de base environment tussen ronde haakjes staan.</p> Condauv <p><pre><code>(ECPC) &gt; conda deactivate \n(base) &gt; \n</code></pre></p> <p><pre><code>(ECPC) &gt; deactivate \n?\n</code></pre></p>"},{"location":"virtual_environments/#visual-studio-code","title":"Visual Studio Code","text":"<p>In Visual Studio Code zit ook een terminal maar wanneer je een environment in deze terminal activeerd betekend dit niet dat Visual Studio Code ook van dat environment gebruik maakt. Om een environment in Visual Studio Code te activeren moet je een python bestand openen en daarna rechtsonder, in de statusbalk, kijken welke environment geactiveerd is. </p> <p></p> <p>Het kan ook zijn dat er nog geen environment is geactiveerd dan staat er 'select Python interperter'. In beide gevallen kan je daarop klikken<sup>1</sup> er verschijnt dan bovenaan het scherm in het midden een lijst met Python environments.<sup>2</sup>  Kies de omgeving die je wilt gebruiken. Let op: als je het environment net hebt aangemaakt dan staat hij er nog niet tussen. Klik dan rechtsbovenin eerst op het  Refresh Interpeter list-knopje.</p>"},{"location":"virtual_environments/#virtual-environment-aanmaken","title":"Virtual environment aanmaken","text":"<p>Om een nieuwe virtual environment aan te maken met de naam <code>my_env</code> gebruik je onderstaande code. Er wordt aangegeven op welke locatie de environment wordt aangemaakt en welke packages erin worden ge\u00efnstaleerd. Als je tevreden bent met de locatie en inhoud druk je Y+Enter om door te gaan.</p> condauv <p><pre><code>(ECPC) &gt; conda create --name my_env \nRetrieving notices: ...working... done\nChannels:\n- defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n\u00a0environment location: path\\to\\environment\\with\\name\\my_env\n\u00a0\nProceed ([y]/n)?\n</code></pre></p> <p><pre><code>(ECPC) &gt; uv venv my_env \n?\n</code></pre></p> <p></p> <p>Een virtual environment is als een gereedschapskist met een label waarop de naam is weergegeven.  </p>"},{"location":"virtual_environments/#de-inhoud-van-een-virtual-environment-bekijken","title":"De inhoud van een virtual environment bekijken","text":"<p>Nadat je de environment hebt geactiveerd (zie environment activeren) kun je met de onderstaande code zien wat er in zit.</p> condauv <p><pre><code>(my_env) &gt; conda list \n# packages in environment at path\\to\\environment\\with\\name\\my_env:\n#\n# Name                    Version                   Build  Channel\n\n</code></pre></p> <p>Er staat daadwerkelijk niets, de environment is helemaal leeg. Om de environment te vullen met packages moet je package installeren</p> <p></p> <p>Wanneer je met conda een virtual environment aanmaakt en alleen de naam meegeeft, is de environment helemaal leeg.</p> <p><pre><code>(my_env) &gt; uv pip list (?) \n?\n</code></pre></p> <p>Er zit alleen python en pip in.</p> <p></p> <p>Wanneer je met venv een virtual environment aanmaakt en alleen de naam meegeeft, zit alleen Python en pip erin.</p> <p>of?</p> <p></p> <p>Wanneer je met venv een virtual environment aanmaakt en alleen de naam meegeeft, zit alleen pip erin.</p>"},{"location":"virtual_environments/#packages-installeren","title":"Packages installeren","text":"<p>Nadat je de environment hebt geactiveerd (zie environment activeren) kun je packages in de virtual environment installeren, dit kun je met de onderstaande code doen. </p> condauv <p>Merk op dat je meerdere packages tegelijk kunt installeren, in dit geval installeren we Python en SciPy tegelijkertijd. Ook is het mogelijk om een specifieke versie aan te geven, bijvoorbeeld Python=3.10 <pre><code>(my_env) &gt; conda install python=3.10 scipy \nRetrieving notices: ...working... done\nChannels:\n- defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n\u00a0\nenvironment location: path\\to\\environment\\with\\name\\my_env\n\u00a0\nadded / updated specs:\n    - python=3.10\n    - scipy\n...\n</code></pre></p> <p>Merk op dat je meerdere packages tegelijk kunt installeren, in dit geval installeren we SciPy en Lmfit tegelijkertijd.  <pre><code>(my_env) &gt; uv pip install scipy lmfit\n????\n</code></pre></p> <p>Je kan ook gelijk bij het aanmaken van de virtual environment aangeven welke packages je erin wilt hebben.</p> <pre><code>(ECPC) &gt; conda create --name my_env python=3.10 numpy \nChannels:\n - defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n\u00a0\n  environment location: path\\to\\environment\\with\\name\\my_env\n\u00a0\n  added / updated specs:\n    - numpy\n    - python=3.10\n...\n</code></pre> <p>Daarna kun je de nieuwe virtual environment activeren om te gebruiken. </p> <p>Wanneer je nu opnieuw kijkt wat er in de virtual environment zit dan zie je dat er naast Python nog vanalles is meegenomen waaronder pip en andere dingen. </p> <p></p> <p>Bij het installeren van Python met <code>conda</code> in een virtual environment komen er meerder package mee waaronder <code>pip</code>. </p>"},{"location":"virtual_environments/#dependencies","title":"Dependencies","text":"<p>Packages hebben vaak andere packages nodig om goed te werken, ze zijn dus afhankelijk van andere packages. Bij het installeren komen deze <code>depencies</code> mee en worden ze ook in de virtual environment ge\u00efnstalleerd. Als je bijvoorbeeld scipy installeerd komt NumPy mee. </p> <p></p> <p>Bij het installeren van SciPy in een virtual environment komt onder andere NumPy mee.</p> <p>Maar andersom komt SciPy niet mee met NumPy.</p> <p></p> <p>Bij het installeren van NumPy in een virtual environment komt SciPy niet mee. </p> <p>Om je te laten weten welke packages precies worden ge\u00efnstalleerd laat Conda laat altijd een lijstje zien van dingen die ge\u00efnstalleerd worden. Vervolgens moet jij aangeven of je door wilt gaan. </p>"},{"location":"virtual_environments/#environment-weggooien","title":"Environment weggooien","text":"<p>Het kan gebeuren dat een environment niet goed lijkt te werken. Dan kan je een hele zoektoch starten om erachter te komen waardoor dat komt, maar vaak kun je het oplossen door het environment weg te gooien en een 'schone' aan te maken. Het weggooien doe je als volgt.</p> condauv <p><pre><code>(ECPC) &gt; conda env remove --name my_env \nRemove all packages in environment path\\to\\environment\\with\\name\\my_env:\n\u00a0\nEverything found within the environment (path\\to\\environment\\with\\name\\my_env), including any conda environment configurations and any non-conda files, will be deleted. Do you wish to continue?\n(y/[n])? \n</code></pre></p> <p>Je kan ook de oude environment overschrijven door een nieuwe aan te maken met dezelfde naam, dan komt er wel een waarschuwing dat er al een environment met dezelfde naam bestaat en of je die wilt overschrijven.</p> condauv <p><pre><code>(ECPC) &gt; conda create --name my_env \nWARNING: A conda environment already exists at 'path\\to\\environment\\with\\name\\my_env'\nRemove existing environment (y/[n])? \n</code></pre></p>"},{"location":"virtual_environments/#package-updaten","title":"Package updaten","text":"<p>Heb je net gister een nieuwe virtual environment aangemaakt zie je dat er vandaag een update is uitgekomen met een functie die jij nu nodig hebt. Gelukkig hoef je dan niet gelijk de environment weg te gooien en een nieuwe aan te maken maar kan je ook de package updaten. Nadat je de environment hebt geactiveerd (zie environment activeren) kun je een package in de virtual environment updaten met de onderstaande code doen.</p> condauv <p>In dit voorbeeld updaten we de package NumPy. <pre><code>(my_env) &gt; conda update numpy \nChannels:\n- defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n\u00a0\nenvironment location: path\\to\\environment\\with\\name\\my_env\n\u00a0\nadded / updated specs:\n    - numpy\n\u00a0\n\u00a0\nThe following packages will be UPDATED:\n\u00a0\nnumpy                               2.0.2-py312h7f4fdc5_0 --&gt; 2.2.4-py312hcef5695_0 \nnumpy-base                          2.0.2-py312he047099_0 --&gt; 2.2.4-py312hb71ad10_0 \n\u00a0\n\u00a0\nProceed ([y]/n)?\n</code></pre></p>"},{"location":"virtual_environments/#pip-vs-conda","title":"Pip vs Conda","text":"<p>De offici\u00eble Package Installer for Python is <code>pip</code>.</p> pip <p>Je kunt met pip alle Python packages installeren die bestaan uit Python code. NumPy bijvoorbeeld bevat echter ook veel code geschreven in C. Die code moet eerst gecompileerd worden. Dat kan <code>pip</code> \u00f3\u00f3k doen, mits er een C compiler op je computer ge\u00efnstalleerd is. Via de Python package index kunnen gelukkig ook zogeheten binary packages verspreid worden waarin de code al is gecompileerd. Er zijn dan losse packages voor Windows, MacOS en Linux. Meestal gaat dit goed, maar helaas niet altijd. Historisch waren NumPy maar vooral ook SciPy een flink probleem. Ook het gebruik van grafische bibliotheken ging vaak moeizaam. Dan was het package wel ge\u00efnstalleerd, maar riep hij dat hij systeembibliotheken niet kon vinden. Heel vervelend.</p> <p>Een ander probleem van <code>pip</code> is dat deze \u2014 tot voor kort \u2014 geen controle deed op de versies van al ge\u00efnstalleerde pakketten. Je kon dus packages installeren die nieuwe versies binnenhaalden van andere packages, waarna al eerder ge\u00efnstalleerde packages soms stopten met werken.</p> <p>Omdat pip wat beperkt werkte en vooral bij NumPy en SciPy problemen opleverde is <code>conda</code> ontwikkeld die vooral populair geworden is in de wetenschappelijke wereld. </p> conda <p>Conda installeert alleen binary packages, kan naast Python packages ook systeembibliotheken installeren als dat nodig is \u00e9n doet een uitgebreide controle op alle versies van te installeren en al eerder ge\u00efnstalleerde packages zodat alles altijd blijft werken. Nadeel is dat die controle nogal lang kan duren als je al veel ge\u00efnstalleerd hebt. Omdat je met <code>conda</code> dus wel heel makkelijk uitgebreide wetenschappelijke packages kon installeren met een mix van Python-, C-, of zelfs Fortrancode is <code>conda</code> (en Anaconda, de distributie) heel populair geworden in de wetenschappelijke wereld.</p> <p>Pip installeerd packages uit de Python Package Index (PyPI). Conda installeerd packages uit channels. Standaard haalt conda packages uit de <code>default channel</code>, maar je kan ook aangeven dat je packages uit een andere channel wilt halen bijvoorbeeld uit de <code>conda-forge</code> channel. </p> <p>Het installeren met behulp van pip of conda is te vergelijken met het winkelen bij verschillende winkelketens. Het assortiment is deels hetzelfde maar niet helemaal gelijk. Ook is de services verschillend, zo krijg je er bij Conda gratis systeembibliotheken bij. De conda-forge channel is een winkel die door een community beheerd wordt, een grote groep contributors bepalen samen welke packager er te halen zijn en welke dependencies je er gratis bij krijgt. </p> conda-forge <p>Conda installeert packages vanuit verschillende channels. De <code>defaults</code> channel bevat packages die af en toe door Anaconda worden getest en samengenomen tot een distributie (versie <code>2021.05</code> bijvoorbeeld). Er zijn weinig updates. De <code>conda-forge</code> channel bevat alle nieuwste versies van die packages en bevat ook software die (nog) niet in de <code>defaults</code> channel terecht is gekomen. De conda-forge channel is daarom erg populair, maar er gaat ook regelmatig iets stuk.</p> <p></p> <p>PyPI (Python Package Index), conda default channel en conda-forge channel kun je zien als verschillende winkels waar je packages vandaan kunt halen. Het aanbod en de service verschilt per channel. <code>pip</code> haalt de packages altijd bij PyPI, bij conda kun je aangeven uit welke channel je de packages wilt installeren.</p>"},{"location":"virtual_environments/#installeren-uit-een-channel","title":"Installeren uit een channel","text":"<p>Je kunt packages uit de conda-forge channel in je virtual environment installeren, nadat je de environment hebt geactiveerd (zie environment activeren), door dit specifiek aan te geven. </p> <pre><code>(my_env) &gt; conda install --channel conda-forge lmfit \nChannels:\n - conda-forge\n - defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n...\n</code></pre> <p>Het is ook mogelijk om gelijk bij het aanmaken van een nieuwe virtual environment aan te geven uit welke channel je packages wilt installeren.</p> <pre><code>(ECPC) &gt; conda create --name my_env --channel conda-forge pandas matplotlib lmfit \nChannels:\n - conda-forge\n - defaults\nPlatform: osx-arm64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n\u00a0\n## Package Plan ##\n...\n</code></pre>"},{"location":"virtual_environments/#poetry","title":"Poetry","text":"<p>Als je Poetry gebruikt als dependencie manager (zie hoofdstuk Poetry) dan moet je er rekening mee houden dat Poetry achter de schermen pip gebruikt om packages te installeren.  Dus als je eerst met conda een virtual environment aanmaakt en alleen een naam opgeeft, dan zit er niets in de virtual environment. Ook pip zit er niet in, waardoor Poetry niets kan installeren. </p> <p></p> <p>Wanneer je met conda een virtual environment aanmaakt en alleen de naam meegeeft, is de environment helemaal leeg. Er zit ook geen pip in de environment waardoor Poetry geen packages met pip kan installeren.</p>"},{"location":"virtual_environments/#pipx","title":"Pipx","text":"<p>Sommige packages zijn niet meer een stukje gereedschap wat je gebruikt bij je eigen werk maar eerder een volledige applicatie die je opzich zelf kan gebruiken. Een voorbeeld hiervan is gammaspotter een applicatie gemaakt door studenten tijdens het eindfeest. </p> <p>Je kan zelf een virtual environment aanmaken en de package daarin installeren. Maar omdat het meer een applicatie is zal je bij het gebruik ervan steeds de environment moeten activeren en daarna de applicatie aanroepen. Als je vervolgens een andere environment activeert is de applicatie niet meer beschikbaar. Ook kan het gebeuren dat je packages update of verwijdert waardoor de applicatie niet meer werkt. Met <code>pipx</code> is het mogelijk om dit soort applicaties in een eigen virtual environment te installeren. Je loopt geen risico dat je ze stukmaakt en ze zijn beschikbaar vanuit andere virtual environments.</p> <p></p> <p>Wanneer je met <code>pipx</code> een Python applicatie instaleerd wordt deze in een eigen virtual environment geplaatst.</p>"},{"location":"virtual_environments/#pipx-installeren","title":"Pipx installeren","text":"<p>Om Pipx te kunnen gebruiken moet je het eerst installeren met behulp van pip. </p> <pre><code> &gt; python -m pip install --user pipx \ncollecting pipx\n...\nSuccessfully installed argcomplete-3.6.2 click-8.1.8 colorama-0.4.6 packaging-24.2 pipx-1.7.1 platformdirs-4.3.7 userpath-1.9.2\n\n</code></pre> <p>Zorg ervoor dat de map waarin pipx apps opslaat, is opgenomen in je PATH omgevingsvariabele. Dit zorgt ervoor dat je deze apps altijd vanuit de terminal kunt aanroepen. Dit doe je met onderstaande code.</p> <pre><code> &gt; python -m pipx ensurepath \nSuccess! Added C:\\Path\\to\\.local\\bin to the PATH environment variable.\nSuccess! Added C:\\Path\\to\\Python\\Python313-arm64\\Scripts to the PATH environment variable.\n\u00a0\nConsider adding shell completions for pipx. Run 'pipx completions' for instructions.\n\u00a0\nYou will need to open a new terminal or re-login for the PATH changes to take effect. Alternatively, you can source your shell's config file with e.g. 'source ~/.bashrc'.\n\u00a0\nOtherwise pipx is ready to go! \u2728 \ud83c\udf1f \u2728\n</code></pre> <p>De laatste zin is opvallend Otherwise pipx is ready to go! \u2728 \ud83c\udf1f \u2728, blijkbaar moet er nog iets gebeuren voordat we pipx kunnen gebruiken. Als we alle informatie doorlezen zien we een paar suggesties maar ook een dwingend advies You will need to open a new terminal or re-login for the PATH changes to take effect.</p> <p>Herstart je terminal en test of het commando <code>pipx</code> werkt. Als je in een terminal in Visual Studio Code werkt moet je dat ook herstarten en als je VS Code gestart hebt vanuit GitHub Desktop moet je \u00f3\u00f3k dat herstarten. Werkt het nog steeds niet, dan zul je volledig uit moeten loggen en weer in moeten loggen om de shellomgeving opnieuw te laden en/of vraag om hulp.</p>"},{"location":"virtual_environments/#apps-installeren-met-pipx","title":"Apps installeren met pipx","text":"<p>Wanneer een applicatie als package beschikbaar is op PyPI kun je deze als volgt met pipx installeren:</p> Terminal<pre><code>pipx install PACKAGE\n</code></pre> <p>Raadpleeg de documentatie van de applicatie om erachter te komen hoe je de applicatie vanuit de temrinal kunt starten.</p> <p>Je kunt een lijstje krijgen van alle applicaties die je met pipx hebt ge\u00efnstalleerd met</p> <pre><code> &gt; pipx list \nvenvs are in /Path/to/.local/pipx/venvs\napps are exposed on your $PATH at /Path/to/.local/bin\nmanual pages are exposed at /Path/to/.local/share/man\n   package canvas-course-tools 0.10.3, installed using Python 3.13.0\n    - canvas\n   package ecpcgrading 1.3.0, installed using Python 3.13.0\n    - ecpcgrading\n   package feat-feedback-tool 1.0.0, installed using Python 3.12.4\n    - ft.\n   package poetry 1.8.4, installed using Python 3.13.0\n    - poetry\n   package prune-envs 1.1.0, installed using Python 3.13.0\n    - prune-envs\n</code></pre> <p>Daar zie je ook meteen welke versie is ge\u00efnstalleerd. Wil je de nieuwste versie installeren gebruik dan:</p> Terminal<pre><code>pipx upgrade PACKAGE\n</code></pre> <ol> <li> <p>Of: View &gt; Command Palette &gt; Python: Select Interpreter.\u00a0\u21a9</p> </li> <li> <p>Visual Studio Code zoekt naar virtual environments waar Python in staat. Environments zonder Python staat waarschijnlijk niet in het lijstje.\u00a0\u21a9</p> </li> </ol>"},{"location":"zonnecel/","title":"Zonnecel","text":"<p>De toenemende behoefte aan energie heeft het zoeken naar nieuwe energiebronnen belangrijk gemaakt. Zonne-energie is \u00e9\u00e9n van de veelbelovende, niet-conventionele bronnen. Zonne-energie is echter niet meteen bruikbaar en moet eerst omgezet worden naar warmte of elektrische energie. De omzetting van zonne-energie naar een bruikbare vorm van energie kan gedaan worden door een zonneboiler of een zonnecel. In de komende sessies staat de zonnecel centraal. Je gaat allerlei eigenschappen van zonnecellen onderzoeken en proberen te verklaren.</p>"},{"location":"zonnecel/#de-fotovoltaische-zonnecel","title":"De fotovolta\u00efsche zonnecel","text":"<p>Stralingsenergie van de zon is een vorm van energie die niet erg nuttig is voor de meeste toepassingen. Om de energie van de zon nuttig te kunnen gebruiken, moet de straling omgezet worden. Een mogelijkheid daartoe is de fotovolta\u00efsche zonnecel. In de zonnecel maken fotonen uit het zonlicht geladen (elektrische) deeltjes vrij die via metaalcontacten op de zonnecel door een extern circuit kunnen stromen om daar hun elektrische energie af te geven. Zolang er licht valt op de zonnecel gaat het proces van vrijmaken van elektronen door en wordt er een elektrische stroom geproduceerd.</p>"},{"location":"zonnecel/#werking","title":"Werking","text":"<p>Werking van een zonnecel. Een foton met voldoende energie kan een elektron-gat-paar maken. Door de grenslaag tussen het n-type silicium en het p-type-silicium kan het elektron alleen linksom stromen, door het externe circuit, en het gat alleen rechtsom.</p> <p>De werking van de zonnecel is schematisch weergegeven in de figuur hieronder. Een zonnecel bestaat uit twee soorten siliciumkristallen, een bovenlaag van het n-type silicium en een tweede, dikkere laag van het p-type silicium. In het n-type silicium kunnen elektronen gemakkelijk bewegen, terwijl in het p-type silicium de gaten (positieve lading) makkelijk kunnen bewegen. Tussen het p- en n-type silicium ontstaat een grenslaag, welke een barri\u00e8re vormt voor zowel de elektronen als de gaten. Deze zogenoemde pn-junctie is de basis van de huidige elektronica en heeft vele toepassingen, zo ook in de zonnecel.</p> <p></p> <p>In een zonnecel is de n-laag zo dun dat het zonlicht de grenslaag kan bereiken. Als er nu een foton op de grenslaag valt, en het foton heeft voldoende energie, dan maakt dat foton een elektron-gat-paar. Kijkend naar de figuur kunnen de elektronen door de grenslaag niet rechtsom bewegen en de gaten niet linksom.  Het elektron gaat nu linksom stromen en het gat rechtsom. Er ontstaat dus een elektrische stroom. Na doorlopen van het externe circuit recombineert het elektron weer met het gat in het p-type silicium. De maximale stroom die gaat lopen wordt bepaald door het aantal elektron-gat-paren dat gevormd wordt. De maximale spanning die over de zonnecel komt te staan wordt bepaald door de energie die daarvoor nodig is (bedenk dat $[U] = J/C$!).</p> <p>Om een elektron-gat-paar in een silicium zonnecel te maken is een energie nodig van 1.12 eV (elektronvolt). De energie van een foton ($E_f$) is gelijk aan \\begin{equation}   E_f = \\frac{hc}{\\lambda} \\end{equation} waar $h$ staat voor de constante van Planck ($h \\approx 4.136 \\cdot 10^{-15} \\text{ eV} \\cdot \\text{s}$), $c$ staat voor de snelheid waarmee licht zich voortplant ($c \\approx 2.998 \\cdot 10^8$ ms$^{-1}$) en $\\lambda$ staat voor de golflengte van het licht. Dit betekent dat een foton met een golflengte van ongeveer \\begin{equation}   \\lambda = \\frac{(4.136 \\cdot 10^{-15} \\text{ eV} \\cdot \\text{s}) \\cdot (2.998 \\cdot 10^8 \\text{ ms}^{-1})}{1.12 \\text{ eV}}\\approx 1100   {\\rm nm} \\end{equation} in staat is om een elektron-gat-paar te maken. Fotonen met een golflengte groter dan 1100 nm hebben een lagere energie dan 1.12 eV en daarvoor is de zonnecel niet gevoelig. Fotonen met een kortere golflengte dan 1100 nm hebben een hogere energie dan nodig is. Zij maken wel een elektron-gat-paar, maar het overschot aan energie wordt niet omgezet in elektrische energie, deze energie gaat verloren als warmte.</p> <p>Op YouTube staat de volgende video met uitleg over de werking van de zonnecel: How do solar cells work?.</p>"},{"location":"zonnecel/#vereenvoudigde-modelbeschrijving","title":"Vereenvoudigde modelbeschrijving","text":"<p>De werking van een zonnecel hangt sterk samen met de werking van een diode. Een diode heeft de bijzondere eigenschap dat afhankelijk van de polariteit over de diode het \u00f3f geen stroom door laat en dus een oneindige hoge weerstand heeft, \u00f3f alle stroom doorlaat en bij benadering een weerstand van 0 heeft. Preciezer gezegd: voor een diode geldt dat de stroom die doorgelaten wordt, afhangt van de spanning over de diode. De stroom door een diode, $I_d$, wordt (bij benadering) gegeven door</p> <p>\\begin{equation}   I_d = I_0 \\left( {\\rm e}^{\\frac{eU}{kT}} - 1 \\right), \\end{equation} waarbij $e$ de elektronlading is ($e \\approx 1.602 \\cdot 10^{-19}$ C), $U$ de spanning over de diode, $k$ de Boltzmannconstante ($k \\approx {1.381} \\cdot 10^{-23}$ JK$^{-1}$) en $T$ de temperatuur. $I_0$ is de lekstroom van de diode. Als de spanning over de diode negatief is, geldt dat $\\exp \\left( \\frac{eU}{kT} \\right) \\ll 1$ en is $I_d \\approx - I_0 \\approx 5-7 \\; \\mu$A en dus bij benadering 0. Als de spanning over de diode positief is groeit de stroom exponentieel en is de weerstand van de diode bij benadering 0. Dit gedrag wordt ge\u00efllustreerd in de figuur hieronder.</p> <p></p> <p>Links het symbool waarmee een diode weergegeven wordt in een schakeling en rechts een $IU$-karakteristiek van een diode.</p> <p></p> <p>Een vereenvoudigde voorstelling van een zonnecel met daarop aangesloten een belastingsweerstand $R_b$. $I_L$ is de stroom opgewekt door elektron-gat-paren, $I_d$ is de stroom die door de diode loopt en $I$ is de stroom die door belastingsweerstand $R_b$ loopt, die aangesloten is op de zonnecel.</p> <p>Voor een eerste benadering kun je een zonnecel voorstellen als een speciale stroombron, zoals weergegeven is in bovenstaande figuur. In deze schakeling is ook de belastingsweerstand $R_b$ over de zonnecel getekend. De stroom die geleverd wordt door de zonnecel, $I$, hangt af van de stroom ten gevolge van het aantal elektron-gat-paren dat gemaakt wordt door het zonlicht, $I_{L}$, en de stroom door de diode, $I_d$. Dus: \\begin{equation}   I = I_L - I_d. \\end{equation} Met behulp van de diodevergelijking kun je bovenstaande vergelijking verder uitschrijven. In de exponent voor de diode komt er echter nog een factor $n$ bij die samenhangt met de materiaaleigenschappen van de zonnecel. Waarden van $n$ liggen typisch tussen 1 en 5, afhankelijk van het type zonnecel. Voor het type zonnecel waarmee je in dit experiment zult werken is $n$ ongeveer 10-15. De stroom die de zonnecel levert wordt nu bij benadering gegeven door</p> <p>\\begin{equation}   I = I_{L} - I_d = I_{L} - I_0 \\left( {\\rm e}^{ \\frac{e U}{nkT}} - 1 \\right). \\end{equation}</p>"},{"location":"zonnecel/#iu-karakteristiek","title":"I,U-karakteristiek","text":"<p>In de praktijk zul je altijd metingen doen aan zonnepanelen, waarbij zonnecellen in het paneel samengebracht zijn. De spanning die over een zonnepaneel staat hangt onder andere af van het aantal zonnecellen dat in serie geschakeld is. De stroom dat een zonnepaneel kan leveren wordt bepaald door het aantal elektron-gat-paren dat gemaakt wordt of, anders gezegd, door het aantal fotonen dat geabsorbeerd wordt. Het is echter niet zo dat je zonder meer kunt stellen dat wanneer er zonlicht op een zonnepaneel valt er een maximale spanning over het paneel staat en dat de stroom toeneemt als de lichtintensiteit toeneemt.</p> <p>Het is daarom zinvol om, voordat je aan een experiment begint, het gedrag van een zonnepaneel te onderzoeken. In eerste instantie doe je dit door te kijken naar de $I,U$-karakteristiek van het zonnepaneel. Zo'n karakteristiek is weergegeven in onderstaand figuur:</p> <p></p> <p>Als je naar de $I,U$-karakteristiek kijkt, zie je dat het zonnepaneel zich bij lage spanningen gedraagt als een niet-ideale stroombron. Als je rond de maximale spanning kijkt, zie je dat het zonnepaneel zich daar vrijwel gedraagt als een niet-ideale spanningsbron.</p> <p>De stroom die geleverd kan worden door een zonnecel uitgezet tegen de spanning $U_\\text{PV}$ geleverd door de zonnecel. Hier staat PV voor PhotoVoltaic cell.</p>"},{"location":"zonnecel/#prb-karakteristiek","title":"P,R<sub>b</sub>-karakteristiek","text":"<p>Het is bij zonnepanelen natuurlijk interessant om naar het elektrisch vermogen te kijken dat een zonnepaneel kan leveren. Het geleverd vermogen door een zonnepaneel hangt af van de materiaaleigenschappen van het paneel. Om een zo hoog mogelijk vermogen te kunnen leveren moet het zonnepaneel een zo hoog mogelijke stroom en spanning leveren. Belangrijk ook is dat het vermogen afhangt van de belasting door het circuit. Met andere woorden: bij verschillende weerstandswaardes wordt een ander vermogen geleverd. Ook is er een optimale weerstand waarbij het vermogen maximaal is:</p> <p></p> <p>Het vermogen dat geleverd kan worden door een zonnecel uitgezet tegen de belasting (weerstand) van het circuit. Er is duidelijk een maximum in het vermogen bij een optimale weerstand.</p>"},{"location":"zonnecel/#fill-factor","title":"Fill factor","text":"<p>De kwaliteit van een zonnecel/-paneel wordt experimenteel vaak aangeduid met de fill factor $FF$. De fill factor wordt gegeven door \\begin{equation}   FF = \\frac{P_{max}}{P_{T_{max}}} = \\frac{I_{Pmax} \\cdot U_{Pmax}}{I_{sc} \\cdot U_{oc}}, \\end{equation} waarbij $P_{max}$ het maximaal vermogen is wat een zonnecel/-paneel levert en $P_{T_{max}}$ het theoretisch maximaal vermogen is. $I_{sc}$ is de kortsluitstroom (bij een belastingsweerstand $R_b$ gelijk aan 0) en $U_{oc}$ de open klemspanning (wanneer het zonnepaneel niet belast wordt). $I_{Pmax}$ en $U_{Pmax}$ zijn de waarden voor respectievelijk de stroom en spanning waarbij het geleverd vermogen maximaal is.</p>"},{"location":"zonnecel/#maximum-power-point-tracking","title":"Maximum power point tracking","text":"<p>De optimale weerstand waarbij het vermogen dat geleverd wordt door een zonnecel maximaal is, is helaas geen constante. Deze weerstandswaarde is afhankelijk van verschillende condities waarbij de belangrijkste de lichtintensiteit op de zonnecel is. Dat betekent dat, zonder aanpassingen, het vermogen dat geleverd wordt door de zonnecel meestal veel lager is dan je zou wensen.</p> <p>Voor zonnepanelen die elektriciteit leveren aan het lichtnet is dit een groot probleem. Allereerst wil je je investering zo snel mogelijk terugverdienen en ook daarna wil je dat de opbrengst maximaal is. Ten tweede is het zo dat de weerstand van het lichtnet bijzonder klein is. Het vermogen dat daardoor geleverd wordt is ook heel klein. Dit wordt opgelost door \u2014 envoudig gezegd \u2014 de verbinding tussen het zonnepaneel en het lichtnet vele malen per seconde aan en uit te schakelen. Hierdoor voelt het zonnepaneel als het ware een weerstand. Deze weerstand is afhankelijk van de hoeveelheid tijd dat het paneel niet aan het lichtnet is geschakeld. Door slim te schakelen kan de weerstand z\u00f3 gekozen worden dat het geleverde vermogen maximaal is. Als de lichtintensiteit wijzigt kan ook de weerstand worden aangepast. Dit heet maximum power point tracking.</p>"}]}