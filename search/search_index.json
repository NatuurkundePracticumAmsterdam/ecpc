{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#ideeen","title":"Idee\u00ebn","text":"Schakeling bouwen <p>Als je geen kant-en-klare schakeling bij je werkplek hebt liggen, druk de Arduino in het breadboard en bouw een schakeling met een LED op de manier die is weergegeven in \\figref{fig:arduino-LED-breadboard}. De weerstand heeft een waarde van \\qty{220}{\\ohm}. De LED heeft aan \u00e9\u00e9n zijde een platte kant in de dikkere ring onderaan de plastic behuizing (goed kijken!); schakel die aan de kant van de aarde. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED. Het heeft geen zin om naar het plaatje te kijken hoe het er \u00edn de LED uitziet -- dat verschilt per type LED.</p> <p>Bestand: <code>docs/index.md</code> en ook <code>pythondaq/models/diode.py</code>. Die vind je ook in de repository <code>davidfokkema/tailor</code>.</p> <p>Eenheden: 220 \u03a9 m/s of ms-1 of $220\\,ms^{-1}$ en $220\\,\\Omega$.</p> <p>Voor menu's kan misschien <code>Code -&gt; Add repository</code> en voor toetsen Ctrl+F.</p>"},{"location":"#uitdaging-wheels","title":"Uitdaging: wheels","text":"<p>Warning</p> <p>Let op dat dit ook kan.</p> <p>Note</p> <p>Of niet.</p> <p>En zo verder.</p>"},{"location":"communicatie/","title":"Communicatie met een meetinstrument","text":"<p>Het hart van ieder experiment wordt gevormd door de metingen die worden uitgevoerd. Meetinstrumenten vervullen daarom een belangrijke rol bij het automatiseren van een experiment. De eerste stap die we zullen zetten tijdens het ontwikkelen van een applicatie is het communiceren met ons meetinstrument. We hebben gekozen voor een Arduino Nano 33 IoT,11 een zeer compact stukje elektronica rondom een ARM-microcontroller. Naast het uitvoeren van analoge spanningsmetingen kan dit model ook analoge spanningen afgeven dat voor ons heel nuttig gaat blijken. We hebben, speciaal voor dit vak, een stukje firmware1 ontwikkeld.12</p>"},{"location":"communicatie/#microcontrollers","title":"Microcontrollers","text":"<p>Computers -- zoals de meesten van ons die kennen -- zijn zeer krachtig en ontworpen om zo flexibel mogelijk te zijn. Ze draaien games, e-mail of rekenen klimaatmodellen door. Ze komen in veel vormen: desktops, laptops, tablets en telefoons. Ze bevatten daarom veel losse componenten: snelle processor (CPU), veel geheugen (RAM), veel permanente opslag (SSD), complexe interfaces (HDMI, USB) en een besturingssysteem waarmee je verschillende programma's kunt opstarten en de computer kunt beheren. Computers zijn behoorlijk prijzig.</p> <p>Een microcontroller daarentegen is veel eenvoudiger. Ze zijn ontworpen voor een beperkte en specifieke taak. Ze hebben veel verschijningsvormen -- de meeste onherkenbaar. Je vindt microcontrollers in de vaatwasser, de magnetron, een draadloos toetsenbord en auto's (letterlijk tientallen verspreid over de hele auto). Ze hebben dan een beperkte taak: ze reageren op de knopjes op je dashboard om het klimaat te regelen of een raam te openen en ze sturen de kleppen in een verbrandingsmotor aan. Microcontrollers bevatten CPU, RAM en SSD vaak in \u00e9\u00e9n chip en hebben beperkte interfaces (vaak letterlijk losse pinnetjes die je moet verbinden). De CPU is relatief gezien traag en de hoeveelheid geheugen klein. Voor de beperkte taak is dat niet erg. Een besturingssysteem is niet nodig: als je hem aanzet draait hij meteen het enige programma dat ooit ingeladen is (dit heet dan firmware). Microcontrollers zijn goedkoop en daarom ook uitermate geschikt voor hobbyprojecten.</p> <p>Een Arduino is zo'n microcontroller. Vaak wordt een Arduino vergeleken met een Raspberry Pi -- een andere goedkope computer. Maar een Raspberry Pi is \u00e9cht een computer (en daarmee ook complex). Daarmee is een Raspberry Pi veel veelzijdiger, maar ook duurder en is het complexer om een eenvoudig programma te draaien. Apparatuur zoals frequentiegeneratoren en oscilloscopen hebben vaak een microcontroller ingebouwd, maar soms ook een microcomputer analoog aan een Raspberry Pi. Dat maakt voor ons weinig verschil zolang we maar weten hoe we het instrument kunnen aansturen.</p>"},{"location":"communicatie/#communicatieprotocol","title":"Communicatieprotocol","text":"<p>Hoe praat je eigenlijk met hardware? Voor fabrikanten zijn er een paar opties:</p> <ol> <li>Je maakt gebruik van een al bestaand protocol (een bestaande standaard en je schrijft vervolgens documentatie specifiek voor jouw instrument (bijvoorbeeld de VISA-standaard 13, o.a. gebruikt door Tektronix digitale oscilloscopen 14)</li> <li>Je schrijft een proprietary2 protocol en een bijbehorende bibliotheek die software-ontwikke-laars moeten gebruiken.3 Voorbeelden zijn instrumenten van National Instruments 15 of de PicoScope digitale oscilloscopen4 16.</li> </ol> <p>De VISA-standaard is veelgebruikt, maar helaas komen proprietary protocollen veel voor. Dat is jammer, want in het laatste geval moet je het doen met de software die geleverd wordt door de fabrikant. Als die jouw besturingssysteem of favoriete programmeertaal niet ondersteunt heb je simpelweg pech.</p> <p>Wij gaan gebruik maken van de VISA-standaard. VISA staat voor Virtual Instrument Software Architecture en is h\u00e9\u00e9l breed en definieert protocollen om te communiceren via allerlei verouderde computerpoorten en kabels (\\figref{fig:old_ports}).</p> <p></p> <p>Een voorbeeld van verschillende poorten zoals RS232 en GPIB aan de achterkant van een Tektronix TDS210 oscilloscoop. Bron: Wikimedia Commons.</p> <p>\\label{fig:old_ports} \\end{figure} Maar gelukkig ook via internet en USB, waarvan wij gebruik zullen maken. Onderdeel van VISA is de SCPI standaard 17, wat staat voor Standard Commands for Programmable Instruments. Dit onderdeel definieert een bepaald formaat voor commando's die we naar ons instrument zullen sturen. De lijst met commando's die door de firmware van onze Arduino worden ondersteund is gegeven in \\appref{ch:firmware}.</p>"},{"location":"communicatie/#eerste-stappen","title":"Eerste stappen","text":"<p>Warning</p> <p>Let op dat je de weerstand van 220 \u03a9 gebruikt! Een te grote weerstand zorgt ervoor dat je nauwelijks iets kunt meten, maar een te kleine weerstand zorgt ervoor dat de stroomsterkte door de Arduino te groot wordt. In dat geval zul je de Arduino onherstelbaar beschadigen. De kleurcodes voor weerstanden vind je in \\appref{ch:kleurcodes}.</p> <p>Schakeling bouwen</p> <p>Als je geen kant-en-klare schakeling bij je werkplek hebt liggen, druk de Arduino in het breadboard en bouw een schakeling met een LED op de manier die is weergegeven in \\figref{fig:arduino-LED-breadboard}. De weerstand heeft een waarde van \\qty{220}{\\ohm}. De LED heeft aan \u00e9\u00e9n zijde een platte kant in de dikkere ring onderaan de plastic behuizing (goed kijken!); schakel die aan de kant van de aarde. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED. Het heeft geen zin om naar het plaatje te kijken hoe het er \u00edn de LED uitziet -- dat verschilt per type LED.</p> <p> </p> In de linkerfiguur is een Arduino Nano 33 IoT op een 400-punt breadboard geschakeld met een LED en een weerstand van \\qty{220}{\\ohm}. In een breadboard zijn in iedere rij alle kolommen A t/m E met elkaar verbonden (zo ook kolommen F t/m J). Draadjes die naast elkaar zijn ingeprikt zijn dus met elkaar verbonden. Zo zie je in de figuur dat het rode draadje een verbinding maakt tussen pin A0 van de Arduino en de bovenste pin van de LED. De onderste pin van de LED is verbonden met de weerstand. De kleurcodes voor weerstanden vind je in \\appref{ch:kleurcodes}. De kleur van de draden is niet belangrijk. Kies draden met een handige lengte. De platte zijde in de ring van de LED wordt richting aarde geschakeld. De Arduino kan met deze schakeling een variabele spanning aanbrengen over de LED met weerstand, en de spanning meten over alleen de weerstand. In de rechterfiguur is het equivalente circuit weergegeven zoals je dat zou bouwen met twee losse voltmeters. De cijfers 0, 1 en 2 bij $U_0$, $U_1$ en $U_2$ zijn de _kanalen_ waarmee de Arduino spanningen kan sturen of uitlezen.}   \\label{fig:arduino-LED-breadboard}    <p>Note</p> <p>Om met Python via het VISA-protocol te kunnen communiceren met apparaten hebben we specifieke packages nodig. Die gaan we installeren in een conda environment. Voor meer informatie over conda environments zie \\secref{sec:conda-envs}.</p> <p>Question</p> <p>\\label{opd:condaenv} Omdat meerdere studenten gedurende de week achter dezelfde computer werken en environments aan gaan maken kun je het beste je initialen toevoegen aan de naam van je environment. Zo zit niemand elkaar in de weg. In dit voorbeeld gebruiken we IK als initialen. Maak de environment en installeer de juiste packages door een terminal te openen5 en in te typen (zonder het dollarteken aan het begin): <pre><code>PS&gt; conda create -n IK-pythondaq -c conda-forge python pyvisa-py\n</code></pre> Om de conda environment daadwerkelijk te gebruiken moet je die altijd eerst activeren met: <pre><code>PS&gt; conda activate IK-pythondaq\n</code></pre></p> <p>Question</p> <p>Sluit de Arduino met de USB-kabel aan op de computer. Om de communicatie met de Arduino te testen maken we gebruik van <code>pyvisa-shell</code>. Open een terminal, zorg dat het goede conda environment actief is en type <code>help</code>: <pre><code>PS&gt; pyvisa-shell -b py\nWelcome to the VISA shell. Type help or ? to list commands.\n(visa) help\nDocumented commands (type help &lt;topic&gt;):\n========================================\nEOF  attr  close  exit  help  list  open  query  read  termchar  timeout  write\n(visa) help list\nList all connected resources.\n(visa) exit\n</code></pre></p> <p>Note</p> <p>We maken hier gebruik van de optie <code>-b py</code>, wat staat voor gebruik backend: python. Het kan namelijk dat er, naast <code>pyvisa-py</code>, ook andere backends, of drivers, ge\u00efnstalleerd staan op het systeem die de VISA-communicatie kunnen verzorgen. Als je bijvoorbeeld LabVIEW ge\u00efnstalleerd hebt, dan heb je de drivers van National Instruments. Maar de verschillende backends geven de aangesloten apparaten andere namen. Ook ondersteunen niet alle drivers alle types apparaten en moet je ze apart downloaden en installeren. Daarom maken we liever gebruik van de beschikbare Python drivers.</p> <p>Om verbinding te maken met onze Arduino gebruik je eerst <code>list</code> om te kijken welke apparaten aangesloten zijn en vervolgens <code>open</code> om de verbinding te openen. Je kunt makkelijk zien welk apparaat de Arduino is door \u00e9\u00e9rst <code>list</code> te gebruiken z\u00f3nder de Arduino aangesloten en vervolgens nog een keer m\u00e9t de Arduino aangesloten -- het kan een paar seconden duren voor de Arduino wordt herkend. Het laatst bijgekomen apparaat is dan de Arduino. Een commando sturen en wachten op een antwoord doe je met <code>query</code>. Als we de identificatiestring willen uitlezen wordt dit bijvoorbeeld: <pre><code>(visa) list\n( 0) ASRL3::INSTR\n(visa) open 0\nASRL3::INSTR has been opened.\nYou can talk to the device using \"write\", \"read\" or \"query\".\nThe default end of message is added to each message.\n(open) query *IDN?\nResponse: ERROR: UNKNOWN COMMAND *IDN?\n\n(open) exit\n</code></pre></p> <p>Question</p> <p>Probeer zelf ook de commando's <code>list</code>, <code>open</code>, en de <code>query</code> uit. Krijg je hetzelfde resultaat?</p> <p>Niet helemaal wat we hadden gehoopt! Als je goed kijkt in de documentatie van de firmware (\\appref{ch:firmware}) dan zie je dat er bepaalde terminator characters nodig zijn. Dit zijn karakters die gebruikt worden om het einde van een commando te markeren. Het is, zogezegd, een enter aan het eind van een zin. Dit mag je heel letterlijk nemen. Oude printers voor computeruitvoer gebruikten een carriage return (CR) om de wagen met papier (typemachine) of de printerkop weer aan het begin van een regel te plaatsen en een line feed (LF) om het papier een regel verder te schuiven. Nog steeds is het zo dat in tekstbestanden deze karakters gebruikt worden om een nieuwe regel aan te geven. Jammer maar helaas, verschillende besturingssystemen hebben verschillende conventies. Windows gebruikt nog steeds allebei: een combinatie van carriage return + line feed (CRLF). Maar MacOS/Linux/Unix gebruiken enkel een line feed (LF), want hoeveel meer heb je nodig? Af en toe is dat lastig, vooral wanneer er elektronica in het spel is want dan willen de regeleindes voor schrijven en lezen nog wel eens verschillend zijn.6 We gaan nu het gebruik van de karakters instellen:</p> <p><pre><code>(open) termchar\nTermchar read: None write: CRLF\n(open) termchar CRLF LF\nDone\n(open) termchar\nTermchar read: CRLF write: LF\n(open) query *IDN?\nResponse: Arduino VISA firmware v1.0.0\n</code></pre> Omdat de Arduino nu weet wanneer het commando voorbij is (door de LF aan het eind van de zin) krijgen we antwoord! Dat antwoord heeft dan juist weer een CRLF aan het eind dus <code>pyvisa-shell</code> weet wanneer het kan stoppen met luisteren en print het antwoord op het scherm. De karakters CRLF en LF zelf blijven onzichtbaar voor ons.</p> <p>Question</p> <p>Stel zelf ook de regeleindes goed in en probeer of je antwoord krijgt van de Arduino. Heeft jouw Arduino de nieuwste firmware? Speel eens met de commando's en kijk of je de LED kunt laten branden of een spanning kunt meten. Bijvoorbeeld: <pre><code>(open) query OUT:CH0 768\nResponse: 768\n(open) query MEAS:CH2?\nResponse: 209\n</code></pre> Wat is de minimale waarde waarbij de LED net licht geeft? Laat de spanning steeds verder oplopen; op een gegeven moment gebeurt er iets raars. Wat is de maximale waarde waarbij de LED zonder problemen kan branden?</p>"},{"location":"communicatie/#een-eenvoudig-script","title":"Een eenvoudig script","text":"<p>We hebben via de shell contact gelegd met de hardware. Nu wordt het tijd om, met de documentatie 18 in de aanslag, hetzelfde vanuit Python te doen. Als je met een nieuw project begint is het helemaal geen gek idee om een kort script te schrijven waarin je wat dingen uitprobeert. Als alles lijkt te werken kun je het netjes gaan maken en gaan uitbreiden. We beginnen hier met een eenvoudig script en zullen dat daarna gaan verfijnen.</p> <p>We lopen het voorbeeldscript eerst regel voor regel door en geven het volledige script aan het eind. Allereerst importeren we de <code>pyvisa</code>-bibliotheek met <pre><code>import pyvisa\n</code></pre> Binnen pyvisa wordt alles geregeld met behulp van een Resource Manager. Die krijgen we met <pre><code>rm = pyvisa.ResourceManager(\"@py\")\n</code></pre> Die kunnen we bijvoorbeeld gebruiken om een lijst van alle beschikbare poorten te krijgen: <pre><code>ports = rm.list_resources()\n</code></pre> Om nu daadwerkelijk verbinding te gaan maken met de Arduino moeten we die openen. Daarvoor geven we de poortnaam op en vertellen we meteen wat de instellingen moeten zijn voor de regeleindes bij het lezen (CRLF, <code>\"\\r\\n\"</code>) en het schrijven (LF, <code>\"\\n\"</code>): <pre><code>device = rm.open_resource(\n\"ASRL3::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\n</code></pre> Ten slotte sturen we een query naar de Arduino: <pre><code>device.query(\"*IDN?\")\n</code></pre> Het volledige script -- met een paar <code>print</code>-statements -- ziet er dan als volgt uit: <pre><code>import pyvisa\nrm = pyvisa.ResourceManager(\"@py\")\nports = rm.list_resources()\nprint(ports)\ndevice = rm.open_resource(\n\"ASRL3::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\nprint(device.query(\"*IDN?\"))\n</code></pre></p> <p>Question</p> <p>Maak in een geschikte map een bestand \\filepath{test_arduino.py} en kopieer daarin bovenstaande code. Selecteer vervolgens in Visual Studio Code je conda environment zodat je het script ook daadwerkelijk kunt runnen. Hoe je dat doet lees je aan het eind van \\secref{sec:conda-envs}. Sluit alle terminals.</p> <p>Draaien we het script, dan zien we, afhankelijk van het systeem en het aantal apparaten dat verbonden is: <pre><code>('ASRL3::INSTR',)\nArduino VISA firmware v1.0.0\n</code></pre></p> <p>Het kan zijn dat het script bij jullie crasht met een foutmelding. Krijg je een <code>PermissionError</code>? Dan heb je vast nog een terminal openstaan waarin <code>pyvisa-shell</code> actief is. Een andere reden kan zijn dat het script probeert een poort te openen die bij jullie een andere naam heeft. Probeer met het lijstje instrumenten te raden welke de Arduino is en pas het script aan totdat het werkt.7</p> <p>Tip</p> <p>In het vervolg gaan we commando's naar de Arduino sturen waar een variabele spanning in staat. Je kunt dit het makkelijkst doen met f-strings, zoals <pre><code>naam = \"Alice\"\nprint(f\"Hoi {naam}!\")\n</code></pre> Als je (nog) geen idee hebt wat dat inhoudt, lees dan de tutorial \\citetitle{f-strings} op Real Python \\parencite{f-strings}.</p> <p>Question</p> <p>Schrijf een script dat de spanning over de LED laat oplopen van nul tot de maximale waarde. Wat gebeurt er als je de spanning laat oplopen tot twee keer die maximale waarde?</p> <p>Question</p> <p>\\label{opd:knipperled} Je kunt de LED ook andere dingen laten doen. Schrijf voor iedere opdracht een apart script.</p> <ol> <li>Laat de LED in een regelmatig tempo knipperen.</li> <li>Maak een breathing light -- een lamp die langzaam aan en uit gaat gevolgd door een pauze in het tempo dat iemand in- en uitademt.</li> <li>Maak een heartbeat light -- een lamp die twee keer kort na elkaar flitst gevolgd door een pauze in het tempo van een hartslag.</li> </ol>"},{"location":"communicatie/#analoog-digitaalconversie-adc","title":"Analoog-digitaalconversie (ADC)","text":"<p>We hebben tot nu toe gewerkt met getallen van \\numrange{0}{1023} sturen en ontvangen. Wat is precies de betekenis van deze getallen? Daarvoor moeten we dieper ingaan op hoe de Arduino -- en computers in het algemeen -- getallen omzet in een spanning en hoe spanningen door de Arduino worden gemeten.</p> <p>Een analoog signaal is continu in zowel de tijd als de waardes die het signaal aan kan nemen. Een digitaal signaal is echter discreet: op vaste tijdstippen is er een waarde bekend en het signaal kan maar een beperkt aantal verschillende waardes aannemen. Een vallende bal is een continu proces. De bal heeft op elk willekeurig moment een positie. Je zou de positie kunnen meten op het tijdstip $t = \\qty{2.0}{\\second}$, maar ook op $t = \\text{\\qtylist[list-final-separator={ of }]{2.1;2.01;2.001;2.0001}{\\second}}$. Ook kun je de positie net zo nauwkeurig bepalen als je wilt.8 De natuur is analoog,9 maar moderne computers zijn digitaal en dus discreet. Als je een foto op je computer te ver inzoomt zie je blokjes. Je kunt verder inzoomen, maar je gaat niet meer detail zien. De hoeveelheid informatie is beperkt.</p> <p>\\begin{bonus}   \\textbf{Binair talstelsel} \\   Wij schrijven onze getallen op in een decimaal (tientallig) talstelsel. We hebben tien verschillende cijfers (0 t/m 9) en plakken bij grotere getallen de tientallen, honderdtallen, etc. aan elkaar. Computers werken met binaire getallen -- een tweetallig talstelsel. Dat betekent dat computers het getal 0 en 1 zonder problemen kunnen opslaan, maar bij het getal 2 wordt het al lastig. Zij moeten dan al met tientallen werken en schrijven het getal 2 op als 10. Het getal 3 is dan 11, 4 is 100, 5 is 101, enz. Zie \\tabref{tab:binair-stelsel} voor nog een paar voorbeelden. De cijfers noem je bits en het getal 5 (101 binair) bestaat dus uit 3 bits. Als je maar 3 bits tot je beschikking hebt kun je $2^3 = 8$ verschillende getallen opslaan, dus 0 t/m 7. Een groepje van 8 bits (256 mogelijkheden) bleek een handige hoeveelheid en kun je op computers individueel opslaan. Zo'n groepje noem je een byte. Bestanden bestaan uit bytes, kilobytes (duizend bytes), megabytes (miljoen bytes) of gigabytes (miljard bytes). Wanneer je een signaal nauwkeurig wilt verwerken met een computer dan is het belangrijk om zoveel mogelijk bits tot je beschikking te hebben. Hoe meer bits, hoe meer verschillende waardes je kunt opslaan en hoe nauwkeuriger je signaal wordt bewaard. \\end{bonus} \\begin{table}   \\centering   \\caption{Voorbeelden van het binair talstelsel.}   \\begin{tabular}{@{}       S[table-format=3.0]       S[table-format=8.0]       @{}}     \\toprule     {decimaal getal} &amp; {binair getal} \\     \\midrule     0                &amp; 0              \\     1                &amp; 1              \\     2                &amp; 10             \\     3                &amp; 11             \\     4                &amp; 100            \\     5                &amp; 101            \\     6                &amp; 110            \\     7                &amp; 111            \\     8                &amp; 1000           \\     9                &amp; 1001           \\                      &amp;                \\     205              &amp; 11001101       \\     \\bottomrule   \\end{tabular}   \\label{tab:binair-stelsel} \\end{table}</p> <p>Bemonsteren of sampling is het proces waarbij een analoog signaal wordt uitgelezen en wordt omgezet in een digitaal signaal. Zo wordt een audiosignaal al sinds eind jaren '70 van de vorige eeuw gewoonlijk bemonsterd met een frequentie van \\qty{44.1}{\\kilo\\hertz} en een resolutie van 16 bits. Dus \\num{44100} keer per seconde wordt er gekeken wat de waarde van het geluidssignaal is en dat wordt opgeslagen als een getal van 16 bits en kan dus $2^{16} = \\num{65536}$ verschillende waardes aannemen. Dit is nauwkeuriger dan het menselijk gehoor kan onderscheiden.</p> <p>De conversie van een analoog signaal naar een digitaal signaal (en andersom!) is de reden dat de spanningen die we kiezen en de metingen die we doen niet alle mogelijke waardes kunnen aannemen, maar stapjes maken. Zie \\figref{fig:adc-conversie}. \\begin{figure}   \\centering   \\includestandalone{figures/adc-process}   \\caption{Bovenste figuur: de omzetting van een analoog signaal naar een digitaal signaal. De ADC (analog-to-digital converter) in dit voorbeeld ondersteunt 16 niveau's (4-bits) in een bereik van \\qtyrange{0}{3.3}{\\volt} (groen gearceerd). Lagere of hogere spanningen kunnen niet gemeten worden (rood gearceerd). Op gezette tijden wordt een meting gedaan (rode punten) waarbij de uitkomst van de meting het discrete niveau is dat het dichtst bij de analoge waarde ligt. Als het signaal te groot wordt kan de ADC als het ware vastlopen op het hoogste niveau. In de rechterflank is waar te nemen dat als het analoge signaal langzaam verandert dat het digitale signaal duidelijk sprongsgewijs verandert. Hoe meer niveau's een ADC heeft en hoe vaker het signaal bemonsterd kan worden, hoe nauwkeuriger het digitale signaal het analoge signaal benaderd. Onderste figuur: de digitale metingen die je programma krijgt van de ADC met de onzekerheid (halve afstand tot het volgende niveau). In lichtgrijs zie je het oorspronkelijke analoge signaal. De meting benadert het signaal dus maar gedeeltelijk.}   \\label{fig:adc-conversie} \\end{figure} De Arduino die we gebruiken heeft een bereik van \\qtyrange{0}{3.3}{\\volt} en een resolutie van 10 bits, dus $2^{10} = \\num{1024}$ stapjes. Als je een experiment ontwerpt is het dus van belang te weten dat je nooit kunt meten met een nauwkeurigheid kleiner dan de stapgrootte. Voor ons is deze resolutie prima.</p> <p>Question</p> <p>We kunnen alleen maar de getallen 0 t/m 1023 naar de Arduino sturen. Ook krijgen we alleen maar dat bereik terug.</p> <ol> <li>Schrijf de formule op waarmee je een spanning in \\unit{\\volt} omrekent naar een ruwe ADC waarde, \u00e9n omgekeerd.</li> <li>Wat is precies het kleinste spanningsverschil dat we nog kunnen meten in \\unit{\\volt}? Een meting kan dus nooit nauwkeuriger gedaan worden dan deze waarde.</li> <li>Bereken welke spanning hoort bij een ruwe waarde van 700.</li> <li>Bereken welke waarde we naar de Arduino moeten sturen als we een spanning willen instellen van \\qty{2.0}{\\volt}. En een spanning van \\qty{2.28}{\\volt}?</li> </ol>"},{"location":"communicatie/#de-iu-karakteristiek-van-een-led","title":"De $I,U$-karakteristiek van een LED","text":"<p>Je hebt op de middelbare school ongetwijfeld de $I,U$-karakteristiek van een ohmse weerstand onderzocht. Je neemt een gewone weerstand en zet daar een steeds hogere spanning op. Je meet de stroomsterkte en ook die neemt toe -- rechtevenredig zelfs! Door $I$ tegen $U$ uit te zetten in een grafiek en de beste lijn door je metingen te trekken vind je met de richtingsco\u00ebffici\u00ebnt de weerstand $R$ (\\figref{fig:ohmsestroom}). Een LED is een lichtgevende diode -- en een diode gedraagt zich heel anders. Met de schakeling die we hebben gebouwd kunnen we de $I,U$-karakteristiek van een LED bepalen. Voor meer informatie over de fysica achter diodes, zie \\appref{ch:diode}.</p> <p>\\begin{figure}   \\centering   \\includestandalone{figures/I,U-curve-resistor}   \\caption{De stroom door een weerstand ten gevolge van de spanning over de weerstand. De richtingsco\u00ebffici\u00ebnt komt overeen met de inverse van de weerstand $R^{-1}$.}   \\label{fig:ohmsestroom} \\end{figure}</p> <p>\\begin{inleveropdracht}[Pythondaq: start script]   Voer de volgende opdrachten uit:</p> <pre><code>1. Schrijf een script waarin je de spanning over de LED laat oplopen van nul tot de maximale waarde. Kijk wat er gebeurt met de LED.\n1. Overleg met elkaar welke spanningen je precies meet met de verschillende kanalen (_channels_) die op de Arduino zijn aangesloten. Kijk nog eens goed naar \\figref{fig:arduino-LED-breadboard}.\n1. Lees -- tijdens het laten oplopen van de spanning over de LED -- de spanning over de _weerstand_ uit. Je zult daarvoor het antwoord van de Arduino (een _string_) om moeten zetten naar een _integer_ en print steeds een regel met: ruwe waarde spanning op LED, voltage op LED, ruwe waarde spanning over weerstand, voltage weerstand. Voorbeeld van uitvoer:\n      \\begin{consolecode*}{bgcolor={}}\n        On LED:  750 (2.4 V)    Over resistor:  189 (0.6 V)\n      \\end{consolecode*}\n      Je hebt nu feitelijk je eerste metingen verricht!\n</code></pre> <p>\\end{inleveropdracht}</p> <p>Je kunt de meetgegevens kopi\u00ebren en plakken naar een tekstbestand, spreadsheetprogramma of Python notebook o.i.d. Maar dat is wel veel werk, zeker als je metingen wilt herhalen. Op dit moment hebben we ook alleen nog maar ruwe metingen. We gaan hier voorbij aan het feit dat we graag de stroomsterkte door de LED $I$ zouden willen uitzetten tegen de spanning over de LED $U_\\mathrm{LED}$.</p> <p>Tip</p> <p>In de volgende opdracht gaan we een grafiek maken. Installeer Matplotlib in je conda environment (zorg dat die geactiveerd is!): <pre><code>PS&gt; conda install -c conda-forge matplotlib\n</code></pre></p> <p>\\begin{inleveropdracht}[Pythondaq: Quick 'n dirty meting]   \\label{opd:quickndirty-meting}   Bereken in je script de spanning over en de stroomsterkte door de LED en bewaar deze metingen in, bijvoorbeeld, een lijst. Sluit je meting netjes af (zorg dat de LED niet blijft branden) en maak dan een grafiek van je metingen. Bekijk elkaars resultaten -- ook van andere groepjes -- en denk na of je meting fysisch helemaal correct is. \\end{inleveropdracht}</p>"},{"location":"communicatie/#bewaren-van-meetgegevens","title":"Bewaren van meetgegevens","text":"<p>Het is fijn dat je script de meetgegevens op het scherm kan printen en een grafiek maakt, maar als je echt bezig bent met een onderzoek is een grafiek niet genoeg. Je wilt dat de data bewaard blijft zodat je die later nog kunt gebruiken voor nieuwe analyses. Ook is het zo dat data steeds vaker beschikbaar moet zijn voor andere wetenschappers die jouw onderzoek willen controleren. Steeds meer wetenschappelijke tijdschriften vragen auteurs niet alleen hun grafieken, maar ook hun onderliggende data beschikbaar te maken en te publiceren. Op die manier is het veel moeilijker om fraude te plegen; iets dat in de wetenschap helaas soms nog voor komt.</p> <p>Er zijn ontzettend veel verschillende bestandsformaten waarin je data kunt bewaren. Er zijn grofweg twee categori\u00ebn: tekstbestanden en binaire bestanden. De eerste zijn te lezen met ieder willekeurig programma. Sommige zijn heel eenvoudig (b.v. CSV), andere kunnen complexe datastructuren en extra informatie opslaan (b.v. JSON, XML). Binaire bestanden bevatten alle mogelijke karakters -- niet alleen letters, cijfers, leestekens, maar ook stuurcodes zoals carriage return en de line feed, oorspronkelijk opdrachten voor bijvoorbeeld printers. Ze hebben vaak een strak formaat: zoveel bytes voor dit stukje informatie, zoveel bytes voor dat stukje, enzovoort. Met binaire karakters hoef je je dus niet te beperken tot letters, cijfers en leestekens en kunnen de bestanden wat kleiner zijn. Ook zorgen de vaste afspraken ervoor dat de lees- en schrijfroutines eenvoudiger kunnen zijn. Getallen worden in het interne geheugen van de computers ook binair opgeslagen dus het is vaak copy/paste vanuit of naar het bestand. Wel leiden kleine fouten vaak tot onbruikbare bestanden. Voor grote databestanden wordt vrijwel altijd gekozen voor een binair formaat, of het nou gaat om audio/video, databases of klimaatmodellen. Het uitwisselen van kleinere bestanden gebeurt echter vaak in een tekstformaat.</p>"},{"location":"communicatie/#comma-separated-values-csv","title":"Comma-separated values (CSV)","text":"<p>Het CSV-bestand is het werkpaard van de wetenschap. Als je data van het ene in het andere programma moet krijgen of je download wetenschappelijke gegevens van een website dan is het CSV-bestand vaak de beste keuze. Het formaat bestaat uit kolommen met getallen, gescheiden door een komma. De eerste regels kunnen commentaar bevatten (uitleg over de kolommen, bijvoorbeeld) en de namen van de kolommen bevatten. Een voorbeeld voor de afstand die een vallend voorwerp aflegt in \\qty{10}{\\second}, gegeven door $s = \\frac{1}{2} g t^2$, is weergegeven in \\figref{fig:csv-bestand}.</p> <pre><code>t,s\n0.0,0.0\n1.0,4.9\n2.0,19.6\n3.0,44.1\n4.0,78.4\n5.0,122.50000000000001\n6.0,176.4\n7.0,240.10000000000002\n8.0,313.6\n9.0,396.90000000000003\n10.0,490.00000000000006\n</code></pre> <p>\\caption{Een CSV-bestand met kolommen $t$ en $s$. De getallen hebben een punt als decimaal scheidingsteken en de komma wordt gebruikt om de kolommen te scheiden.}   \\label{fig:csv-bestand} \\end{figure} Je kunt CSV-bestanden schrijven en lezen met de modules <code>csv</code>, <code>numpy</code> of <code>pandas</code>. De eerste is altijd meegeleverd met Python en is speciaal geschreven voor het bestandsformaat 19, maar NumPy \\cites{numpy}{numpy-paper} en Pandas \\cites{pandas}{pandas-paper} bevatten veel meer functionaliteit op het gebied van wiskunde en data-analyse. Als je die modules toch al gebruikt kun je beter niet kiezen voor de kale csv module.</p> <p>\\begin{inleveropdracht}[Pythondaq: csv]   \\label{opd:quickndirty-csv}   Breid je script uit zodat de data niet alleen maar weergegeven wordt in een grafiek maar ook wordt weggeschreven als CSV-bestand. Gebruik hiervoor een module naar keuze. \\end{inleveropdracht}</p> <p>\\begin{bonusopdracht}   Pas de code zodanig aan dat een CSV-bestand nooit wordt overschreven. Je kunt bijvoorbeeld aan de bestandsnaam een oplopend getal toevoegen (<code>data-001.csv</code>, <code>data-002.csv</code>, etc.). \\end{bonusopdracht}</p> <p>\\begin{bonustekst}   ### HDF5, PyTables</p> <p>Een populair binair formaat in de wetenschappelijke wereld is HDF510 20. Je kunt hiermee verschillende datasets bewaren in \u00e9\u00e9n bestand. Je kunt een soort boomstructuur aanbrengen en zo verschillende datasets groeperen en er ook nog extra informatie (metadata) aanhangen zoals datum van de meting, beschrijving van de condities, etc. Je kunt een meetserie opslaan als reeks die in \u00e9\u00e9n keer in en uit het bestand wordt geladen maar ook als tabel. Die laatste biedt de mogelijkheid om -- net als in een database -- data te selecteren en alleen die data in te laden uit het bestand. Op die manier is het mogelijk om met datasets te werken die groter zijn dan het geheugen van je computer.</p> <p>PyTables 21 is een Python bibliotheek die het werken met HDF5-bestanden makkelijker maakt. Er zijn uiteraard functies om de bestanden aan te maken en uit te lezen maar ook om queries uit te voeren. Pandas kan -- via PyTables -- ook werken met HDF5-bestanden. \\end{bonustekst}</p> <p>\\begin{bonusopdracht}   Lees de tutorial van PyTables 21 en pas je script aan zodat de meetserie van de LED wordt opgeslagen in een HDF5-bestand. Gebruik \u00e9\u00e9n bestand en maak daarin een nieuwe dataset voor iedere meetserie. Bewaar ook wat metadata (bijvoorbeeld tijdstip van de meting). Iedere keer dat je je script runt wordt er aan hetzelfde databestand een nieuwe dataset toegevoegd. \\end{bonusopdracht}</p> <ol> <li> <p>Firmware is software die in hardware is geprogrammeerd. Bijvoorbeeld het computerprogramma dat ervoor zorgt dat je magnetron reageert op de knoppen en je eten verwarmd.\u00a0\u21a9</p> </li> <li> <p>Proprietary betekent dat een bedrijf of individu exclusieve de rechten heeft over het protocol of de software en anderen geen toegang geeft tot de details.\u00a0\u21a9</p> </li> <li> <p>Niet zelden zijn dergelijke bibliotheken maar op een paar besturingssystemen beschikbaar als driver. Gebruik je MacOS in plaats van Windows en het wordt alleen op Windows ondersteund? Dan kun je je dure meetinstrument dus niet gebruiken totdat je overstapt.\u00a0\u21a9</p> </li> <li> <p>Die overigens op vrijwel alle platforms en voor veel programmeertalen bibliotheken leveren.\u00a0\u21a9</p> </li> <li> <p>Start de applicatie <code>Anaconda Powershell Prompt</code> of start een terminal binnen Visual Studio Code met het menu \\menu{Terminal &gt; New Terminal}.\u00a0\u21a9</p> </li> <li> <p>De regeleindes voor de Arduinofirmware zijn verschillend voor lezen en schrijven. Dit heeft een oninteressante reden: bij het ontvangen van commando's is het makkelijk om alles te lezen totdat je \u00e9\u00e9n bepaald karakter (LF) tegenkomt. Bij het schrijven gebruikt de standaard <code>println</code>-functie een Windows-stijl regeleinde (CRLF).\u00a0\u21a9</p> </li> <li> <p>Tip: als je de Arduino loshaalt en weer aansluit is het de nieuwe regel in het lijstje.\u00a0\u21a9</p> </li> <li> <p>Uiteraard afhankelijk van de nauwkeurigheid van je meetinstrument.\u00a0\u21a9</p> </li> <li> <p>Totdat je het domein van de kwantummechanica betreedt, dan blijkt de natuur ook een discrete kant te hebben.\u00a0\u21a9</p> </li> <li> <p>Hierarchical Data Format Version 5.\u00a0\u21a9</p> </li> <li> <p>Arduino AG. Arduino nano 33 iot. URL: https://store.arduino.cc/arduino-nano-33-iot.\u00a0\u21a9</p> </li> <li> <p>David B.R.A. Fokkema. Arduino visa firmware. 2020. URL: https://github.com/davidfokkema/arduino-visa-firmware.\u00a0\u21a9</p> </li> <li> <p>IVI Foundation. Vpp-4.3: the visa library. 2018. URL: https://www.ivifoundation.org/downloads/Architecture Specifications/IVIspecstopost10-22-2018/vpp43_2018-10-19.pdf.\u00a0\u21a9</p> </li> <li> <p>Tektronix, Inc. URL: https://www.tek.com/.\u00a0\u21a9</p> </li> <li> <p>National Instruments Corp. URL: https://www.ni.com/.\u00a0\u21a9</p> </li> <li> <p>Pico Technology Limited. URL: https://www.picotech.com/.\u00a0\u21a9</p> </li> <li> <p>SCPI Consortium. Standard commands for programmable instruments (scpi). 1999. URL: https://www.ivifoundation.org/docs/scpi-99.pdf.\u00a0\u21a9</p> </li> <li> <p>PyVISA Authors. Pyvisa: control your instruments with python. URL: https://pyvisa.readthedocs.io/en/latest/.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. Csv \u2013 csv file reading and writing. URL: https://docs.python.org/3/library/csv.html.\u00a0\u21a9</p> </li> <li> <p>The HDF Group. The hdf5 library and file format. URL: https://www.hdfgroup.org/solutions/hdf5/.\u00a0\u21a9</p> </li> <li> <p>Ivan Vilata Francesc Alted and others. PyTables: hierarchical datasets in Python. URL: http://www.pytables.org/.\u00a0\u21a9\u21a9</p> </li> </ol>"}]}