{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introductie","text":"<p>Welkom bij de Experiment Control with Python Course. Het doel van deze cursus is om jullie kennis te laten maken met het aansturen en uitlezen van een experiment.</p> <p>Bij heel eenvoudige experimenten kun je metingen \u00e9\u00e9n voor \u00e9\u00e9n verrichten en noteren in je labjournaal, bijvoorbeeld bij de trillingstijd van een slinger bij verschillende lengtes. Maar al snel wordt dan ondoenlijk, bijvoorbeeld wanneer je de hele beweging van de slinger wilt volgen met een ultrasoon afstandsdetector. In een gemiddeld lab worden alle experimenten via de computer aangestuurd en uitgelezen. Voor standaard handelingen zoals het bekijken van een sample onder een elektronenmicroscoop of het opnemen van een spectrum van een radioactieve bron kun je de door de fabrikant meegeleverde software gebruiken. Vaak echter is die software \u00f3f heel duur terwijl je maar een klein deel van de functionaliteit nodig hebt, of ongeschikt voor jouw doeleinden. En heel vaak voer je g\u00e9\u00e9n standaardexperiment uit, maar ben je een nieuw experiment aan het opzetten. In dat laatste geval is er helemaal geen software voor handen. Je zult dus zelf aan de slag moeten.</p> <p>We willen je in deze cursus niet alleen maar leren om een snelle meting uit te voeren, maar ook hoe je de code netjes schrijft. Als je een bachelorproject doet, een masterstage, of een promotieonderzoek, dan wil je code schrijven die nog steeds bruikbaar is nadat je je stage hebt afgerond of je proefschrift hebt verdedigd. Ook zullen andere onderzoekers aan dezelfde code werken. Het is dus belangrijk om te zorgen voor een duidelijke structuur waarmee de code overzichtelijk blijft maar ook makkelijk is aan te passen of uit te breiden.</p> <p>Jullie gaan aan de slag met een Arduino. De Arduino bevat firmware waarmee het zich gedraagd als een meetinstrument en kan communiceren met de computer volgens een standaardprotocol dat ook ge\u00efmplementeerd wordt door onder andere functiegeneratoren en oscilloscopen.</p>"},{"location":"#notatie","title":"Notatie","text":"<p>We zullen in deze handleiding vaak Engelse termen gebruiken, ook als Nederlandse termen voorhanden zijn. Bijvoorbeeld: list in plaats van lijst, class in plaats van klasse. Dit omdat deze Engelse termen veel meer ingeburgerd zijn en omdat voor sommige van de Engelse termen geen goede vertalingen zijn. Liever wat consequenter Engelse termen gebruiken dan alles door elkaar!</p> <p>In deze handleiding kom je twee verschillende dingen tegen. Pythoncode en systeemopdrachten. Voor pythoncode geldt dat je in Visual Studio Code een nieuw bestand moet aanmaken met de extensie <code>.py</code> en dat je daarin de code kunt typen. Vervolgens kun je het script runnen en geeft Visual Studio Code de uitvoer terug. In deze handleiding zal dat als volgt worden weergegeven: <pre><code># Ik ben een script. Ik sta in een gekleurd blok \n# en de Pythoncode heeft gekleurde syntax.\ndef my_func(x):\nreturn x ** 2\nprint(my_func(2))\n</code></pre> Rechtsboven in het blok staat een -icoon. Als je daar op klikt dan wordt de hele code gekopieerd naar het klembord en kun je het in Visual Studio Code weer plakken met Ctrl+V.</p> <p>Ook zullen we soms systeemopdrachten moeten uitvoeren. We willen bijvoorbeeld nieuwe Pythonbibliotheken installeren of onze nieuw-gebouwde applicaties testen. Dit doen we vanuit de terminal. De terminal biedt een zogeheten command-line interface voor het systeem. Dit in tegenstelling tot een grafische interface.</p> <p>Met deze notatie laten we zien hoe je <code>my-script.py</code> met python kunt runnen: Terminal<pre><code>python my-script.py\n</code></pre> Wanneer we ook de uitvoer van commando's laten zien is het handiger om onderscheid te maken tussen het commando en de uitvoer. Als dat nodig is laten we ook de prompt1 zien: Terminal<pre><code>PS&gt; python --version\nPython 3.10.9\n</code></pre> Merk op dat de commando's dan iets donkerder gekleurd zijn dan de prompt en de uitvoer. Let dus op de verschillende code blocks. Is het een Python script of zijn het commando's die je moet uitvoeren in een terminal?</p>"},{"location":"#opgaves","title":"Opgaves","text":"<p>In de handleiding staan verschillende opgaves. De meeste zijn bedoeld als oefening, maar sommige moet je inleveren voor feedback en een beoordeling.</p> <p>Info</p> <p>In sommige programmeercursussen is het de bedoeling dat je een bepaald algoritme zelf schrijft. Je moet bijvoorbeeld een loop schrijven om een reeks berekeningen uit te voeren en mag dan niet gebruik maken van de NumPy-bibliotheek om dat in \u00e9\u00e9n regel te doen. Je kunt je voorstellen dat als je straks in een lab werkt dat je juist gebruik wilt maken van bibliotheken die het leven een stuk gemakkerlijker maken. Trek dus alles uit de kast. Kijk eens in de Python Standard Library,2 de Python Package Index3 of Awesome Python4.</p> <p>Waarschuwing</p> <p>Er is \u00e9\u00e9n uitzondering op bovenstaande regel. Er zijn Python frameworks beschikbaar die specifiek geschreven zijn om makkelijk interfaces voor experimenten te maken. Ze bevatten een groep drivers voor apparatuur van verschillende fabrikanten en beloven dat je met een paar regels code een heel experiment aan elkaar kunt knopen. Hoewel dat een mooie belofte is zijn het bijna alleen maar pakketten die geschreven zijn door een specifiek lab, v\u00f3\u00f3r dat specifieke lab, in de hoop dat het breder toepasbaar wordt. Ze zijn daarmee eigenlijk te specifiek en je moet flink de documentatie induiken als je iets wilt doen dat nog niet bedacht is door de oorspronkelijke auteurs. Daarom worden ze weinig gebruikt en is de kans dat jullie daar later mee gaan werken klein. Liever leren we jullie hoe zo'n pakket in elkaar zit en daarmee ook een beetje hoe je zo'n pakket zelf schrijft. Doe vooral idee\u00ebn op, maar gebruik ze niet. Als je twijfelt of je een bibliotheek mag gebruiken, overleg dan met je begeleider.</p> <p>Basisopdracht</p> <p>Deze opgaves helpen je om het niveau te behalen wat van je verwacht wordt. Ze worden niet beoordeeld.</p> <p>Inleveropdracht</p> <p>Deze opgave moet worden ingeleverd voor feedback en een beoordeling. Je herkent ze aan de groene kleur. De opgaven bouwen voort op elkaar, dus er zijn meerdere opgaven. Je levert ze niet los in, maar als geheel. Kijk goed bij de assignments op canvas welke groene opdrachten je gemaakt moet hebben voordat je het inlevert. </p> <p>Meer leren</p> <p>Dit zijn verdiepende en verbredende opgaves om je te kunnen ontwikkelen tot een goed programmeur en een waardevolle aanwinst voor een onderzoeksgroep. Je kunt er geen extra punten mee verdienen wanneer je deze technieken toepast in je inleveropdrachten, maar het is wel een goede oefening. Doe deze opgaves alleen als je klaar bent met de rest.</p> <ol> <li> <p>Er bestaan verschillende prompts, meestal afhankelijk van het besturingssysteem \u2014 al heeft Windows zelf al twee verschillende prompts: de command prompt en de powershell prompt. In MacOS en Linux is de prompt vaak een <code>$</code>-teken. In veel documentatie op internet wordt deze prompt gebruikt.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. The python standard library. URL: https://docs.python.org/3/library/.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. Python package index. URL: https://pypi.org.\u00a0\u21a9</p> </li> <li> <p>Vinta Chen. Awesome python. URL: https://awesome-python.com.\u00a0\u21a9</p> </li> </ol>"},{"location":"basisscript/","title":"Basisscript voor het experiment","text":"<p>Het experiment wat we gaan uitvoeren is het bepalen van de $I,U$-karakteristiek van een LED. Omdat de Arduino alleen getallen tussen 0 en 1023 kan sturen en ontvangen moeten we nadenken over de Analoog-digitaalconversie voordat we een zinnige $I,U$-karakteristiek kunnen maken. </p>"},{"location":"basisscript/#analoog-digitaalconversie-adc","title":"Analoog-digitaalconversie (ADC)","text":"<p>We hebben tot nu toe gewerkt met getallen van 0-1023 sturen en ontvangen. Wat is precies de betekenis van deze getallen? Daarvoor moeten we dieper ingaan op hoe de Arduino \u2014 en computers in het algemeen \u2014 getallen omzet in een spanning en hoe spanningen door de Arduino worden gemeten.</p> <p>Een analoog signaal is continu in zowel de tijd als de waardes die het signaal aan kan nemen. Een digitaal signaal is echter discreet: op vaste tijdstippen is er een waarde bekend en het signaal kan maar een beperkt aantal verschillende waardes aannemen. Een vallende bal is een continu proces. De bal heeft op elk willekeurig moment een positie. Je zou de positie kunnen meten op het tijdstip $t$ = 2.0 s, maar ook op $t$ = 2.1, 2.01, 2.001 of 2.0001 s. Ook kun je de positie net zo nauwkeurig bepalen als je wilt.1 De natuur is analoog,2 maar moderne computers zijn digitaal en dus discreet. Als je een foto op je computer te ver inzoomt zie je blokjes. Je kunt verder inzoomen, maar je gaat niet meer detail zien. De hoeveelheid informatie is beperkt.</p> <p>Bemonsteren of sampling is het proces waarbij een analoog signaal wordt uitgelezen en wordt omgezet in een digitaal signaal. Zo wordt een audiosignaal al sinds eind jaren '70 van de vorige eeuw gewoonlijk bemonsterd met een frequentie van 44.1 kHz en een resolutie van 16 bits. Dus 44100 keer per seconde wordt er gekeken wat de waarde van het geluidssignaal is en dat wordt opgeslagen als een getal van 16 bits en kan dus $2^{16} = 65536$ verschillende waardes aannemen. Dit is nauwkeuriger dan het menselijk gehoor kan onderscheiden.</p> <p>De conversie van een analoog signaal naar een digitaal signaal (en andersom!) is de reden dat de spanningen die we kiezen en de metingen die we doen niet alle mogelijke waardes kunnen aannemen, maar stapjes maken.</p> <p></p> <p>De omzetting van een analoog signaal naar een digitaal signaal gebeurt als volgt. De ADC (analog-to-digital converter) in dit voorbeeld ondersteunt 16 niveau's (4-bits) in een bereik van 0 V tot 3.3 V (groen gearceerd). Lagere of hogere spanningen kunnen niet gemeten worden (rood gearceerd). Op gezette tijden wordt een meting gedaan (rode punten) waarbij de uitkomst van de meting het discrete niveau is dat het dichtst bij de analoge waarde ligt. Als het signaal te groot wordt kan de ADC als het ware vastlopen op het hoogste niveau. In de rechterflank is waar te nemen dat als het analoge signaal langzaam verandert dat het digitale signaal duidelijk sprongsgewijs verandert. Hoe meer niveau's een ADC heeft en hoe vaker het signaal bemonsterd kan worden, hoe nauwkeuriger het digitale signaal het analoge signaal benadert.</p> <p></p> <p>De digitale metingen die je programma krijgt van de ADC is hierboven weergegeven. De onzekerheid is gelijk aan de halve afstand tot het volgende niveau. In lichtgrijs zie je het oorspronkelijke analoge signaal. De meting benadert het signaal dus maar gedeeltelijk. De Arduino die we gebruiken heeft een bereik van 0 V tot 3.3 V en \u2014 in tegenstelling tot het voorbeeld hierboven \u2014 een resolutie van 10 bits, dus $2^{10} = 1024$ stapjes. Als je een experiment ontwerpt is het dus van belang te weten dat je nooit kunt meten met een nauwkeurigheid kleiner dan de stapgrootte. Voor ons is deze resolutie prima.</p> <p>Volt naar ADC</p> <p>We kunnen alleen maar de getallen 0 t/m 1023 naar de Arduino sturen. Ook krijgen we alleen maar dat bereik terug.</p> <ol> <li>Schrijf de formule op waarmee je een spanning in V omrekent naar een ruwe ADC waarde, \u00e9n omgekeerd.</li> <li>Wat is precies het kleinste spanningsverschil dat we nog kunnen meten in V? Een meting kan dus nooit nauwkeuriger gedaan worden dan deze waarde.</li> <li>Bereken welke spanning hoort bij een ruwe waarde van 700.</li> <li>Bereken welke waarde we naar de Arduino moeten sturen als we een spanning willen instellen van 2.0 V. En een spanning van 2.28 V?</li> </ol>"},{"location":"basisscript/#binair-talstelsel","title":"Binair Talstelsel","text":"Meer leren <p>Wij schrijven onze getallen op in een decimaal (tientallig) talstelsel. We hebben tien verschillende cijfers (0 t/m 9) en plakken bij grotere getallen de tientallen, honderdtallen, etc. aan elkaar. Computers werken met binaire getallen \u2014 een tweetallig talstelsel. Dat betekent dat computers het getal 0 en 1 zonder problemen kunnen opslaan, maar bij het getal 2 wordt het al lastig. Zij moeten dan al met tientallen werken en schrijven het getal 2 op als 10. Het getal 3 is dan 11. Voor 4 zijn de cijfers alweer op en moeten we overschakelen naar honderdtallen, dus 4 is 100, 5 is 101, enz. Zie onderstaande tabel voor nog een paar voorbeelden. De cijfers noem je bits en het getal 5 (101 binair) bestaat dus uit 3 bits. Als je maar 3 bits tot je beschikking hebt kun je $2^3 = 8$ verschillende getallen opslaan, dus 0 t/m 7. Een groepje van 8 bits (256 mogelijkheden) bleek een handige hoeveelheid en kun je op computers individueel opslaan. Zo'n groepje noem je een byte. Bestanden bestaan uit bytes, kilobytes (duizend bytes), megabytes (miljoen bytes) of gigabytes (miljard bytes). Wanneer je een signaal nauwkeurig wilt verwerken met een computer dan is het belangrijk om zoveel mogelijk bits tot je beschikking te hebben. Hoe meer bits, hoe meer verschillende waardes je kunt opslaan en hoe nauwkeuriger je signaal wordt bewaard.</p> <p>Voorbeelden van het binair talstelsel:</p> decimaal getal binair getal 0 0 1 1 2 10 3 11 4 100 5 101 6 110 7 111 8 1000 9 1001 \u2026 \u2026 205 11001101"},{"location":"basisscript/#de-iu-karakteristiek-van-een-led","title":"De I,U-karakteristiek van een LED","text":"<p>Je hebt op de middelbare school ongetwijfeld de $I,U$-karakteristiek van een ohmse weerstand onderzocht. Je neemt een gewone weerstand en zet daar een steeds hogere spanning op. Je meet de stroomsterkte en ook die neemt toe \u2014 rechtevenredig zelfs! Door $I$ tegen $U$ uit te zetten in een grafiek en de beste lijn door je metingen te trekken vind je met de richtingsco\u00ebffici\u00ebnt de inverse van de weerstand $R^{-1}$:</p> <p></p> <p>Een LED is een lichtgevende diode \u2014 en een diode gedraagt zich heel anders. Met de schakeling die we hebben gebouwd kunnen we de $I,U$-karakteristiek van een LED bepalen. Voor meer informatie over de fysica achter diodes, zie de appendix Diodes.</p> <p>Pythondaq: repository</p> <p>Omdat we met een belangrijk project aan de slag gaan, namelijk een inleveropdracht, gaan we gelijk goed beginnen door een repository aan te maken. </p> <ol> <li>Open Github Desktop en ga naar File &gt; New repository .... Geef de repository een naam (Pythondaq) en kies een locatie. Let er op dat je deze map niet in een andere repository aanmaakt, maar daarbuiten. Overleg eventueel over een handige plek.</li> <li>Vink <code>Initialize this repository with a README</code> aan.</li> <li>Kies bij <code>Git ignore</code> voor Python.</li> <li>Ga naar Repository &gt; Open in Visual Studio Code en ga aan de slag. Vergeet niet regelmatig te committen!</li> </ol> <p>Pythondaq: start script</p> <p>Voer de volgende opdrachten uit:</p> <ol> <li>Schrijf een script waarin je de spanning over de LED laat oplopen van nul tot de maximale waarde. Kijk wat er gebeurt met de LED.</li> <li>Commit.</li> <li>Overleg met elkaar welke spanningen je precies meet met de verschillende kanalen (channels) die op de Arduino zijn aangesloten. Kijk nog eens goed naar de figuur van de schakeling.</li> <li>Commit.</li> <li>Lees \u2014 tijdens het laten oplopen van de spanning over de LED \u2014 de spanning over de weerstand uit. Je zult daarvoor het antwoord van de Arduino (een string) om moeten zetten naar een integer en print steeds een regel met: ruwe waarde spanning op LED, voltage op LED, ruwe waarde spanning over weerstand, voltage weerstand. Voorbeeld van uitvoer: <pre><code>On LED:  750 (2.4 V)    Over resistor:  189 (0.6 V)\n</code></pre> Je hebt nu feitelijk je eerste metingen verricht!</li> <li>Commit! </li> </ol> <p>Je kunt de meetgegevens kopi\u00ebren en plakken naar een tekstbestand, spreadsheetprogramma of Python notebook o.i.d. Maar dat is wel veel werk, zeker als je metingen wilt herhalen. Op dit moment hebben we ook alleen nog maar ruwe metingen. We gaan hier voorbij aan het feit dat we graag de stroomsterkte door de LED $I$ zouden willen uitzetten tegen de spanning over de LED $U_\\mathrm{LED}$.</p> <p>Info</p> <p>In de volgende opdracht gaan we een grafiek maken. Installeer Matplotlib in je conda environment (zorg dat die geactiveerd is!): Terminal<pre><code>conda install -c conda-forge matplotlib\n</code></pre></p> <p>Pythondaq: Quick 'n dirty meting</p> <p>Bereken in je script de spanning over en de stroomsterkte door de LED en bewaar deze metingen in een lijst met spanningen en een lijst met stroomsterktes. Sluit je meting netjes af (zorg dat de LED niet blijft branden) en maak dan een grafiek van je metingen. Bekijk elkaars resultaten \u2014 ook van andere groepjes \u2014 en denk na of je meting fysisch helemaal correct is.</p>"},{"location":"basisscript/#bewaren-van-meetgegevens","title":"Bewaren van meetgegevens","text":"<p>Het is fijn dat je script de meetgegevens op het scherm kan printen en een grafiek maakt, maar als je echt bezig bent met een onderzoek is een grafiek niet genoeg. Je wilt dat de data bewaard blijft zodat je die later nog kunt gebruiken voor nieuwe analyses. Ook is het zo dat data steeds vaker beschikbaar moet zijn voor andere wetenschappers die jouw onderzoek willen controleren. Steeds meer wetenschappelijke tijdschriften vragen auteurs niet alleen hun grafieken, maar ook hun onderliggende data beschikbaar te maken en te publiceren. Op die manier is het veel moeilijker om fraude te plegen; iets dat in de wetenschap helaas soms nog voor komt.</p> <p>Er zijn ontzettend veel verschillende bestandsformaten waarin je data kunt bewaren. Er zijn grofweg twee categori\u00ebn: tekstbestanden en binaire bestanden. De eerste zijn te lezen met ieder willekeurig programma. Sommige zijn heel eenvoudig (b.v. CSV), andere kunnen complexe datastructuren en extra informatie opslaan (b.v. JSON, XML). Binaire bestanden bevatten alle mogelijke karakters \u2014 niet alleen letters, cijfers, leestekens, maar ook stuurcodes zoals carriage return en de line feed, oorspronkelijk opdrachten voor bijvoorbeeld printers. Ze hebben vaak een strak formaat: zoveel bytes voor dit stukje informatie, zoveel bytes voor dat stukje, enzovoort. Met binaire karakters hoef je je dus niet te beperken tot letters, cijfers en leestekens en kunnen de bestanden wat kleiner zijn. Ook zorgen de vaste afspraken ervoor dat de lees- en schrijfroutines eenvoudiger kunnen zijn. Getallen worden in het interne geheugen van de computers ook binair opgeslagen dus het is vaak copy/paste vanuit of naar het bestand. Wel leiden kleine fouten vaak tot onbruikbare bestanden. Voor grote databestanden wordt vrijwel altijd gekozen voor een binair formaat, of het nou gaat om audio/video, databases of klimaatmodellen. Het uitwisselen van kleinere bestanden gebeurt echter vaak in een tekstformaat.</p>"},{"location":"basisscript/#comma-separated-values-csv","title":"Comma-separated values (CSV)","text":"<p>Het CSV-bestand is het werkpaard van de wetenschap. Als je data van het ene in het andere programma moet krijgen of je download wetenschappelijke gegevens van een website dan is het CSV-bestand vaak de beste keuze. Het formaat bestaat uit kolommen met getallen, gescheiden door een komma. De eerste regels kunnen commentaar bevatten (uitleg over de kolommen, bijvoorbeeld) en de namen van de kolommen bevatten. Een voorbeeld voor de afstand die een vallend voorwerp aflegt in 10 s, gegeven door $s = \\frac{1}{2} g t^2$, is hieronder weergegeven:</p> <pre><code>t,s\n0.0,0.0\n1.0,4.9\n2.0,19.6\n3.0,44.1\n4.0,78.4\n5.0,122.50000000000001\n6.0,176.4\n7.0,240.10000000000002\n8.0,313.6\n9.0,396.90000000000003\n10.0,490.00000000000006\n</code></pre> <p>Het CSV-bestand heeft kolommen $t$ en $s$. De getallen hebben een punt als decimaal scheidingsteken en de komma wordt gebruikt om de kolommen te scheiden. Je kunt CSV-bestanden schrijven en lezen met de modules <code>csv</code>, <code>numpy</code> of <code>pandas</code>. De eerste is altijd meegeleverd met Python en is speciaal geschreven voor het bestandsformaat,7 maar NumPy89 en Pandas1011 bevatten veel meer functionaliteit op het gebied van wiskunde en data-analyse. Als je die modules toch al gebruikt hoef je niet te kiezen voor de kale csv module.</p>"},{"location":"basisscript/#de-functie-zip","title":"De functie <code>zip()</code>","text":"<p>Het viel je misschien op dat in bovenstaand CSV-bestand iedere regel een $t$-waarde en een $s$-waarde heeft. Als je een lijst met $t$'s en een lijst met $s$'en hebt dan bevat de eerste regel het eerste element uit beide lijsten, de tweede regel het tweede element, etc. Je kunt dan een for-loop schrijven die Python's indexnotatie gebruikt: <code>t[i]</code>, <code>s[i]</code>, etc. Het kan \u00f3\u00f3k, makkelijker, met de <code>zip()</code>-functie. Beide methodes kun je als volgt gebruiken in het geval van twee3 lijsten A en B:</p> with_indexing.pywith_zip.py <pre><code>A = [1, 2, 3, 4]\nB = [1, 4, 9, 16]\nfor i in range(len(A)):\nprint(A[i], B[i])\n# Output:\n#\n# 1 1\n# 2 4\n# 3 9\n# 4 16\n</code></pre> <pre><code>A = [1, 2, 3, 4]\nB = [1, 4, 9, 16]\nfor a, b in zip(A, B):\nprint(a, b)\n# Output:\n#\n# 1 1\n# 2 4\n# 3 9\n# 4 16\n</code></pre> <p>Vergelijk beide methodes goed. In het geval van <code>zip()</code> hoef je niet de lengte van de lijst op te zoeken en krijg je meteen de losse elementen zonder dat je ze zelf uit de lijst moet plukken met indexnotatie.</p> oefenen met zip <p>Gegeven de spanningen $U$ gelijk aan 1.2 V; 1.8 V; 2.4 V; 2.7 V; 3.1 V en de bijbehorende stroomsterktes $I$ gelijk aan 0.3 A; 0.4 A; 0.6 A; 0.8 A; 1.0 A, loop over de lijsten met <code>zip()</code> en print voor iedere iteratie de spanning $U$, de stroomsterkte $I$ en de weerstand $R$.</p>"},{"location":"basisscript/#het-gebruik-van-de-csv-module","title":"Het gebruik van de <code>csv</code>-module","text":"<p>Wanneer je de <code>csv</code>-module wilt gebruiken moet je \u00e9\u00e9rst een bestand openen om in te schrijven, daarna een writer object aanmaken, en dat object gebruiken om regels te schrijven. Daarna moet het bestand netjes afgesloten worden zodat het ook echt naar schijf weggeschreven wordt. Het openen en sluiten van een bestand kun je Python het beste laten doen met het <code>with</code>-statement:4</p> <pre><code>with open('metingen.csv', 'w', newline='') as csvfile:\n# csvfile is nu een bestandsobject\n...\n# na dit blok sluit Python automatisch het bestand\n</code></pre> <p>Bij <code>open()</code> geef je eerst de naam van een bestand, dan <code>'w'</code> om aan te geven dat het bestand writeable moet zijn (gebruik <code>'r'</code> om te lezen) en <code>newline=''</code> om Python niet zelf regeleindes te laten schrijven; dat doet de <code>csv</code>-module. Op de volgende manier schrijven we dan de CSV-data weg:</p> <p><pre><code>import csv\nwith open('metingen.csv', 'w', newline='') as csvfile:\nwriter = csv.writer(csvfile)\nwriter.writerow(['t', 's'])\nwriter.writerow([0.0, 0.0])\nwriter.writerow([1.0, 4.9])\nwriter.writerow([2.0, 19.6])\n...\n</code></pre> Je kunt het wegschrijven van de regels vervangen door een for-loop.</p> <p>Pythondaq: CSV</p> <p>Breid je script uit zodat de data niet alleen maar weergegeven wordt in een grafiek maar ook wordt weggeschreven als CSV-bestand. Gebruik de <code>zip()</code>-functie en de <code>csv</code>-module.</p> CSV bestandsnaam <p>Pas de code zodanig aan dat een CSV-bestand nooit wordt overschreven. Je kunt bijvoorbeeld controleren of het bestand al bestaat en aan de bestandsnaam een oplopend getal toevoegen (<code>data-001.csv</code>, <code>data-002.csv</code>, etc.) totdat je uitkomt bij een bestandsnaam die nog niet bestaat. Controleer dat je programma ook echt geen data overschrijft.</p>"},{"location":"basisscript/#hdf5-pytables","title":"HDF5, PyTables","text":"Meer leren <p>Een populair binair formaat in de wetenschappelijke wereld is HDF5.5 12 Je kunt hiermee verschillende datasets bewaren in \u00e9\u00e9n bestand. Je kunt een soort boomstructuur aanbrengen en zo verschillende datasets groeperen en er ook nog extra informatie (metadata) aanhangen zoals datum van de meting, beschrijving van de condities, etc. Je kunt een meetserie opslaan als reeks die in \u00e9\u00e9n keer in en uit het bestand wordt geladen maar ook als tabel. Die laatste biedt de mogelijkheid om \u2014 net als in een database \u2014 data te selecteren en alleen die data in te laden uit het bestand. Op die manier is het mogelijk om met datasets te werken die groter zijn dan het geheugen van je computer.6 Meer informatie lees je in de tutorial van PyTables13.</p> <p>PyTables13 is een Python bibliotheek die het werken met HDF5-bestanden makkelijker maakt. Er zijn uiteraard functies om de bestanden aan te maken en uit te lezen maar ook om queries uit te voeren. Pandas kan \u2014 via PyTables \u2014 ook werken met HDF5-bestanden. </p> <p>HDF5 tutorial</p> <p>Download de HDF5 tutorial. Open de tutorial in Visual Studio Code en bestudeer de stappen die daar staan beschreven nauwkeurig.</p> <p>PyTables</p> <p>Pas je script aan zodat de meetserie van de LED wordt opgeslagen in een HDF5-bestand. Vraag hulp als je uitleg wilt over wat een <code>UInt16</code> voor een ding is. Gebruik \u00e9\u00e9n bestand en maak daarin een nieuwe dataset voor iedere meetserie. Bewaar ook wat metadata (bijvoorbeeld tijdstip van de meting). Iedere keer dat je je script runt wordt er aan hetzelfde databestand een nieuwe dataset toegevoegd.</p> <ol> <li> <p>Uiteraard afhankelijk van de nauwkeurigheid van je meetinstrument.\u00a0\u21a9</p> </li> <li> <p>Totdat je het domein van de kwantummechanica betreedt, dan blijkt de natuur ook een discrete kant te hebben.\u00a0\u21a9</p> </li> <li> <p>Je kunt net zoveel lijsten in <code>zip()</code> gooien als je wilt: <code>for a, b, c, d, e in zip(A, B, C, D, E)</code> is geen probleem.\u00a0\u21a9</p> </li> <li> <p>hier is <code>open()</code> een zogeheten context manager, een functie die je kunt gebruiken met een <code>with</code>-statement en dat bij de start iets doet \u2014 hier een bestand openen \u2014 en bij het eind iets doet \u2014 hier het bestand weer netjes afsluiten. Je kunt zelf ook context managers schrijven, als je wilt.\u00a0\u21a9</p> </li> <li> <p>Hierarchical Data Format Version 5, in gebruik bij bijvoorbeeld de LOFAR radiotelescoop, het IceCube neutrino-observatorium en de LIGO zwaartekrachtsgolvendetector.\u00a0\u21a9</p> </li> <li> <p>Lees bijvoorbeeld deze korte blog post over het gebruik van HDF5.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. Csv \u2013 csv file reading and writing. URL: https://docs.python.org/3/library/csv.html.\u00a0\u21a9</p> </li> <li> <p>The NumPy Development Team. Numpy \u2013 the fundamental package for scientific computing with python. URL: https://numpy.org.\u00a0\u21a9</p> </li> <li> <p>Charles R. Harris, K. Jarrod Millman, St'efan J. van der Walt, Ralf Gommers, Pauli Virtanen, David Cournapeau, Eric Wieser, Julian Taylor, Sebastian Berg, Nathaniel J. Smith, Robert Kern, Matti Picus, Stephan Hoyer, Marten H. van Kerkwijk, Matthew Brett, Allan Haldane, Jaime Fern'andez del R'\u0131o, Mark Wiebe, Pearu Peterson, Pierre G'erard-Marchant, Kevin Sheppard, Tyler Reddy, Warren Weckesser, Hameer Abbasi, Christoph Gohlke, and Travis E. Oliphant. Array programming with NumPy. Nature, 585(7825):357\u2013362, September 2020. URL: https://doi.org/10.1038/s41586-020-2649-2, doi:10.1038/s41586-020-2649-2.\u00a0\u21a9</p> </li> <li> <p>The pandas development team. Pandas-dev/pandas: pandas 1.0.5. June 2020. URL: https://doi.org/10.5281/zenodo.3898987, doi:10.5281/zenodo.3898987.\u00a0\u21a9</p> </li> <li> <p>Wes McKinney. Data Structures for Statistical Computing in Python. In St\u00e9fan van der Walt and Jarrod Millman, editors, Proceedings of the 9th Python in Science Conference, 56 \u2013 61. 2010. doi:10.25080/Majora-92bf1922-00a.\u00a0\u21a9</p> </li> <li> <p>The HDF Group. The hdf5 library and file format. URL: https://www.hdfgroup.org/solutions/hdf5/.\u00a0\u21a9</p> </li> <li> <p>Ivan Vilata Francesc Alted and others. PyTables: hierarchical datasets in Python. URL: http://www.pytables.org/.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"cli/","title":"Command-line interface","text":""},{"location":"cli/#gebruikersomgevingen","title":"Gebruikersomgevingen","text":"<p>Vanaf de jaren '60 van de vorige eeuw werden computers interactief. Het was mogelijk om via een terminal commando's aan de computer te geven en te wachten op een antwoord. In tegenstelling tot moderne gebruikersomgevingen waren deze volledig op tekst gebaseerd. Hoewel moderne besturingssystemen \u2014 of het nu computers, tablets of mobiele telefoons betreft \u2014 volledig grafisch zijn ingericht, is de tekstuele interface nooit verdwenen. Opdrachten geven door te typen is gewoon best wel handig en snel. Ook is het veel eenvoudiger om applicaties te ontwikkelen zonder grafische interface.</p> <p>Op ieder besturingssysteem \u2014 Linux, MacOS, Windows \u2014 is een shell, terminal of command prompt te vinden. Als je die opstart kun je op de zogeheten command line opdrachten intypen. Veelal zijn dit commando's om het bestandssysteem te navigeren en programma's op te starten.</p> <p>Wanneer je in Visual Studio Code een Python script start dan opent het een terminal onderin het scherm.</p>"},{"location":"cli/#commandos","title":"Commando's","text":"<p>Je hebt tot nu toe al heel wat commando's in de terminal getypt. Laten we een paar voorbeelden bestuderen: Terminal<pre><code>PS&gt; python script.py\n</code></pre> Als eerste vertel je welke applicatie je wilt gaan starten; in dit geval: <code>python</code>. Daarna geef je met het argument <code>script.py</code> aan welk Pythonscript je wilt uitvoeren. Vaak kun je ook opties meegeven zoals in: Terminal<pre><code>PS&gt; python -V\nPython 3.10.13\n</code></pre> Hiermee vraag je Python om het versienummer weer te geven. Soms kunnen opties zelf weer een argument meekrijgen. Bijvoorbeeld: Terminal<pre><code>PS&gt; python -m antigravity\n</code></pre> Met deze regel geef je Python de optie <code>-m</code> en die importeert een module (hier <code>antigravity</code>) en voert die uit. Probeer maar eens zelf wat er gebeurt als je dat commando uitvoert.</p> <p>Als applicaties veel verschillende functionaliteit hebben dan krijg je regelmatig te maken met een lange regel met een combinatie van argumenten en opties: Terminal<pre><code>PS&gt; conda create -n pythondaq -c conda-forge python pyvisa-py\n</code></pre> Uitgesplitst in argumenten en opties, met vierkante haken [] om aan te geven welke onderdelen bij elkaar horen, is dat:</p> <p>conda create [-n pythondaq] [-c conda-forge] [python pyvisa-py]</p> <p>Poetry argumenten</p> <ol> <li>Naast <code>conda create</code> heb je ook met andere argumenten gewerkt zoals <code>activate</code> en <code>install</code>. Welke argumenten ken je al van de applicatie <code>poetry</code>?</li> <li>Vraag de lijst met argumenten (commando's) op van Poetry met <code>poetry list</code>, hoeveel kende je nog niet?</li> </ol>"},{"location":"cli/#click","title":"Click","text":"<p>Als we gebruik willen maken van commando's in onze eigen applicatie moeten we weten wat de gebruiker in de terminal typt. Dit is mogelijk met <code>sys.argv</code>.1</p> cli.py<pre><code>import sys\nprint(sys.argv)\n</code></pre> <p>Alles wat we in de terminal typen wordt aan input meegegeven: Terminal<pre><code>PS&gt; python cli.py test 123   \n['cli.py', 'test', '123']\n</code></pre></p> <p>Met if-statements kunnen we acties verbinden aan bepaalde argumenten: cli.py<pre><code>import sys\nargs = sys.argv\nprint(args)\nif args[1] == \"test\":\nprint(f\"This is a test: {args[2]}\")\nelse:\nprint(f\"CommandNotFoundError: No command '{args[1]}'.\")\n</code></pre></p> <p>Als je meerdere opties en argumenten meegeeft dan wordt het veel werk om die in je script uit elkaar te plukken en ze goed te interpreteren. Om dat makkelijker te maken zijn er verschillende bibliotheken beschikbaar \u2014 waaronder een paar in de standard library. Een hele handige \u2014 die n\u00edet in de standard library zit maar w\u00e9l meegeleverd is met Anaconda \u2014 is Click.11</p> <p>Info</p> <p>Click maakt gebruik van decorators (<code>@decorator</code>). Om decorators te gebruiken, hoef je niet per se te weten hoe ze werken. Als je meer wilt weten over de werking ervan kijk dan de calmcode tutorial of lees de Primer on Python Decorators.</p> <p>Als kort voorbeeld \u2014 ge\u00efnspireerd op de documentatie van Click \u2014 nemen we het volgende script: hello.py<pre><code>def hello():\nprint(\"Hello physicist!\")\nif __name__ == \"__main__\":\nhello()\n</code></pre></p> <p>Dit script print de uitdrukking \"Hello physicist!\". We gaan dit aanpassen en maken het mogelijk om de naam en het aantal begroetingen te kiezen. Hiervoor gebruiken we Click. Allereerst moeten we <code>click</code> importeren en aangeven dat we de <code>hello()</code>-functie willen gebruiken als commando:</p> hello.py<pre><code>import click\n@click.command()\ndef hello():\nprint(\"Hello physicist!\")\nif __name__ == \"__main__\":\nhello()\n</code></pre> <p>Dit levert ons nog niet zoveel op, maar op de achtergrond is click wel degelijk aan het werk. De <code>@click.command()</code> houdt in de gaten wat er in de command line wordt ingetypt. Zo kunnen we de helpfunctie aanroepen door <code>--help</code> achter de naam van het script te zetten.</p> Terminal<pre><code>python hello.py --help\n</code></pre> <p>Help functie</p> <p>Neem het script <code>hello.py</code> over en vraag de helpfunctie op. Test dit met \u00e9n zonder <code>@click.command()</code>.</p> <p>Argument toevoegen</p> <p>Laten we zorgen dat we een naam als argument mee kunnen geven.</p> <ol> <li>In de code hieronder geven we met de regel <code>@click.argument(\"name\")</code> aan dat we van de gebruiker een argument verwachten. Zorg dat het argument ook gebruikt wordt in de functie <code>hello</code>:         hello.py<pre><code>import click\n@click.command()\n@click.argument(\"name\")\ndef hello(name):\nprint(f\"Hello {name}!\")\nif __name__ == \"__main__\":\nhello()\n</code></pre></li> <li>Draai <code>hello.py</code> eerst zonder een argument <code>python hello.py</code> en bekijk de foutmelding.</li> <li>Draai <code>hello.py</code> nu met een argument: <code>python hello.py Alice</code>.</li> </ol> <p>Warning</p> <p>Let er op dat je bij <code>@click.argument</code> de naam meegeeft die overeen komt met de namen van de parameters van je functie. In ons geval hebben we een argument <code>\"name\"</code>. Dit moet overeenkomen met de functiedefinitie <code>def hello(name)</code>.</p> <p>Argumenten zijn altijd verplicht en moeten in een vaste volgorde staan. Bij opties is dat anders. Je geeft met mintekens aan dat je een optie meegeeft. Veel opties hebben een lange naam en een afkorting (bijvoorbeeld <code>--count</code> en <code>-c</code>). Opties kunnen zelf weer een argument hebben (bijvoorbeeld <code>--count 3</code>). Het is handig om een standaardwaarde te defini\u00ebren. In dat geval mag de gebruiker de optie weglaten. We voegen een for-loop2 toe om de begroeting te herhalen.</p> hello.py<pre><code>import click\n@click.command()\n@click.argument(\"name\")\n@click.option(\n\"-c\",\n\"--count\",\ndefault=1,\n)\ndef hello(name, count):\nfor _ in range(count):\nprint(f\"Hello {name}!\")\nif __name__ == \"__main__\":\nhello()\n</code></pre> <p>Test hello</p> <p>Neem bovenstaande pythoncode over en test <code>hello.py</code>. Kun je 5 keer een begroeting printen met de naam van je assistent?</p> <p>Warning</p> <p>Let er op dat je bij <code>@click.option</code> de afkorting met 1 minteken meegeeft en de lange naam met 2 mintekens. De lange naam moet overeenkomen met de paramater van je functie. In ons geval hebben we een optie <code>\"--count\"</code> \u2014 de lange naam telt. Dit moet overeenkomen met de functiedefinitie <code>def hello(name, count)</code>.</p> <p>Het is handig om een korte helptekst toe te voegen. Dit gaat als volgt:</p> hello.py<pre><code>import click\n@click.command()\n@click.argument(\"name\")\n@click.option(\n\"-c\",\n\"--count\",\ndefault=1,\nhelp=\"Number of times to print greeting.\",\nshow_default=True,  # show default in help\n)\ndef hello(name,count):\nfor _ in range(count):\nprint(f\"Hello {name}!\")\nif __name__ == \"__main__\":\nhello()  \n</code></pre> <p>Helptekst toevoegen</p> <p>Voeg de helptekst toe en vraag de helptekst op zoals in de opdracht Help functie.</p> <p>Als je dit script gebruikt ziet dat er zo uit:</p> Terminal<pre><code>PS&gt; python hello.py --help\nUsage: hello.py [OPTIONS] NAME\nOptions:\n  -c, --count INTEGER  Number of times to print greeting.  [default: 1]\n  --help               Show this message and exit.\nPS&gt; python hello.py Alice\nHello Alice!\nPS&gt; python hello.py Alice -c 2\nHello Alice!\nHello Alice!\nPS&gt; python hello.py Alice --count 3\nHello Alice!\nHello Alice!\nHello Alice!\n</code></pre> <p>Pauze optie</p> <p>Breid het bovenstaande script <code>hello.py</code> uit met een optie om een korte pauze in te lassen na het printen van ieder <code>print()</code>-statement. Een pauze kun je inlassen met <code>time.sleep()</code>. Zorg er voor dat er zonder die optie g\u00e9\u00e9n pauze is en dat je met de optie kunt kiezen hoe lang er gewacht moet worden.</p> <p>Opties zonder argument werken als vlag \u2014 een soort aan/uitknop.3</p> Vlag <p>Gebruik een optie als vlag om de gebruiker te laten kiezen tussen het wel (tea) of niet (no tea) aanbieden van een kopje thee. Zorg dat er standaard tea wordt aangeboden.</p> <p>Argumenten en opties</p> <p>Bij opdracht Commando testen heb je een applicatie gemaakt om het kwadraat van een getal te printen. In deze opdracht gaan we het script uitbreiden om het getal als argument of optie mee te geven op de command line. Voer de volgende stappen uit:</p> <ol> <li>Maak een schone environment aan en installeer de applicatie (doet alles het nog?)</li> <li>Voeg click toe en pas het script aan zodat je het getal zelf kan kiezen.4 Wanneer kies je in het script voor een optie en wanneer voor een argument?</li> <li>Test de applicatie.</li> <li>Maak de applicatie compleet met helpteksten en default waardes.</li> </ol> Meer functies <ol> <li>Pas de applicatie aan zodat je kan kiezen tussen het kwadraat of de wortel van het getal. </li> </ol>"},{"location":"cli/#click-subcommandos","title":"Click subcommando's","text":"<p>Tot nu toe konden we maar \u00e9\u00e9n functie uitvoeren in onze applicatie. Maar het is ook mogelijk om subcommando's aan te maken zodat je met \u00e9\u00e9n programma meerdere taken kunt uitvoeren. Denk bijvoorbeeld aan <code>conda</code>. Je installeert packages met <code>conda install</code>, verwijdert ze met <code>conda remove</code>, maakt een environment met <code>conda create</code> en activeert het met <code>conda activate</code>.</p> <p>Subcommando's bedenken</p> <p> Je gaat de <code>pythondaq</code> applicatie straks verder uitbreiden zodat er veel meer mogelijk is dan nu. Wat zou je willen dat de applicatie allemaal kan? Welke subcommando's wil je gaan aanmaken? Overleg met elkaar om goede idee\u00ebn uit te wisselen.</p> <p>Een eenvoudig voorbeeldscript waarin de conda commando's <code>install</code> en <code>remove</code> worden nagebootst leggen we hieronder uit. Eerst de code:</p> <p>fakeconda.py<pre><code>import click\n@click.group()\ndef cmd_group():\npass\n@cmd_group.command()\n@click.argument(\"package\")\ndef install(package):\nprint(f\"Installing {package}...\")\n@cmd_group.command()\n@click.argument(\"package\")\ndef remove(package):\nprint(f\"Removing {package}...\")\nif __name__ == \"__main__\":\ncmd_group()\n</code></pre> In (de laatste) regel 18 roepen we de hoofdfunctie aan die we enigszins willekeurig <code>cmd_group()</code> genoemd hebben en die we bovenaan defini\u00ebren. In tegenstelling tot het <code>hello.py</code>-script doet deze functie helemaal niets (<code>pass</code>). We vertellen aan click dat we een groep van commando's aan gaan maken met de <code>@click.group()</code>-decorator in regel 3. Vervolgens gaan we commando's binnen deze groep hangen door niet de decorator <code>@click.command()</code> te gebruiken, maar <code>@cmd_group.command()</code> \u2014 zie regels 7 en 12. De namen van de commando's die worden aangemaakt zijn de namen van de functies. Dus regel 7 en 9 maken samen het commando <code>install</code>. Verder werkt alles hetzelfde. Dus een argument toevoegen \u2014 zoals in regel 8 \u2014 is gewoon met <code>@click.argument()</code>. Hier hoef je geen <code>cmd_group</code> te gebruiken.</p> <p>Warning</p> <p>Omdat de naam van een subcommando gelijk is aan de functienaam kan dat voor problemen zorgen wanneer je gereserveerde namen van python wilt gebruiken zoals: <code>import</code>, <code>return</code>, <code>lambda</code>. Of wanneer je de naam van het subcommando graag hetzelfde wilt hebben als een ander pythonfunctie zoals <code>sin</code> of <code>list</code>. Een oplossing is om de functienaam aan te passen en de subcommando naam expliciet aan click mee te geven bij <code>command</code>: <pre><code>@cmd_group.command(\"import\")\n@click.argument(\"package\")\ndef import_package(package):\nprint(f\"import {package}...\")\n</code></pre> We hebben nu een commando <code>import</code> aangemaakt \u2014 niet een commando <code>import_package</code>.</p> <p>Pyproject toml</p> <ol> <li>Maak een nieuw poetry project aan met de naam conda.  Terminal<pre><code>poetry new --src conda\n</code></pre></li> <li> <p>Voeg het bestand <code>fakeconda.py</code> toe (copy/paste de code hierboven).</p> </li> <li> <p>Overleg met elkaar5 en zorg dat de volgende uitvoer mogelijk wordt (je hoeft alleen tekst te printen): Terminal<pre><code>PS&gt; fake_conda install scipy\nInstalling scipy...\n</code></pre></p> </li> </ol> <p>Smallangle (meer leren)</p> <p>Met deze opdracht kun je testen hoe goed je het Python-jargon onder de knie hebt. Je zult het woord smallangle z\u00f3 vaak tegenkomen dat het je duizelt \u2014 maar jij weet precies over welk onderdeel we het hebben.</p> <ol> <li>Maak een nieuw poetry project (met een <code>src</code> indeling) aan met de naam <code>smallangle</code>.</li> <li>Let op de Octocat  voor <code>smallangle</code>, het moet dus een repository zijn (of worden). </li> <li>Maak een nieuw environment die <code>smallangle</code> heet met daarin alleen Python.</li> <li>Zet in het package <code>smallangle</code> een module <code>smallangle.py</code>.</li> <li>Plak de onderstaande code in <code>smallangle.py</code>:     <pre><code>import numpy as np\nfrom numpy import pi\nimport pandas as pd\ndef sin(number):\nx = np.linspace(0, 2 * pi, number)\ndf = pd.DataFrame({\"x\": x, \"sin (x)\": np.sin(x)})\nprint(df)\nreturn\ndef tan(number):\nx = np.linspace(0, 2 * pi, number)\ndf = pd.DataFrame({\"x\": x, \"tan (x)\": np.tan(x)})\nprint(df)\nreturn\nif __name__ == \"__main__\":\nsin(10)\n</code></pre></li> <li>Ga door naar stap 2 van de opdracht smallangle. Je mag stap 1 overslaan \u2014 dat werk heb je nu zelf al gedaan.</li> </ol> <p>smallangle</p> <p>Het project <code>smallangle</code> wordt met Poetry beheerd. Je gaat click aan de module <code>smallangle.py</code> toevoegen zodat je met subcommando's, argumenten en/of opties kunt werken. Tot slot maak je van smallangle een applicatie die je in de terminal kunt aanroepen.</p> <ol> <li>Ga naar GitHub naar <code>AnneliesVlaar/smallangle</code> en open de repository in GitHub desktop in GitHub Desktop en Visual Studio Code.</li> <li>Installeer de package in een nieuw environment.</li> <li>Run het script <code>smallangle.py</code> en los de errors op totdat het werkt.</li> <li> <p>Voeg click toe zodat je de subcommando's <code>sin</code> en <code>tan</code> hebt. Het aantal stappen (het aantal $x$-waardes tussen 0 en $2\\pi$) moet gekozen kunnen worden met een optie (geef een standaardwaarde mee, zodat de gebruiker de optie kan weglaten).</p> TypeError: 'int' object is not iterable <p>Probeer je de code te draaien maar krijg je een foutmelding zoals deze: Terminal<pre><code>Traceback (most recent call last):\nFile \"c:\\smallangle\\src\\smallangle\\smallangle.py\", line 28, in &lt;module&gt;\nsin(10)\nFile \"C:\\click\\core.py\", line 1157, in __call__     \nreturn self.main(*args, **kwargs)\n^^^^^^^^^^^^^^^^^^^^^^^^^^\nFile \"C:\\click\\core.py\", line 1067, in main\nargs = list(args)\n^^^^^^^^^^\nTypeError: 'int' object is not iterable\n</code></pre></p> <p>Dan komt dat doordat je <code>sin(10)</code> probeert uit te voeren, terwijl de functie al verClickt is. De functie verwacht een argument vanuit de terminal en geen integer vanuit het pythonscript. Pas je script aan zodat <code>if __name__ == \"__main__\":</code> naar de juiste functie verwijst en Click aanroept; niet <code>sin(10)</code>.</p> </li> <li> <p>Zorg dat smallangle een applicatie wordt die je aan kunt roepen met bijvoorbeeld <code>smallangle sin -n 9</code>.</p> </li> </ol> Smallangle (uitdaging) <p>Met het commando <code>approx</code> en een argument $\\epsilon$ moet het script de grootste hoek geven waarvoor nog geldt dat $\\lvert x - \\sin(x) \\rvert \\leq \\epsilon$, ofwel de grootste hoek waarvoor de kleine-hoekbenadering nog geldt met de opgegeven nauwkeurigheid. Doe dit op drie cijfers nauwkeurig (loop over .000, .001 en .002, etc. totdat de vergelijking niet meer geldt). N.B. besteed geen tijd aan het analytisch oplossen van de vergelijking. Een voorbeeld van de uitvoer: Terminal<pre><code>PS&gt; smallangle approx .1\nFor an accuracy of 0.1, the small-angle approximation holds\nup to x = 0.854.\n</code></pre></p>"},{"location":"cli/#docstrings","title":"Docstrings","text":"<p>Documentatie is vaak een onderschoven kindje, maar is ontzettend belangrijk. Als je zelf informatie opzoekt over bijvoorbeeld een voor jou onbekende Pythonbibliotheek dan vind je het heel fijn als er een duidelijke tutorial is. Als je code schrijft die ook door andere mensen gebruikt moet worden is documentatie nodig. Als de code langer mee moet gaan dan zeg een paar weken, dan helemaal. Want over een paar weken ben jij zelf een ander persoon. Hoe vervelend het ook is, code die je nota bene zelf geschreven hebt is over een paar weken niet meer glashelder. Je zult dan moeten uitzoeken hoe je ook alweer iets hebt gedaan of wat de gedachte erachter was.</p> <p>Tot nu toe heb je waarschijnlijk gebruik gemaakt van <code>#stukjes commentaar</code> om duidelijk te maken wat je code doet. Maar als je de applicatie aan het gebruiken bent en je wilt weten wat een bepaalde functie eigenlijk doet, moet je dus de code induiken op zoek naar de betreffende functie. Met docstrings \u2014 documentatiestrings \u2014 is dat verleden tijd. De documentatie over een functie kan automatisch gegenereerd worden vanuit je code met behulp van de docstring. Docstrings staat tussen 3 dubbele aanhalingstekens en hebben doorgaans een vaste structuur:6</p> <p>integers_up_to.py<pre><code>def integers_up_to(number):\n\"\"\"List integers up to a given number.\n    Args:\n        number (int): list integers up to this number\n    Returns:\n        list: containing the integers\n    \"\"\"\nif number &gt; 1:\nreturn list(range(1, number))\nelse:\nreturn []\nhelp(integers_up_to)\n</code></pre> De eerste regel geeft een korte samenvatting weer, na de witregel komt een langere samenvatting. Met <code>Args:</code> worden alle argumenten opgesomd die aan de functie worden meegegeven en <code>Returns:</code> geeft aan wat de functie teruggeeft. We kunnen de documentatie van deze functie opvragen met: <code>help(integers_up_to)</code>. Dat geeft het volgende resultaat: Terminal<pre><code>PS&gt; python integers_up_to.py \n    Help on function integers_up_to in module __main__:\n    integers_up_to(number)\n        List integers up to a given number.\n        Args:\n            number (int): list integers up to this number\n        Returns:\n            list: containing the integers\n</code></pre> Je zult niet altijd de <code>help()</code> functie gebruiken misschien, maar gebruik zoveel mogelijk docstrings \u2014 ze helpen ook enorm als je de code leest. Het is extra werk maar het verdient zich dubbel en dwars terug. Je hoeft geen proza te schrijven, maar wees duidelijk. Lees voor meer voorbeelden bijvoorbeeld de Google Python Style Guide.12</p>"},{"location":"cli/#docstring-generator","title":"Docstring generator","text":"<p>Om het gemakkelijker te maken om docstrings ook \u00e9cht te gaan schrijven, zijn er docstring generators ontwikkeld. Voor Visual Studio Code is er de extensie autoDocstring - Python Docstring Generator.13</p> <p>Autodocstring</p> <p>Kijk in Visual Studio Code bij extensions hoe je AutoDocstring kunt gebruiken. Kies daarvoor in de linkerkantlijn het goede icoon voor extensions en selecteer dan de <code>autoDocstring</code> extensie. Zoek in de documentatie naar hoe je automatisch (een deel van) de docstring genereert.</p> <p>Wanneer we voor de functie <code>integers_up_to()</code> de docstring generator gebruiken, krijgen we het volgende: <pre><code>def integers_up_to(number):\n\"\"\"_summary_\nArgs:\n    number (_type_): _description_\nReturns:\n    _type_: _description_\n\"\"\"\nif number &gt; 1:\nreturn list(range(1, number))\nelse:\nreturn []\n</code></pre></p> <p>Zo kunnen we gemakkelijk alles gaan invullen. Zo lang je niet op Esc drukt maar gewoon je tekst typt kun je met Tab naar het volgende veld en zo de docstring snel invullen. Het is mooi als je daarna onder de summary nog een uitgebreidere uitleg geeft van een paar zinnen. Vergeet ook niet om de docstring zonodig weer bij te werken als je een functie aanpast.</p>"},{"location":"cli/#docstrings-en-click-help","title":"Docstrings en Click <code>--help</code>","text":"<p>Docstrings werken ook heel handig samen met Click want ze worden gebruikt als we de helpfunctie aanroepen. We voegen docstrings toe aan fake-conda:</p> <p>fakeconda.py<pre><code>import click\n@click.group()\ndef cmd_group():\npass\n@cmd_group.command()\n@click.argument(\"package\")\ndef install(package):\n\"\"\"Install a conda package.\n    Args:\n        package (string): name of the package\n    \"\"\"\nprint(f\"Installing {package}...\")\n@cmd_group.command()\n@click.argument(\"package\")\ndef remove(package):\n\"\"\"Remove a conda package.\n    Args:\n        package (string): name of the package\n    \"\"\"\nprint(f\"Removing {package}...\")\nif __name__ == \"__main__\":\ncmd_group()\n</code></pre> Als we vervolgens de help functie aanroepen zien we de eerste regel van de docstrings verschijnen voor alle subcommando's: Terminal<pre><code>PS&gt; fake_conda --help\nUsage: fake_conda [OPTIONS] COMMAND [ARGS]...\nOptions:\n    --help  Show this message and exit.\nCommands:\n    install  Install a conda package.\n    remove   Remove a conda package.\n</code></pre> Daarna kun je uitleg vragen voor de subcommando's waarbij je de hele docstring te zien krijgt: Terminal<pre><code>PS&gt; fake_conda install --help\nUsage: fakeconda.py install [OPTIONS] PACKAGE\n    Install a conda package.\n    Args:     package (string): name of the package\nOptions:\n    --help  Show this message and exit.\n</code></pre></p> <p>Smallangle: docstring</p> <p>Voorzie de functies in <code>smallangle.py</code> die je gemaakt hebt bij de opdracht smallangle volledig van docstrings, zodat <code>smallangle --help</code> zinvolle informatie geeft.7</p> <p>Pythondaq: docstring</p> <ol> <li>Pak de <code>pythondaq</code> applicatie erbij. Zet bij alle functies een nuttige docstring.</li> <li>Schrijf ook docstrings voor de classes die je gemaakt hebt.</li> <li>Ga naar je model en houd je muis bij <code>set_output_voltage()</code> en zie daar verschijnt jouw fantastische omschrijving van de method die in de controller staat!</li> </ol>"},{"location":"cli/#documentatie-met-material-for-mkdocs","title":"Documentatie met Material for MkDocs","text":"Meer leren <p>Een bijkomend voordeel van docstrings is dat ze gebruikt kunnen worden om automatisch documentatie te genereren voor een heel project met behulp van bijvoorbeeld MkDocs of Sphinx.8 MkDocs is een documentatie generator en Material for MkDocs is daar de meestgebruikte uitbreiding op. Het wordt veel gebruikt om documentatie te schrijven voor software projecten. Een paar voorbeelden zijn bijvoorbeeld de website van de Accelerators and Beam Physics Computing groep op CERN14 of de nieuwe Textual bibliotheek15 om zogenaamde terminal user interfaces te maken, een tegenhanger van grafische interfaces. Behalve dat je vrij eenvoudig uitgebreide documentatie kunt schrijven kan MkDocs alle docstrings gebruiken om een referentie op te bouwen. De website voor de ECPC cursus is ook gebouwd met Material for MkDocs.</p> <p>Het voert tijdens deze cursus te ver om veel aandacht te besteden aan MkDocs. Maar aangezien documentatie zo belangrijk is wilden we het toch noemen! Voor een uitgebreide tutorial, zie Build Your Python Project Documentation With MkDocs.16</p>"},{"location":"cli/#command-line-interface-voor-ons-experiment","title":"Command-line interface voor ons experiment","text":"<p>In hoofdstuk Model-View-Controller heb je <code>pythondaq</code> uitgesplitst in model, view en controller. Wanneer we een command-line interface gaan bouwen dan is dat de softwarelaag tussen de gebruiker en de rest van de code. De command-line interface is dus een view. Het is helemaal niet gek om meerdere views te hebben, bijvoorbeeld een eenvoudig script zoals <code>view.py</code>, een command-line interface en een grafische interface. Hier gaan we ons richten op een command-line interface. We gaan een nieuw bestand <code>cli.py</code> aanmaken en dat langzaam opbouwen.</p> <p>Pythondaq: commando's</p> <ol> <li>Maak een nieuw bestand <code>src/pythondaq/cli.py</code>.</li> <li>Maak een <code>@click.group()</code> aan en voeg de subcommando's <code>list</code> en <code>scan</code> daaraan toe. Laat de commando's voorlopig alleen een willekeurige korte tekst printen; ze hoeven nu nog niet echt iets te doen. Merk op dat <code>list()</code> een Pythonfunctie is, dus daar moet je misschien nog iets mee.9</li> <li> <p>Zorg dat je de command-line applicatie met de naam <code>diode</code> in de terminal kunt aanroepen, inclusief de subcommando's <code>list</code> en <code>scan</code>, dus bijvoorbeeld:</p> Terminal<pre><code>PS&gt; diode list\nList, dit moet ik later nog afmaken.\n</code></pre> </li> </ol>"},{"location":"cli/#het-uitvoeren-van-een-meetserie","title":"Het uitvoeren van een meetserie","text":"<p>We gaan ons eerst richten op het uitvoeren van een volledige meetserie en het tonen van de resultaten daarvan aan de gebruiker.</p> <p>Info</p> <p>Bij het opgeven van argumenten en opties voor de spanning kan het belangrijk zijn om te controleren of de spanning \u00fcberhaupt wel een getal is tussen 0 en 3.3 V. Je kunt dit doen door de <code>type</code>-parameter in <code>@click.argument()</code> en <code>@click.option()</code>. Je kunt een Pythontype opgeven (bijvoorbeeld: <code>type=int</code> of <code>type=float</code>) en Click heeft speciale types zoals <code>type=click.FloatRange(0, 3.3)</code> voor een kommagetal tussen 0 en 3.3. Bekijk alle speciale types in de Click documentatie. Als je hiervan gebruik maakt hoef je niet zelf te controleren of de parameters kloppen. Click doet dat voor je.</p> <p>Pythondaq: <code>scan</code></p> <p>Met het commando <code>scan</code> wil je een meetserie uitvoeren over een spanningsbereik. Als een meting lang duurt is het niet erg als de resultaten pas n\u00e1 de meting worden weergegeven. Je applicatie moet straks het volgende kunnen:</p> <ol> <li>Print een lijst van metingen van de stroomsterkte d\u00f3\u00f3r en de spanning \u00f3ver de LED.</li> <li>De gebruiker moet het spanningsbereik (in volt) zelf kunnen opgeven met argumenten of opties.</li> <li>Geef ook de mogelijkheid de metingen op te slaan als CSV-bestand. Gebruik daarvoor een optie <code>--output FILENAME</code>. Wanneer met die optie een bestandsnaam wordt meegegeven sla je de metingen op en anders niet.</li> </ol> <p>Pythondaq: herhaalmetingen</p> <p>Als het goed is geeft je programma al een onzekerheid op de metingen terug op basis van herhaalmetingen. Bouw een optie in waarmee het aantal herhaalmetingen gekozen kan worden. Waarschijnlijk doe je dat al, maar bereken op basis van de herhaalmetingen de beste schatting van de stoomsterkte en de onzekerheid daarop, en ook voor de spanning over de LED.</p>"},{"location":"cli/#het-meetinstrument-kiezen","title":"Het meetinstrument kiezen","text":"<p>We kunnen de Arduino benaderen als we de naam weten die de VISA driver er aan heeft toegekend. Helaas kan \u2014 ook afhankelijk van het besturingssysteem \u2014 die naam veranderen als we de Arduino in een andere poort van onze computer steken of soms zelfs als we een andere Arduino op dezelfde poort koppelen. Met het commando <code>list</code> laten we alle apparaten zien die gevonden worden door de VISA drivers.</p> <p>Pythondaq: <code>list</code></p> <p>Schrijf het commando <code>list</code> zodat het een lijst geeft van de aangesloten instrumenten \u2014 zoals we in het vorige hoofdstuk al eens gedaan hebben.</p> <p>Pythondaq: choose device</p> <p>Pas het commando <code>scan</code> aan zodat je de poortnaam van een device kunt meegeven. Zorg dat het gekozen device ook daadwerkelijk wordt gebruikt in het model en de controller. Als je g\u00e9\u00e9n poortnaam opgeeft, geef dan een foutmelding.</p> <p>Pythondaq: <code>info</code></p> <p>Maak een commando <code>info</code> waarmee je de identificatiestring10 van een opgegeven instrument opvraagt en weergeeft. Je kunt het instrument met een optie of argument meegeven.</p> <p>Pythondaq: Helpteksten</p> <p>Loop al je commando's nog eens na en zorg ervoor dat er duidelijke helpteksten aanwezig zijn. Een nieuwe gebruiker moet met deze informatie met jouw command-line interface uit de voeten kunnen.</p> <p>Pythondaq: Grafiek</p> <p>Breid je <code>scan</code> opdracht uit met een optie om een grafiek te tekenen. Dat kan het makkelijkst met een boolean flag. Bijvoorbeeld: <code>--graph</code> om een grafiek te tekenen en <code>--no-graph</code> om dat niet te doen. De standaardkeuze kan zijn om dat niet te doen. Lees meer over boolean flags in de Click documentatie.</p> Pythondaq: <code>list --search</code> <p>Breid het commando <code>list</code> uit met een optie <code>--search</code> waarmee je niet een lijst van alle instrumenten krijgt, maar alleen de instrumenten die de zoekterm bevatten. Dus bijvoorbeeld: Terminal<pre><code>PS&gt; diode list\nThe following devices are connected to your computer:\nASRL/dev/cu.SOC::INSTR\nASRL/dev/cu.MALS::INSTR\nASRL/dev/cu.AirPodsvanDavid-Wireles-1::INSTR\nASRL/dev/cu.Bluetooth-Incoming-Port::INSTR\nASRL/dev/cu.usbmodem143401::INSTR\nPS&gt; diode list -s usbmodem\nThe following devices match your search string:\nASRL/dev/cu.usbmodem143401::INSTR\n</code></pre> De lijst met instrumenten kan er op Windows heel anders uitzien. Sterker nog, op Windows is de lijst meestal vrij saai. Maar leen eens heel even een Arduino van iemand anders en je ziet dat er dan twee poorten in de lijst verschijnen.</p> <p>Pas \u2014 na het uitbreiden van <code>list</code> \u2014 de commando's <code>scan</code> en <code>info</code> aan zodat het niet nodig is om de volledige devicenaam mee te geven, maar alleen een zoekterm.</p> <p>Op dit punt hebben we de functionaliteit van ons snelle script van het vorige hoofdstuk bereikt. Dit was veel meer werk, maar het is veel flexibeler. Als je wilt meten met een andere Arduino, een ander bereik, of een andere stapgrootte dan type je gewoon een iets ander commando in de terminal. Je hoeft geen scripts meer aan te passen. Als je na een tijdje niet meer precies weet hoe het ook alweer werkte allemaal kun je dat snel weer oppakken door <code>--help</code> aan te roepen.</p> <p>Alle subcommando's implementeren</p> <p>Kijk nog eens terug naar het lijstje subcommando's die je in opdracht Subcommando's bedenken hebt opgeschreven. Heb je alles ge\u00efmplementeerd? Wat zou je willen dat je nog meer kan instellen? Als er tijd over is, kijk dan of dit lukt.</p>"},{"location":"cli/#een-interface-met-stijl","title":"Een interface met stijl","text":"Meer leren <p>Ook command-line interfaces gaan met hun tijd mee. Vroeger waren ze per definitie zwart/wit en statisch, maar tegenwoordig worden interfaces vaak opgeleukt met kleur, emoji's en bewegende progressbars. Rich17 is een project dat in recordtijd heel populair is geworden. Het bestaat pas sinds november 2019 en heeft precies twee jaar later meer dan 31000 verzameld. Dat is veel \u2014 en de populariteit is sindsdien nog verder toegenomen.</p> <p>Rich is ontzettend uitgebreid en heeft heel veel mogelijkheden. Voor ons project kan het handig zijn om een progressbar te gebruiken of met Rich een tabel weer te geven. De documentatie18 van Rich is best goed, maar kan lastig zijn om een mooi overzicht te krijgen. Een serie van korte video tutorials kun je vinden bij calmcode. Iedere video duurt maar \u00e9\u00e9n tot twee minuten en laat mooi de mogelijkheden zien. Voor de functies die je wilt gebruiken kun je dan meer informatie opzoeken in de documentatie van Rich zelf.</p> <p>Rich</p> <p>Verrijk je interface met Rich. Doe dit naar eigen wens en inzicht.</p>"},{"location":"cli/#data-analyse","title":"Data-analyse","text":"Meer leren <p>Door de $I,U$-karakteristiek van de (lichtgevende) diode te analyseren is het mogelijk om de constante van Boltzmann te bepalen. De stoomsterkte door een diode wordt gegeven door de Shockley diodevergelijking. Zie ook hoofdstuk diode.</p> <p>Lukt het, om binnen de te bepalen onzekerheid, overeenkomst te vinden met de literatuurwaarde? Een LED is helaas geen ideale diode dus dit kan lastig zijn.</p> <p>Model fitten<p>Fit het model van Shockley aan je $I,U$-karakteristiek. Welke parameters kun je bepalen? Overleg met je begeleider!</p> </p> <ol> <li> <p>argv staat voor: argument vector, een lijst met argumenten\u00a0\u21a9</p> </li> <li> <p>Merk op in de code hieronder: <code>_</code> is de weggooivariabele in Python. Het gaat ons erom dat de loop een aantal keer doorlopen wordt en we hoeven niets te doen met de loop index.\u00a0\u21a9</p> </li> <li> <p>Zie voor meer informatie over flags de Click documentatie.\u00a0\u21a9</p> </li> <li> <p>Click maakt van alle argumenten een string, tenzij je een default waarde of een type definieerd. Gebruik <code>type=int</code>, <code>type=float</code> enzovoorts om aan te geven wat voor type object het argument moet worden\u00a0\u21a9</p> </li> <li> <p>Als je een commando in Poetry toevoegt dan heeft dat de opbouw <code>naam_commando = \"package.module:naam_functie\"</code>, welke functie moet uitgevoerd worden als je het commando aanroept?\u00a0\u21a9</p> </li> <li> <p>Die vaste structuur wordt niet door Python afgedwongen, maar is een goed gebruik. Er worden verschillende stijlen gebruikt. E\u00e9n van de meest gebruikte stijlen is door programmeurs van Google bedacht.12 \u21a9</p> </li> <li> <p>Als de docstring zeer uitgebreid wordt met meerdere argumenten dan wordt de helptekst van click onoverzichtelijk. Als je wilt dat alleen de korte samenvatting in de help verschijnt, zet dan na de korte samenvatting: <code>\\f</code>.\u00a0\u21a9</p> </li> <li> <p>Sphinx is van oudsher de standaard documentatiegenerator voor Pythonprojecten. Maar Sphinx is al redelijk op leeftijd en gebruikt als tekstformaat niet het bekende en zeer populaire Markdown maar het steeds minder populaire Restructured Text. MkDocs wordt steeds meer gebruikt en Sphinx steeds minder. Toch zul je Sphinx nog veel tegenkomen bij projecten omdat het na al die jaren zeer veel features heeft en zeer stabiel is.\u00a0\u21a9</p> </li> <li> <p>Zie ook de waarschuwing op warn:cmd_name \u21a9</p> </li> <li> <p>De identificatiestring van onze Arduino was <code>Arduino VISA firmware v1.0.0</code>. Je moet natuurlijk niet letterlijk deze string copy/pasten, maar de identificatie opvragen van het instrument. Welk firmwarecommando moest je daarvoor ook alweer gebruiken?\u00a0\u21a9</p> </li> <li> <p>Pallets. Click. URL: https://click.palletsprojects.com/.\u00a0\u21a9</p> </li> <li> <p>Google. Google python style guide. URL: https://google.github.io/styleguide/pyguide.html.\u00a0\u21a9\u21a9</p> </li> <li> <p>Nils Werner. Autodocstring - python docstring generator. URL: https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring.\u00a0\u21a9</p> </li> <li> <p>Accelerators and Beam Physics Computing Group. Accelerators and beam physics computing. URL: https://abpcomputing.web.cern.ch.\u00a0\u21a9</p> </li> <li> <p>Will McGugan and others. Textual. URL: https://textual.textualize.io.\u00a0\u21a9</p> </li> <li> <p>Martin Breuss. Build your python project documentation with mkdocs. URL: https://realpython.com/python-project-documentation-with-mkdocs/.\u00a0\u21a9</p> </li> <li> <p>Will McGugan. Rich. URL: https://github.com/willmcgugan/rich.\u00a0\u21a9</p> </li> <li> <p>Will McGugan. Rich documentation. URL: https://rich.readthedocs.io/en/latest/.\u00a0\u21a9</p> </li> </ol>"},{"location":"communicatie/","title":"Communicatie met een meetinstrument","text":"<p>Het hart van ieder experiment wordt gevormd door de metingen die worden uitgevoerd. Meetinstrumenten vervullen daarom een belangrijke rol bij het automatiseren van een experiment. De eerste stap die we zullen zetten tijdens het ontwikkelen van een applicatie is het communiceren met ons meetinstrument. We hebben gekozen voor een Arduino Nano 33 IoT,8 een zeer compact stukje elektronica rondom een ARM-microcontroller. Naast het uitvoeren van analoge spanningsmetingen kan dit model ook analoge spanningen afgeven dat voor ons heel nuttig gaat blijken. We hebben, speciaal voor dit vak, een stukje firmware1 ontwikkeld.9</p>"},{"location":"communicatie/#microcontrollers","title":"Microcontrollers","text":"<p>Computers \u2014 zoals de meesten van ons die kennen \u2014 zijn zeer krachtig en ontworpen om zo flexibel mogelijk te zijn. Ze draaien games, e-mail of rekenen klimaatmodellen door. Ze komen in veel vormen: desktops, laptops, tablets en telefoons. Ze bevatten daarom veel losse componenten: snelle processor (CPU), veel geheugen (RAM), veel permanente opslag (SSD), complexe interfaces (HDMI, USB) en een besturingssysteem waarmee je verschillende programma's kunt opstarten en de computer kunt beheren. Computers zijn behoorlijk prijzig.</p> <p>Een microcontroller daarentegen is veel eenvoudiger. Ze zijn ontworpen voor een beperkte en specifieke taak. Ze hebben veel verschijningsvormen \u2014 de meeste onherkenbaar. Je vindt microcontrollers in de vaatwasser, de magnetron, een draadloos toetsenbord en auto's (letterlijk tientallen verspreid over de hele auto). Ze hebben dan een beperkte taak: ze reageren op de knopjes op je dashboard om het klimaat te regelen of een raam te openen en ze sturen de kleppen in een verbrandingsmotor aan. Microcontrollers bevatten CPU, RAM en SSD vaak in \u00e9\u00e9n chip en hebben beperkte interfaces (vaak letterlijk losse pinnetjes die je moet verbinden). De CPU is relatief gezien traag en de hoeveelheid geheugen klein. Voor de beperkte taak is dat niet erg. Een besturingssysteem is niet nodig: als je hem aanzet draait hij meteen het enige programma dat ooit ingeladen is (dit heet dan firmware). Microcontrollers zijn goedkoop en daarom ook uitermate geschikt voor hobbyprojecten.</p> <p>Een Arduino is zo'n microcontroller. Vaak wordt een Arduino vergeleken met een Raspberry Pi \u2014 een andere goedkope computer. Maar een Raspberry Pi is \u00e9cht een computer (en daarmee ook complex). Daarmee is een Raspberry Pi veel veelzijdiger, maar ook duurder en is het complexer om een eenvoudig programma te draaien. Apparatuur zoals frequentiegeneratoren en oscilloscopen hebben vaak een microcontroller ingebouwd, maar soms ook een microcomputer analoog aan een Raspberry Pi. Dat maakt voor ons weinig verschil zolang we maar weten hoe we het instrument kunnen aansturen.</p>"},{"location":"communicatie/#communicatieprotocol","title":"Communicatieprotocol","text":"<p>Hoe praat je eigenlijk met hardware? Voor fabrikanten zijn er een paar opties:</p> <ol> <li>Je maakt gebruik van een al bestaand protocol (een bestaande standaard en je schrijft vervolgens documentatie specifiek voor jouw instrument (bijvoorbeeld de VISA-standaard 10, o.a. gebruikt door Tektronix digitale oscilloscopen 11)</li> <li>Je schrijft een proprietary2 protocol en een bijbehorende bibliotheek die software-ontwikke-laars moeten gebruiken.3 Voorbeelden zijn instrumenten van National Instruments 12 of de PicoScope digitale oscilloscopen4 13.</li> </ol> <p>De VISA-standaard is veelgebruikt, maar helaas komen proprietary protocollen veel voor. Dat is jammer, want in het laatste geval moet je het doen met de software die geleverd wordt door de fabrikant. Als die jouw besturingssysteem of favoriete programmeertaal niet ondersteunt heb je simpelweg pech.</p> <p>Wij gaan gebruik maken van de VISA-standaard. VISA staat voor Virtual Instrument Software Architecture en is h\u00e9\u00e9l breed en definieert protocollen om te communiceren via allerlei verouderde computerpoorten en kabels. Hieronder zie je een voorbeeld van verschillende poorten zoals RS232 en GPIB aan de achterkant van een Tektronix TDS210 oscilloscoop.</p> <p> Bron: Wikimedia Commons.</p> <p>Maar gelukkig ook via internet en USB, waarvan wij gebruik zullen maken. Onderdeel van VISA is de SCPI standaard 14, wat staat voor Standard Commands for Programmable Instruments. Dit onderdeel definieert een bepaald formaat voor commando's die we naar ons instrument zullen sturen. De lijst met commando's die door de firmware van onze Arduino worden ondersteund is gegeven in de appendix.</p>"},{"location":"communicatie/#eerste-stappen","title":"Eerste stappen","text":"<p>Waarschuwing</p> <p>Let op dat je de weerstand van 220 \u03a9 gebruikt! Een te grote weerstand zorgt ervoor dat je nauwelijks iets kunt meten, maar een te kleine weerstand zorgt ervoor dat de stroomsterkte door de Arduino te groot wordt. In dat geval zul je de Arduino onherstelbaar beschadigen. De kleurcodes voor weerstanden vind je in de appendix.</p> <p>Schakeling bouwen</p> <p>Als je geen kant-en-klare schakeling bij je werkplek hebt liggen, druk de Arduino in het breadboard en bouw een schakeling met een LED op de manier die is weergegeven in de figuur hieronder. De weerstand heeft een waarde van 220 \u03a9. De LED heeft aan \u00e9\u00e9n zijde een platte kant in de dikkere ring onderaan de plastic behuizing (goed kijken!); schakel die aan de kant van de aarde (de zwarte draad), dus aan de kant van de weerstand en niet aan de kant van de rode draad naar de Arduino. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED. Het heeft geen zin om naar het plaatje te kijken hoe het er \u00edn de LED uitziet \u2014 dat verschilt per type LED.</p> <p></p> <p>In de figuur hierboven is een Arduino Nano 33 IoT op een 400-punt breadboard geschakeld met een LED en een weerstand van 220 \u03a9. In een breadboard zijn in iedere rij alle kolommen A t/m E met elkaar verbonden (zo ook kolommen F t/m J). Draadjes die naast elkaar zijn geprikt zijn dus met elkaar verbonden. Zo zie je in de figuur \u2014 als je inzoomt \u2014 dat het rode draadje een verbinding maakt tussen pin A0 van de Arduino en de bovenste pin van de LED. De onderste pin van de LED is verbonden met de weerstand. De kleurcodes voor weerstanden vind je in de appendix. De kleur van de draden is niet belangrijk. Kies altijd draden met een handige lengte. De platte zijde in de ring van de LED wordt richting aarde geschakeld. De Arduino kan met deze schakeling een variabele spanning aanbrengen over de LED met weerstand, en de spanning meten over alleen de weerstand. </p> <p>Het equivalente circuit zoals je dat zou bouwen met twee losse voltmeters is hieronder weergegeven. De cijfers 0, 1 en 2 bij $U_0$, $U_1$ en $U_2$ zijn de kanalen waarmee de Arduino spanningen kan sturen of uitlezen. Dat wordt zometeen belangrijk.</p> <p></p> <p>Info</p> <p>Om met Python via het VISA-protocol te kunnen communiceren met apparaten hebben we specifieke packages nodig. Die gaan we installeren in een conda environment. Voor meer informatie over conda environments zie paragraaf Conda environments.</p> <p>Environment aanmaken</p> <p>Open een <code>Anaconda Prompt</code> die je kunt vinden via de zoekbalk van Windows. Maak de environment en installeer de juiste packages door een terminal te openen5 en in te typen:</p> <p>Terminal<pre><code>conda create -n pythondaq -c conda-forge python pyvisa-py\n</code></pre> Om de conda environment daadwerkelijk te gebruiken moet je die altijd eerst activeren met: Terminal<pre><code>conda activate pythondaq\n</code></pre></p> <p>Pyvisa in terminal</p> <p>Sluit de Arduino met de USB-kabel aan op de computer. Om de communicatie met de Arduino te testen maken we gebruik van <code>pyvisa-shell</code>. Open een terminal, zorg dat het goede conda environment actief is en type <code>help</code>: Terminal<pre><code>PS&gt; pyvisa-shell -b py\nWelcome to the VISA shell. Type help or ? to list commands.\n(visa) help\nDocumented commands (type help &lt;topic&gt;):\n========================================\nEOF  attr  close  exit  help  list  open  query  read  termchar  timeout  write\n(visa) help list\nList all connected resources.\n(visa) exit\n</code></pre></p> <p>Info</p> <p>We maken hier gebruik van de optie <code>-b py</code>, wat staat voor gebruik backend: python. Het kan namelijk dat er, naast <code>pyvisa-py</code>, ook andere backends, of drivers, ge\u00efnstalleerd staan op het systeem die de VISA-communicatie kunnen verzorgen. Als je bijvoorbeeld LabVIEW ge\u00efnstalleerd hebt, dan heb je de drivers van National Instruments. Maar de verschillende backends geven de aangesloten apparaten andere namen. Ook ondersteunen niet alle drivers alle types apparaten en moet je ze apart downloaden en installeren. Daarom maken we liever gebruik van de beschikbare Python drivers.</p> <p>Om verbinding te maken met onze Arduino gebruik je eerst <code>list</code> om te kijken welke apparaten aangesloten zijn en vervolgens <code>open</code> om de verbinding te openen. Je kunt makkelijk zien welk apparaat de Arduino is door \u00e9\u00e9rst <code>list</code> te gebruiken z\u00f3nder de Arduino aangesloten en vervolgens nog een keer m\u00e9t de Arduino aangesloten \u2014 het kan een paar seconden duren voor de Arduino wordt herkend. Het laatst bijgekomen apparaat is dan de Arduino. Een commando sturen en wachten op een antwoord doe je met <code>query</code>. Als we de identificatiestring willen uitlezen wordt dit bijvoorbeeld: <pre><code>(visa) list\n( 0) ASRL3::INSTR\n( 1) ASRL5::INSTR\n( 2) ASRL28::INSTR\n(visa) open 2\nASRL28::INSTR has been opened.\nYou can talk to the device using \"write\", \"read\" or \"query\".\nThe default end of message is added to each message.\n(open) query *IDN?\nResponse: ERROR: UNKNOWN COMMAND *IDN?\n\n(open) exit\n</code></pre></p> <p>Pyvisa error</p> <p>Probeer zelf ook de commando's <code>list</code>, <code>open</code>, en de <code>query</code> uit. Krijg je hetzelfde resultaat?</p> <p>Niet helemaal wat we hadden gehoopt! Als je goed kijkt in de documentatie van de firmware dan zie je dat er bepaalde terminator characters nodig zijn. Dit zijn karakters die gebruikt worden om het einde van een commando te markeren. Het is, zogezegd, een enter aan het eind van een zin. Dit mag je heel letterlijk nemen. Oude printers voor computeruitvoer gebruikten een carriage return (CR) om de wagen met papier (typemachine) of de printerkop weer aan het begin van een regel te plaatsen en een line feed (LF) om het papier een regel verder te schuiven. Nog steeds is het zo dat in tekstbestanden deze karakters gebruikt worden om een nieuwe regel aan te geven. Jammer maar helaas, verschillende besturingssystemen hebben verschillende conventies. Windows gebruikt nog steeds allebei: een combinatie van carriage return + line feed (CRLF). </p> Video Carriage Return Line Feed <p></p> <p>Maar MacOS/Linux/Unix gebruiken enkel een line feed (LF), want hoeveel meer heb je nodig? Af en toe is dat lastig, vooral wanneer er elektronica in het spel is want dan willen de regeleindes voor schrijven en lezen nog wel eens verschillend zijn.6 We gaan nu het gebruik van de karakters instellen:</p> <p><pre><code>(open) termchar\nTermchar read: None write: CRLF\n(open) termchar CRLF LF\nDone\n(open) termchar\nTermchar read: CRLF write: LF\n(open) query *IDN?\nResponse: Arduino VISA firmware v1.0.0\n</code></pre> Omdat de Arduino nu weet wanneer het commando voorbij is (door de LF aan het eind van de zin) krijgen we antwoord! Dat antwoord heeft dan juist weer een CRLF aan het eind dus <code>pyvisa-shell</code> weet wanneer het kan stoppen met luisteren en print het antwoord op het scherm. De karakters CRLF en LF zelf blijven onzichtbaar voor ons.</p> <p>Pyvisa regeleindes</p> <p>Stel zelf ook de regeleindes goed in en probeer of je antwoord krijgt van de Arduino. Heeft jouw Arduino de nieuwste firmware? Speel eens met de commando's en kijk of je de LED kunt laten branden of een spanning kunt meten. Bijvoorbeeld: <pre><code>(open) query OUT:CH0 768\nResponse: 768\n(open) query MEAS:CH2?\nResponse: 209\n</code></pre></p> <ul> <li>Wat is de minimale waarde waarbij de LED net licht geeft? </li> <li>Laat de spanning steeds verder oplopen; op een gegeven moment gebeurt er iets raars. </li> <li>Wat is de maximale waarde waarbij de LED zonder problemen kan branden?</li> </ul>"},{"location":"communicatie/#een-eenvoudig-script","title":"Een eenvoudig script","text":"<p>We hebben via de shell contact gelegd met de hardware. Nu wordt het tijd om, met de documentatie15 in de aanslag, hetzelfde vanuit Python te doen. Als je met een nieuw project begint is het helemaal geen gek idee om een kort script te schrijven waarin je wat dingen uitprobeert. Als alles lijkt te werken kun je het netjes gaan maken en gaan uitbreiden. We beginnen hier met een eenvoudig script en zullen dat daarna gaan verfijnen.</p> <p>We lopen het voorbeeldscript eerst regel voor regel door en geven het volledige script aan het eind. Allereerst importeren we de <code>pyvisa</code>-bibliotheek met <pre><code>import pyvisa\n</code></pre> Binnen pyvisa wordt alles geregeld met behulp van een Resource Manager. Die krijgen we met <pre><code>rm = pyvisa.ResourceManager(\"@py\")\n</code></pre> Die kunnen we bijvoorbeeld gebruiken om een lijst van alle beschikbare poorten te krijgen: <pre><code>ports = rm.list_resources()\n# Bijvoorbeeld: (\"ASRL3::INSTR\",)\n</code></pre> Om nu daadwerkelijk verbinding te gaan maken met de Arduino moeten we die openen. Daarvoor geven we de poortnaam op en vertellen we meteen wat de instellingen moeten zijn voor de regeleindes bij het lezen (CRLF, <code>\"\\r\\n\"</code>) en het schrijven (LF, <code>\"\\n\"</code>): <pre><code>device = rm.open_resource(\n\"ASRL3::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\n</code></pre> Ten slotte sturen we een query naar de Arduino: <pre><code>device.query(\"*IDN?\")\n</code></pre> Het volledige script \u2014 met een paar <code>print</code>-statements \u2014 ziet er dan als volgt uit:</p> <pre><code>import pyvisa\nrm = pyvisa.ResourceManager(\"@py\")\nports = rm.list_resources()\nprint(ports)\ndevice = rm.open_resource(\n\"ASRL3::INSTR\", read_termination=\"\\r\\n\", write_termination=\"\\n\"\n)\nprint(device.query(\"*IDN?\"))\n</code></pre> <p>Pyvisa in pythonscript</p> <p>Maak in een geschikte map een bestand <code>test_arduino.py</code> en kopieer daarin bovenstaande code. Selecteer vervolgens in Visual Studio Code je conda environment zodat je het script ook daadwerkelijk kunt runnen. Hoe je dat doet lees je aan het eind van de paragraaf Conda environments. Sluit alle terminals.</p> <p>Draaien we het script, dan zien we, afhankelijk van het systeem en het aantal apparaten dat verbonden is: <pre><code>('ASRL3::INSTR',)\nArduino VISA firmware v1.0.0\n</code></pre></p> <p>Het kan zijn dat het script bij jullie crasht met een foutmelding. Krijg je een <code>PermissionError</code>? Dan heb je vast nog een terminal openstaan waarin <code>pyvisa-shell</code> actief is. Een andere reden kan zijn dat het script probeert een poort te openen die bij jullie een andere naam heeft. Probeer met het lijstje instrumenten te raden welke de Arduino is en pas het script aan totdat het werkt.7</p> <p>Info</p> <p>In het vervolg gaan we commando's naar de Arduino sturen waar een variabele spanning in staat. Je kunt dit het makkelijkst doen met f-strings, zoals <pre><code>naam = \"Alice\"\nprint(f\"Hoi {naam}!\")\n</code></pre> en minder makkelijk met <pre><code>naam = \"Alice\"\nprint(\"Hoi %s!\" % naam)\n</code></pre> Als je (nog) geen idee hebt wat dat inhoudt, lees dan de tutorial Python 3's f-strings: an improved string formatting syntax op Real Python.16</p> <p>LED laten branden</p> <p>Schrijf een script dat de spanning over de LED laat oplopen van nul tot de maximale waarde. Wat gebeurt er als je de spanning laat oplopen tot twee keer die maximale waarde?</p> <p>KnipperLED</p> <p>Je kunt de LED ook andere dingen laten doen. Maak een bestand <code>knipperLED.py</code> en maak een van de onderstaande opdrachten:</p> <ul> <li>Laat de LED in een regelmatig tempo knipperen.</li> <li>Maak een breathing light \u2014 een lamp die langzaam aan en uit gaat gevolgd door een pauze in het tempo dat iemand in- en uitademt.</li> <li>Maak een heartbeat light \u2014 een lamp die twee keer kort na elkaar flitst gevolgd door een pauze in het tempo van een hartslag.</li> <li>Bedenk je eigen knipperritme.</li> </ul> <ol> <li> <p>Firmware is software die in hardware is geprogrammeerd. Bijvoorbeeld het computerprogramma dat ervoor zorgt dat je magnetron reageert op de knoppen en je eten verwarmd.\u00a0\u21a9</p> </li> <li> <p>Proprietary betekent dat een bedrijf of individu exclusieve de rechten heeft over het protocol of de software en anderen geen toegang geeft tot de details.\u00a0\u21a9</p> </li> <li> <p>Niet zelden zijn dergelijke bibliotheken maar op een paar besturingssystemen beschikbaar als driver. Gebruik je MacOS in plaats van Windows en het wordt alleen op Windows ondersteund? Dan kun je je dure meetinstrument dus niet gebruiken totdat je overstapt.\u00a0\u21a9</p> </li> <li> <p>Die overigens op vrijwel alle platforms en voor veel programmeertalen bibliotheken leveren.\u00a0\u21a9</p> </li> <li> <p>Start de applicatie <code>Anaconda Powershell Prompt</code> of start een terminal binnen Visual Studio Code met het menu Terminal &gt; New Terminal.\u00a0\u21a9</p> </li> <li> <p>De regeleindes voor de Arduinofirmware zijn verschillend voor lezen en schrijven. Dit heeft een oninteressante reden: bij het ontvangen van commando's is het makkelijk om alles te lezen totdat je \u00e9\u00e9n bepaald karakter (LF) tegenkomt. Bij het schrijven gebruikt de standaard <code>println</code>-functie een Windows-stijl regeleinde (CRLF).\u00a0\u21a9</p> </li> <li> <p>Tip: als je de Arduino loshaalt en weer aansluit is het de nieuwe regel in het lijstje.\u00a0\u21a9</p> </li> <li> <p>Arduino AG. Arduino nano 33 iot. URL: https://store.arduino.cc/arduino-nano-33-iot.\u00a0\u21a9</p> </li> <li> <p>David B.R.A. Fokkema. Arduino visa firmware. 2020. URL: https://github.com/davidfokkema/arduino-visa-firmware.\u00a0\u21a9</p> </li> <li> <p>IVI Foundation. Vpp-4.3: the visa library. 2018. URL: https://www.ivifoundation.org/downloads/Architecture Specifications/IVIspecstopost10-22-2018/vpp43_2018-10-19.pdf.\u00a0\u21a9</p> </li> <li> <p>Tektronix, Inc. URL: https://www.tek.com/.\u00a0\u21a9</p> </li> <li> <p>National Instruments Corp. URL: https://www.ni.com/.\u00a0\u21a9</p> </li> <li> <p>Pico Technology Limited. URL: https://www.picotech.com/.\u00a0\u21a9</p> </li> <li> <p>SCPI Consortium. Standard commands for programmable instruments (scpi). 1999. URL: https://www.ivifoundation.org/docs/scpi-99.pdf.\u00a0\u21a9</p> </li> <li> <p>PyVISA Authors. Pyvisa: control your instruments with python. URL: https://pyvisa.readthedocs.io/en/latest/.\u00a0\u21a9</p> </li> <li> <p>Joanna Jablonski. Python 3's f-strings: an improved string formatting syntax (guide). 2022. URL: https://realpython.com/python-f-strings/.\u00a0\u21a9</p> </li> </ol>"},{"location":"diodes/","title":"De diode: een p-n-overgang","text":"<p>In het introductie-experiment meten we de $I,U$-karakteristiek van een LED, een lichtgevende diode. In dit hoofdstuk gaan we iets dieper in op het aspect diode.</p> <p>Uiteindelijk is een diode een eenrichtingsweg voor stroom. Dat wil zeggen: er kan maar in \u00e9\u00e9n richting stroom door de diode lopen. De diode heeft een lage weerstand, maar als de polariteit wordt omgedraaid dan is de weerstand plots zeer groot en loopt er nauwelijks stroom. Diodes kunnen bijvoorbeeld gebruikt worden als gelijkrichter waarbij een wisselspanning met een stelsel diodes wordt omgezet in een gelijkspanning. Ook zijn er dus diodes die licht geven. Het fysisch principe achter een diode zorgt ervoor dat er, in sommige gevallen, zeer energiezuinig licht geproduceerd kan worden.</p>"},{"location":"diodes/#halfgeleiders","title":"Halfgeleiders","text":"<p>Metalen zijn geleiders. Ze hebben in de buitenste schil \u00e9\u00e9n of enkele valentie-elektronen die vrij kunnen bewegen in het kristalrooster. Een potentiaalverschil (veroorzaakt door bijvoorbeeld een batterij) zorgt voor een stroom van elektronen. Bij een isolator zitten alle elektronen vast in het rooster. Bij een halfgeleider is dat eigenlijk ook zo \u2014 de valentie-elektronen zijn nodig voor de bindingen tussen de atomen \u2014 maar door trillingen in het rooster is het relatief eenvoudig om af en toe een elektron-gat-paar te cre\u00ebren: een elektron ontsnapt en kan door het kristalrooster bewegen, maar de achtergebleven atomen missen nu een bindingselektron (het gat). Naburige elektronen kunnen heel eenvoudig in dit gat springen, maar laten dan weer een gat achter. Op deze manier kunnen gaten ook vrij door het rooster reizen. Een gat heeft effectief een positieve lading.</p>"},{"location":"diodes/#p-type-en-n-type-halfgeleiders","title":"p-type en n-type halfgeleiders","text":"<p>Halfgeleiders kunnen gedoteerd worden met andere stoffen. Feitelijk worden onzuiverheden in het kristalrooster ingebracht. Als je elementen uit de stikstofgroep (vijf valentie-elektronen) toevoegt aan de halfgeleider silicium (vier valentie-elektronen) dan worden de vreemde atomen in het kristalrooster gedwongen tot het aangaan van vier covalente bindingen met naburige siliciumatomen. Hierdoor blijft een elektron over. Dit elektron kan vrij door het rooster bewegen en op deze manier zijn er dus veel extra vrije elektronen aan het materiaal toegevoegd. Dit is een n-type halfgeleider omdat de ladingsdragers negatief geladen zijn.</p> <p>Op eenzelfde manier kunnen elementen uit de boorgroep (drie valentie-elektronen) worden toegevoegd aan silicium. Het is alleen niet mogelijk om vier covalente bindingen aan te gaan en er ontstaat plaatselijk een gat, een positieve ladingsdrager. Dit wordt dus een p-type halfgeleider genoemd. Hoewel gaten zich vrij door het rooster kunnen bewegen gaat dit wel trager dan bij elektronen.</p> <p>Merk op dat hoewel n-type en p-type halfgeleiders beschikken over respectievelijk negatieve en positieve ladingsdragers ze als geheel neutraal zijn. De onzuiverheden in het rooster blijven wel achter als ion als er geen vrije ladingsdrager in de buurt is. Immers, stikstof is neutraal met vijf valentie-elektronen dus als het vijfde elektron vrij door het rooster is gaan bewegen blijft een positief ion achter. Een booratoom blijft achter als een negatief ion als het gat vertrokken is (en een extra elektron de binding heeft opgevuld).</p>"},{"location":"diodes/#p-n-overgangen","title":"p-n-overgangen","text":"<p>Wanneer een p-type en een n-type halfgeleider elektrisch contact maken1 dan kunnen de elektronen en de gaten elkaar in het midden tegenkomen. Immers, door diffusie verplaatsen de elektronen en gaten zich willekeurig door het materiaal.</p> <p></p> <p>Elektronen (zwart) en gaten (wit) zijn de vrije ladingsdragers in respectievelijk n-type en p-type halfgeleiders. Wanneer beide typen elektrisch contact maken kunnen elektronen en gaten de grenslaag oversteken en recombineren.</p> <p>Het extra elektron kan een tekort aanvullen en alle naburige atomen kunnen zo vier covalente bindingen aangaan. Het elektron en het gat heffen elkaar dus op recombinatie. Dit is energetisch voordelig, maar er ontstaat in het midden een sperlaag2 waar geen vrije ladingsdragers meer aanwezig zijn. Dit betekent echter wel dat de onzuiverheden (ionen!) ervoor zorgen dat het materiaal niet langer neutraal is, maar elektrisch geladen. Waar de elektronen verdwenen zijn blijven positieve ionen achter en omgekeerd voor de gaten. Er ontstaat zo een elektrisch veld dat de elektronen en gaten tegenhoudt. Buiten de sperlaag is er geen elektrisch veld, net als bij een condensator.3 Elektronen en gaten kunnen niet langer de sperlaag oversteken.</p> <p></p> <p>Na recombinatie van elektronen (zwart) en gaten (wit) ontstaat er een sperlaag waar geen vrije ladingsdragers meer aanwezig zijn. De gedoteerde atomen vormen ionen in het rooster en er onstaat een postief geladen gebied en een negatief geladen gebied. Buiten de sperlaag is geen veld aanwezig, net als bij een condensator. Het resulterende elektrisch veld remt eerst en stopt uiteindelijk de diffusie van de elektronen en gaten. Er ontstaat een evenwicht waarbij vrije ladingsdragers de grenslaag niet meer kunnen oversteken.</p>"},{"location":"diodes/#sperrichting","title":"Sperrichting","text":"<p>Wanneer een diode wordt verbonden met een elektrisch circuit is de richting van het potentiaalverschil van belang. Wanneer het p-type halfgeleider verbonden wordt met de negatieve pool en het n-type met de positieve pool dan ontstaat er een elektrisch veld in de zelfde richting als dat van de sperlaag. Hierdoor wordt het veld sterker en zullen vrije ladingsdragers de sperlaag zeker niet kunnen oversteken. De diode staat in sperrichting en er zal nauwelijks4 stroom lopen. Een andere manier om dit in te zien is dat de gaten naar de negatieve pool worden getrokken en het gebied rond de sperlaag verlaten. Daar blijven nu dus nog meer negatieve ionen achter; de sperlaag wordt dikker. Idem aan de andere zijde van de sperlaag.</p>"},{"location":"diodes/#doorlaatrichting","title":"Doorlaatrichting","text":"<p>Wanneer we de polariteit omdraaien en de p-typezijde verbinden aan de positieve pool en de n-typezijde aan de negatieve pool dan ontstaat er een elektrisch veld van p-type naar n-type, tegengesteld aan het sperveld. Wanneer het potentiaalverschil op de diode \u2014 ten gevolge van een externe spanningsbron \u2014 lager is dan het potentiaalverschil over de sperlaag, dan zal er nog steeds geen stroom kunnen lopen. De sperlaag wordt echter wel dunner. Wanneer het externe potentiaalverschil groter is, dan keert het netto elektrisch veld in de sperlaag om en kunnen gaten en elektronen de grenslaag oversteken. Er loopt een stroom, maar wel anders dan in een geleider. De gaten en elektronen recombineren in het gebied van de grenslaag, terwijl er aan de metaal/halfgeleider grenzen nieuwe elektron-gatparen worden gevormd. Er stromen aan de zijde van de n-type halfgeleider dus continu elektronen vanuit het metaal naar de grenslaag en aan de zijde van de p-type halfgeleider stromen continu gaten van het metaal naar de grenslaag. Aan de grenslaag metaal/p-type halfgeleider verlaten elektronen de halfgeleider (en zo ontstaan de gaten). Voor de vrije ladingsdragers is de weerstand in de halfgeleider vrij laag waardoor de stroomsterkte flink kan oplopen. Een diode geleidt dus in de doorlaatrichting, maar pas boven een minimale doorlaatspanning.</p>"},{"location":"diodes/#lichtgevende-diode","title":"Lichtgevende diode","text":"<p>Wanneer een elektron en een gat elkaar tegenkomen is het energetisch gunstiger om te recombineren. Het elektron bindt zich aan de atomen in het rooster. Hierbij komt dus energie vrij. Meestal is dit in de vorm van roostertrillingen (warmte). Wanneer de materialen goed gekozen worden is het mogelijk om het energieverlies niet dominant via roostertrillingen te laten verlopen, maar via emissie van licht. Bij een doorzichtige halfgeleider kan het licht de grenslaag verlaten en uitgestraald worden. De LEDs die wij gebruiken bestaan uit een heel klein stukje halfgeleidermateriaal in een kegelvormige reflector om het licht naar boven te richten. Het geheel is ter bescherming in kunststof gegoten en de bolvorm zorgt voor een lenseffect om zoveel mogelijk licht in \u00e9\u00e9n richting uit te stralen.</p>"},{"location":"diodes/#de-iu-karakteristiek-van-een-diode","title":"De I,U-karakteristiek van een diode","text":"<p>Shockley, \u00e9\u00e9n van de uitvinders van de transistor, ontwikkelde een model voor p-n-overgangen. Volgens dat model7 wordt de stroomsterkte gegeven door</p> <p>\\begin{equation}   I = I_\\mathrm{S} \\left(e^\\frac{V_\\mathrm{D}}{nV_\\mathrm{T}} - 1 \\right), \\end{equation} met $I$ de diodestroom, $I_\\mathrm{S}$ de diodelekstroom, $V_\\mathrm{D}$ de spanning over de diode, $n$ de kwaliteitsfactor van de diode en $V_\\mathrm{T}$ de thermal voltage gegeven door \\begin{equation}   V_\\mathrm{T} = \\frac{kT}{q}, \\end{equation} met $k$ de constante van Boltzmann, $T$ de temperatuur van het materiaal en $q$ de elementaire lading. De diodelekstroom is de stroomsterkte ten gevolge van de minderheidsladingsdragers5 \u2014 het kleine aantal vrije elektronen in p-type halfgeleider en het kleine aantal gaten in n-type halfgeleider.</p> <p></p> <p>De stroom door een diode ten gevolge van de spanning over de diode.</p> <ol> <li> <p>In de praktijk worden er geen twee losse halfgeleiders aan elkaar verbonden maar wordt een enkel siliciumkristal zeer selectief plaatselijk verontreinigd: de ene helft om een p-type te maken, de andere helft om een n-type te maken.\u00a0\u21a9</p> </li> <li> <p>Engels: depletion zone.\u00a0\u21a9</p> </li> <li> <p>Zie o.a. Giancoli6 voor een beschrijving van het veld van twee vlakke en tegengesteld geladen schijven.\u00a0\u21a9</p> </li> <li> <p>Bedenk dat in een niet-gedoteerde halfgeleider door roostertrillingen elektron-gat-paren worden gevormd waardoor de halfgeleider een beetje geleidt. Dit gebeurt \u00f3\u00f3k in een gedoteerde halfgeleider. In n-type komen dus ook (weinig) gaten voor, en in p-type ook (weinig) elektronen. Deze kunnen de sperlaag wel oversteken en er zal dus toch een zeer kleine stroom kunnen lopen.\u00a0\u21a9</p> </li> <li> <p>Engels: minority charge carriers. \u21a9</p> </li> <li> <p>D.C. Giancoli. Physics for Scientists and Engineers with Modern Physics. Pearson Education, 2008. ISBN 9780131495081. URL: https://books.google.nl/books?id=xz-UEdtRmzkC.\u00a0\u21a9</p> </li> <li> <p>W. Shockley. The theory of p-n junctions in semiconductors and p-n junction transistors. Bell System Technical Journal, 28(3):435\u2013489, 1949. URL: https://onlinelibrary.wiley.com/doi/abs/10.1002/j.1538-7305.1949.tb03645.x, arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/j.1538-7305.1949.tb03645.x, doi:10.1002/j.1538-7305.1949.tb03645.x.\u00a0\u21a9</p> </li> </ol>"},{"location":"eindfeest/","title":"Eindopdracht","text":"<p>In het eerste jaar bepalen natuurkundestudenten een $I,U$-curve van een zonnepanneel. Zij vari\u00ebren met de hand de weerstand en lezen de stroom en spanning af. Wij gaan het experiment automatiseren zodat met \u00e9\u00e9n druk op de knop een $I,U$-curve getoond wordt. </p> <p>Deze opdracht is vergelijkbaar met wat we tot nu toe hebben gedaan. We gaan wederom een $I,U$-curve bepalen, maar niet van een diode maar van een zonnepaneel. Een zonnepaneel gedraagt zich \u2014 afhankelijk van de belastingsweerstand van het circuit \u2014 soms als een spanningsbron en soms als een stroombron. Het geleverde vermogen is ook zeer afhankelijk van deze belasting. Voor de werking van de zonnecel en een beschrijving van de $I,U$- en $P,R$-curves, zie hoofdstuk Zonnecel.</p>"},{"location":"eindfeest/#de-schakeling","title":"De schakeling","text":"<p>In de figuur hieronder is de equivalente schakeling die we gaan bouwen weergegeven.</p> <p></p> <p>We gebruiken een variabele weerstand $R_\\text{var}$ om de belasting van het zonnepaneel te vari\u00ebren. Deze is in serie geschakeld met een stroomsterktemeter om de stroomsterkte door het circuit te meten. Parallel is een spanningsmeter geschakeld waarmee we de spanning die geleverd wordt door het zonnepaneel kunnen meten.</p> <p>Merk op dat onze Arduino geen stroomsterktemeter heeft. We zullen dus de spanning over een kleine weerstand moeten meten om zo \u2014 met behulp van de wet van Ohm \u2014 de stroomsterkte te bepalen. Een ander probleem is dat de spanning die geleverd wordt door het zonnepaneel groter kan zijn dan de 3.3 V die maximaal op de pinnen mag staan. Hiervoor gaan we gebruik maken van een 3:1 spanningsdeler zodat de spanning altijd onder de 3.3 V zal blijven \u2014 volgens de specificaties komt de maximale spanning van het zonnepaneel in de meest ideale omstandigheden uit op 10 V.2 Het laatste probleem is de variabele weerstand: er zijn variabele weerstanden te koop waarbij de weerstand zeer nauwkeurig kan worden gekozen. Helaas is de minimale weerstand, ten gevolge van de vrij ingewikkelde interne schakelingen, te groot om de maximale stroom van een zonnepaneel te meten. Daarom maken we gebruik van een type veldeffect transistor, de MOSFET. Een MOSFET is feitelijk een soort schakelaar. Afhankelijk van de spanning die op de gate gezet wordt, is de weerstand tussen de source (aarde, minpool) en de drain (pluspool)1 te vari\u00ebren tussen nul en oneindig. Er is maar een relatief klein gebied waarin de weerstand snel verandert van oneindig naar nul.</p> <p>De schakeling voor onze Arduino is weergegeven in de figuur hieronder. Hier belasten we het zonnepaneel met een MOSFET. In serie hiermee staat een kleine weerstand van 4.7 \u03a9 waarover we de spanning meten ten behoeve van de bepaling van de stroomsterkte. De pin van de Arduino die verbonden is met de gate van de MOSFET is beschermd met een weerstand van 1 k\u03a9. Dit is belangrijk, want wanneer er een spanning gezet wordt op de gate kan er kortdurend een vrij grote stroom lopen. De gate gedraagt zich als een kleine capaciteit. Parallel aan de MOSFET + weerstand is een 3:1 spanningsdeler geschakeld met weerstanden van 2 M\u03a9 en 1 M\u03a9. </p> <p></p> <p>In de figuur hieronder is een Arduino Nano 33 IoT op een 400-punt breadboard geschakeld. Aan de linkerkant van het breadboard is de serieschakeling van de MOSFET met de kleine weerstand geplaatst. De pinnen van de MOSFET zijn van boven naar beneden de gate, de drain (+) en de source (-). De rechterkant bevat de spanningsdeler. Het zonnepaneel zelf wordt aan de $+$ en $-$ power rails aan de rechterkant van het bord geschakeld (de twee pinnen rechtsboven, zonnepaneel niet weergegeven). </p> <p></p> <ol> <li> <p>De namen source en drain verwijzen hier naar de elektronenstroom. Elektronen worden geleverd door de source (aard, minpool) en stromen dan naar de drain (pluspool).\u00a0\u21a9</p> </li> <li> <p>Seeed Studio. Small solar panel 55x70mm 0.5w. URL: https://www.seeedstudio.com/0-5W-Solar-Panel-55x70.html.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/","title":"FAQ: lijst conventies","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"faq/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"faq/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"faq/#ideeen","title":"Idee\u00ebn","text":"Schakeling bouwen <p>Als je geen kant-en-klare schakeling bij je werkplek hebt liggen, druk de Arduino in het breadboard en bouw een schakeling met een LED op de manier die is weergegeven in fig:arduino-LED-breadboard. De weerstand heeft een waarde van 220 \u03a9. De LED heeft aan \u00e9\u00e9n zijde een platte kant in de dikkere ring onderaan de plastic behuizing (goed kijken!); schakel die aan de kant van de aarde. Als de pootjes van de LED niet afgeknipt zijn, dan zit het korte pootje aan de platte zijde van de LED. Het heeft geen zin om naar het plaatje te kijken hoe het er \u00edn de LED uitziet \u2014 dat verschilt per type LED.</p> <p>Bestand: :<code>docs/index.md</code> en ook <code>pythondaq/models/diode.py</code>. Die vind je1 ook in de repository <code>davidfokkema/tailor</code>. Folder: <code>Oefenopdrachten</code>.</p> <p>Eenheden: 220 \u03a9 m/s of ms-1 of $220\\,ms^{-1}$ en $220\\,\\Omega$. We doen het eerste!!</p> <p>Voor menu's gaan we het zo doen: Menu &gt; Code &gt; Add repository en voor toetsen Ctrl+F.</p> <p>Een referentie naar een opdracht of figuur maak je aan door <code>&lt;div id=\"label\"&gt;&lt;/div&gt;</code> blokje als label neer te zetten. Verwijzen gaat dan met <code>[opdracht _label_](bronbestand.md#label)</code> waarbij je dus ook het bestand moet weten waarin het label gedefinieerd wordt.</p> <p>Voor vergelijkingen: \\begin{equation} f(x) \\sin x, \\end{equation} met $f(x)$ een functie van $x$.</p> <p>Voor code: hier een <code>print</code>-statement, maar meer code met: Titel<pre><code>print(\"Hello, world!\")\n</code></pre></p> <p>oefenopdracht</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa</p> <p>Inlever opdracht</p> <p>Deze opdracht lever je in. </p> <p>Meer leren</p> <p>Met deze opdracht kan je meer leren</p> <ol> <li> <p>en dit is dus een voetnoot\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/#uitdaging-wheels","title":"Uitdaging: wheels","text":"<p>Waarschuwing</p> <p>Let op dat dit ook kan.</p> <p>Info</p> <p>Of niet.</p> <p>En zo verder.</p>"},{"location":"firmware/","title":"Firmware","text":""},{"location":"firmware/#firmware","title":"Firmware","text":"<p>De firmware bestaat uit een gedeeltelijke implementatie van het VISA-protocol.1 Het voornaamste verschil bestaat uit het feit dat VISA voor ieder commando zowel een korte als een lange versie heeft. Zo zou je in de documentatie van een instrument het commando <code>MEASure</code> kunnen vinden. Je kunt dan zowel <code>MEAS</code> als <code>MEASURE</code> gebruiken om het commando te geven. In deze implementatie is het slechts mogelijk om de korte vorm te gebruiken.</p> <p>De nummering van de kanalen volgt de nummering van de Arduino hardware. Dus kanaal 0 is pin A0 op de Arduino, kanaal 1 is pin A1, enz. De digitale resolutie is ingesteld op 10 bits ($2^{10}$~stappen, ofwel waardes tussen 0 en 1023) en het analoge bereik is 0 V tot 3.3 V.</p> <p>De code is terug te vinden in de repository <code>/davidfokkema/arduino-visa-firmware</code>.2 Deze documentatie is voor versie~1.0.0. De commando's die geaccepteerd worden door de firmware zijn weergegeven in de tabel hieronder.</p> Commando Beschrijving <code>*IDN?</code> Geeft informatie over de hardware. <code>OUT:CH&lt;ch&gt; &lt;value&gt;</code> Zet een specifieke spanning <code>&lt;value&gt;</code> op uitvoerkanaal <code>&lt;ch&gt;</code>. Waardes mogen liggen tussen 0 (minimale spanning) en 1023 (maximale spanning). Voorbeeld: <code>OUT:CH0 1023</code> <code>OUT:CH&lt;ch&gt;?</code> Geef de huidige instelling voor de spanning terug op uitvoerkanaal <code>&lt;ch&gt;</code> in het bereik 0 tot 1023. Voorbeeld: <code>OUT:CH0?</code> <code>MEAS:CH&lt;ch&gt;?</code> Meet de spanning op invoerkanaal <code>&lt;ch&gt;</code> in het bereik 0 tot 1023. Voorbeeld: <code>MEAS:CH1?</code> <ol> <li> <p>IVI Foundation. Vpp-4.3: the visa library. 2018. URL: https://www.ivifoundation.org/downloads/Architecture Specifications/IVIspecstopost10-22-2018/vpp43_2018-10-19.pdf.\u00a0\u21a9</p> </li> <li> <p>David B.R.A. Fokkema. Arduino visa firmware. 2020. URL: https://github.com/davidfokkema/arduino-visa-firmware.\u00a0\u21a9</p> </li> </ol>"},{"location":"github/","title":"Versiebeheer met GitHub","text":""},{"location":"github/#versiebeheer","title":"Versiebeheer","text":"<p>Zodra je scripts wat ingewikkelder worden begin je tegen hele praktische problemen aan te lopen. Het werkt nu, maar je wilt een flinke aanpassing gaan doen. Werkt het straks nog wel? Hoe ingewikkelder het script, hoe ingewikkelder de wijzigingen en hoe minder het vertrouwen dat het in \u00e9\u00e9n keer gaat lukken. Misschien heb je wel eens de ervaring gehad dat het maar niet wil werken en dat je niet goed weet wat je precies had veranderd ten opzichte van toen het nog wel werkte. Veel mensen hebben de neiging om naast een <code>script.py</code> een <code>script-v1.py</code>, <code>script-v2.py</code>, enz. aan te maken. Soms zelfs een <code>script-eindversie.py</code> en met wat pech dan toch nog een <code>script-eindversie-definitief.py</code>. Niet heel fijn. Je ziet dan nog steeds niet goed wat er veranderd is (dat blijft naast elkaar leggen en zoeken) en je map loopt vol met overbodige scripts. Dit kan beter\u2026 met versiebeheer!</p> <p>Versiebeheer (Engels: version control) stelt je in staat om af en toe een momentopname te maken van al je bestanden in een bepaalde map, inclusief alle submappen. Dit doe je niet na iedere regel code, maar bijvoorbeeld wel als je een stukje code af hebt en getest hebt dat het werkt. Zo'n momentopname heet een commit. Hoe vaak je commit is aan jou; maar wacht niet te lang \u2014 dan is het geen versiebeheer meer.</p> <p>Je versiebeheersysteem geeft ondertussen duidelijk al je wijzigingen weer ten opzichte van de laatste commit. Ook kun je de wijzigingen tussen oudere versies bekijken. Alles is relatief: je kunt zien wat er veranderd is tussen twee weken terug en gisteren, of gisteren en vandaag; iedere commit kun je vergelijken met willekeurig iedere andere commit. Heb je iets verprutst en wil je een oude versie terughalen? Prima! Commit die ook, dan kun je zelfs dat weer terugdraaien later. Je verliest nooit meer je werk. En stukmaken mag!</p>"},{"location":"github/#git","title":"Git","text":"<p>Ruim tien jaar geleden werden er nog vele concurrerende systemen gebruikt. Die tijd is grotendeels voorbij. E\u00e9n van de nieuwste systemen, Git,1 wordt tegenwoordig door bijna iedereen gebruikt of ondersteund. Git is ontwikkeld door Linus Torvalds als alternatief voor het commerci\u00eble systeem dat gebruikt werd voor de ontwikkeling van de Linux kernel.7 Het begon als een zeer eenvoudig \u2014 en volkomen ongebruiksvriendelijk \u2014 programma. Later is het in een veel gebruiksvriendelijker jasje gestoken.</p> <p>Git werkt in principe via de command-line. Je geeft opdrachten in de map waar je broncode staat: toevoegen van wijzigingen aan de staging area, bekijken van de meest recente wijzigingen, committen van je code, teruggaan en werken met oudere versies, aanmaken van branches,2 je wijzigingen uploaden naar internet, enz. Het geheel van map met broncode en versiegeschiedenis wordt een repository genoemd.</p> <p>In deze cursus zullen we gebruik maken van een grafische applicatie die eenvoudiger werkt. Je kunt daarna \u2014 als je dat wilt \u2014 de stap maken naar de command-line waarmee je nog veel meer mogelijkheden tot je beschikking krijgt. Voor meer informatie over Git en het gebruik via de command-line, zie het boek Pro Git.8</p>"},{"location":"github/#github","title":"GitHub","text":"<p>Git is een distributed version control system (DVCS) wat wil zeggen dat er geen centrale server hoeft te zijn. Je kunt volledig offline werken in je eigen repository en je wijzigingen af en toe committen. Als je daar zin in hebt kun je je wijzigingen naar een collega sturen (pushen) of je kunt een collega toestemming geven om de wijzigingen op te halen (pullen). Je bouwt dan aan \u00e9\u00e9n grote versiegeschiedenis met kopie\u00ebn op meerdere computers. Je bent zo volledig onafhankelijk van bedrijven die servers in de lucht houden of bepalen wie er wel en niet toegang krijgt. Dat is fijn, maar een centrale plek om repositories neer te zetten heeft weer het grote voordeel dat je de wereld kunt laten zien wat voor moois je gemaakt hebt \u00e9n dat het samenwerking wel vermakkelijkt. Als iedereen uit je team regelmatig commits pusht naar een centrale server en daar vandaan ook ophaalt dan is iedereen altijd up-to-date.</p> <p>Er zijn tegenwoordig veel websites die een plek bieden voor Git repositories. De bekendste zijn GitHub, GitLab, Bitbucket en SourceForge. GitHub, aangekocht door Microsoft, is op dit moment het bekendste en grootste platform. Veel bekende softwareprojecten vinden daar hun thuis.</p> <p>Wij gaan werken met GitHub, je moet dan wel een (gratis) account aanmaken. Als student kom je ook nog in aanmerking voor een educatiekorting op een pro-account. Je betaalt dan nog steeds niets.</p> <p>Account aanmaken</p> <p>Ga naar https://github.com/ en klik rechtsboven op <code>Sign Up</code>. Maak een account aan onder je priv\u00e9-emailadres. Op deze manier blijf je toegang houden tot je account ook nadat je afgestudeerd bent.</p>"},{"location":"github/#github-desktop","title":"GitHub Desktop","text":"<p>Om het programmeurs makkelijker te maken met GitHub te werken heeft GitHub een desktop applicatie ontwikkeld.</p> <p>Repository toevoegen</p> <p>Maak op de volgende manier een repository voor je Pythonscripts:</p> <ol> <li>Maak \u2014 bijvoorbeeld vanuit Visual Studio Code \u2014 een map <code>Oefenopdrachten</code> en zet daarin alle python-bestandjes die je hebt gemaakt om te oefenen zoals de opdrachten Pyvisa in pythonscript en KnipperLED.</li> <li>Open GitHub desktop en log in met je GitHub account.</li> <li>File &gt; Add Local Repository. Kies de map <code>Oefenopdrachten</code>.</li> <li>Je kunt de repository niet toevoegen omdat de map weliswaar bestaat, maar nog geen bestaande repository is. Er verschijnt een waarschuwing met een stukje kleine blauwe tekst. Klik op <code>create a repository</code>.</li> <li>Vink <code>Initialize this repository with a README</code> aan.</li> <li>Kies bij <code>Git ignore</code> voor Python.3</li> <li>En bevestig dan met de blauwe knop <code>Create Repository</code>.</li> <li>Als je nu op de history klikt dan zie je dat er een <code>Initial commit</code> is met wat <code>git</code>-bestanden en de Pythonscripts die je in de map hebt gezet. Vanaf nu staat <code>Oefenopdrachten</code> in versiebeheer en houdt Git je wijzigingen bij.</li> </ol> <p>Het is ook mogelijk om een repository aan te maken via File &gt; New Repository. Gebruik dit v\u00f3\u00f3r de start van een project om een nieuwe map te maken met een lege Git repository.</p>"},{"location":"github/#commit","title":"Commit","text":"<p>Alle wijzigingen aan bestanden in de repository kun je vanaf nu bijhouden door regelmatig een commit te maken. Met een commit maak je als het ware een snapshot van alle bestanden en hang je daar een labeltje aan. Dit kan in GitHub Desktop, maar ook direct vanuit Visual Studio Code. Elke commit geef je een begeleidend schrijven mee. Je hoopt dat jij, maar ook je collega, na het lezen van het berichtje snel begrijpt wat er veranderd is \u00e9n waarom. Wanneer je bepaalde wijzigingen ongedaan wilt maken, kan je snel vinden bij welke commit je dan moet zijn. En als je dan je applicatie gaat uitbrengen op Github kun je de commit messages gebruiken om snel op te sommen wat de nieuwste versie van jou app kan!</p> <p>Commit</p> <p>Voer de volgende opdrachten uit:</p> <ol> <li>In Visual Studio Code, ga naar File &gt; Open Folder en kies de map waar je in opdracht Repository toevoegen een repository hebt aangemaakt.</li> <li>Open \u00e9\u00e9n van je Pythonscripts.</li> <li>Type een stukje code erbij \u2014 bijvoorbeeld een print-statement \u2014 en haal ergens anders iets weg. Bewaar het bestand.</li> <li>Links verschijnt een blauw bolletje 4 bij <code>Source Control</code> die laat weten dat er wijzigingen zijn ten opzichte van de vorige commit. Klik op <code>Source Control</code>.</li> <li>Onder <code>Changes</code> staat een lijst met bestanden waar wijzigingen in aan zijn gebracht. Kies welke bestanden je wilt committen door rechts op het +je te klikken. Deze bestanden komen nu op het podium te staan onder <code>Staged Changes</code>. Je kunt ook alle bestanden in een keer op het podium zetten door naast het kopje <code>Changes</code> op het +je te klikken.</li> <li>Schrijf een nuttige commit message. Dus niet: opdracht: commit, maar zoiets als: search for port name to open communication with device.5</li> <li>Klik op het vinkje om te committen. Gefeliciteerd! Je hebt je eerste commit gepleegd, vanaf nu kun je zonder angst dingen stuk maken want je kan altijd terug naar hoe het was!</li> </ol> <p>In GitHub Desktop zie je nu bij history de commit staan, met in een oogopslag alle wijzigingen.</p> <p>Info</p> <p>Als je wilt opzoeken hoe iets werkt bij GitHub Desktop, kijk dan in de documentatie: https://docs.github.com/en/desktop.</p>"},{"location":"github/#github_1","title":"GitHub","text":"<p>Om makkelijk je Git repository te delen met vrienden, collega's en de rest van de wereld kan je er voor kiezen om deze op GitHub te zetten. Je kunt dan je commits pushen naar GitHub en wijzigingen die je vrienden hebben gemaakt pullen zodat jij er ook weer aan verder kan werken. Van alle repositories die op GitHub staan \u00e9n openbaar zijn kun je de broncode clonen en zelf mee aan de slag! Laten we eens een kijkje nemen op GitHub.</p> <p>Tailor</p> <p>Als je nog nooit op GitHub bent geweest dan kunnen de pagina's nogal intimiderend overkomen. De informatiedichtheid is nogal hoog. Na een paar bezoeken weet je meestal wel waar je dingen kunt vinden. David heeft een data-analyse app geschreven dat Tailor heet en dat gebruikt wordt bij natuurkundepractica voor studenten medische natuurwetenschappen (MNW) en science, business and innovation (SBI). Laten we eens kijken wat daar allemaal opstaat.</p> <ol> <li>Zoek de repository <code>/davidfokkema/tailor</code> op GitHub op.</li> <li>Je komt terecht op de hoofdpagina, hier zie je een mappenstructuur met een aantal bestanden. Rechts daarvan staat een korte beschrijving onder het kopje <code>About</code>. Een uitgebreidere beschrijving vind je als je naar beneden scrollt onder <code>Readme</code>.</li> <li>Linksboven zie je een aantal tabbladen (code, issues, pull requests, ...), het tabblad <code>code</code> is de hoofdpagina met de mappenstructuur. Navigeer door de mappen, wat staat er op regel 15 van <code>plot_tab.py</code>?</li> <li>Ga terug naar de hoofdpagina, kijk onder het groen kopje met <code>code</code>. Hoeveel commits zijn er gemaakt? Klik op commits en daarna op een commit-message. Hoeveel regels zijn er weggehaald of bijgekomen?</li> <li>Je kan per bestand bekijken wanneer die is aangepast en wat er is aangepast met de history knop. Ga naar het bestand <code>pyproject.toml</code> en klik rechtsboven op <code>History</code>. Wat is er aangepast in <code>pyproject.toml</code> bij de commit Release v1.5.1? Je ziet ook welke bestanden nog meer zijn gewijzigd in deze commit, welk bestand is nog meer gewijzigd bij Release v1.5.1?</li> <li>Ga terug naar de hoofdpagina. Welke versie van Tailor is als laatste gereleased?</li> <li>Je kent het misschien wel, dat je een app gebruikt maar dat het niet helemaal goed werkt (bug), of je hebt een idee hoe het nog beter kan worden (enhancement). Daarvoor is op GitHub het tabblad <code>Issues</code>. Hoeveel bugs zijn er gerapporteerd? En hoeveel enhancements?</li> <li>Als het jou nu gelukt is om een bug te fixen, of je hebt een super handige feature ontworpen, dan kan je de eigenaren van de repository vragen om jouw code te implementeren door een pull request te sturen. Ga naar het tabblad <code>Pull requests</code>, klik op <code>Closed</code> en bekijk welke pull requests zijn ge\u00efmplementeerd.</li> <li>Het meest rechter tabblad <code>Insights</code> geeft je, tegen alle verwachtingen in, inzicht. Je kan zien door hoeveel mensen er aan gewerkt wordt. Kijk bij <code>Code frequency</code>, in welke periode is er het meest aan de code veranderd?</li> <li>Als je een repository goed/handig/slim/fijn vindt kun je dit aangeven met een ster. Klik daarvoor rechtsboven op star .</li> <li>Dan tot slot die ene, meest in het oogspringende groene <code>code</code> knop. Met die knop kan je de repository als zip-bestand downloaden of openen met GitHub desktop.</li> </ol> Clone repository <p>Clone de LMfit-py repository op GitHub:</p> <ol> <li>Zoek de repository op GitHub op (<code>lmfit/lmfit-py</code>)</li> <li>Kies Code &gt; Open with GitHub Desktop</li> <li>Kies zelf een map op je harde schijf om de repository te bewaren.</li> <li>Open Visual Studio Code en open de repository met File &gt; Open Folder.6 Als GitHub Desktop de ge\u00efnstalleerde VS Code herkent kan dat direct vanuit GitHub Desktop met Repository &gt; Open in Visual Studio Code.</li> <li>Open examplesREADME.txt. Verander in de eerste paragraaf <code>Below are examples</code> in <code>Below are different examples</code> en sla het bestand op.</li> <li>Schakel naar de GitHub Desktop applicatie en bekijk de wijziging.</li> <li>Linksonder kun je een korte beschrijving van je wijziging intypen en druk dan op de blauwe <code>Commit</code>-knop.</li> <li>Schakel, rechtsboven, naar <code>History</code>. Bovenaan staat jouw wijziging. Daaronder kun je alle wijzigingen van anderen bekijken.</li> </ol> <p>Aangezien je geen schrijfrechten hebt voor LMfit kun je niet kiezen voor <code>Push origin</code> \u2014 de knop die rechtsboven verschijnt. Met die knop duw je je wijzigingen naar GitHub zodat iedereen ze kan zien. Dat is mooi, maar je mag niet zomaar de repository van iemand anders wijzigen.</p> Push en pull <p>In eerdere opdrachten heb je repositories op de computer aangemaakt. Vanuit GitHub Desktop kan je een repository publiceren op GitHub. Commits kun je vervolgens pullen en pushen van en naar Github.</p> <ol> <li>Publiceer een repository op Github \u2014 bijvoorbeeld je oefenopdrachten of je <code>pythondaq</code>-repository. Verander iets in je code, commit en kijk hoe je dat naar GitHub kunt Pushen.</li> <li>Ga naar Github.com en verander daar iets in de code, commit en kijk hoe je dat naar de computer kan Pullen.</li> </ol> Git in de terminal <p>Tot nu toe heb je Visual Studio Code of GitHub Desktop gebruikt om te committen. Maar je kan Git ook bedienen via de terminal. De mogelijkheden van Git zijn in de terminal ook veel groter dan in de grafische applicaties die we gebruikt hebben.</p> <ol> <li>Open een repository in Visual Studio Code</li> <li>Gebruik de terminal in Visual Studio Code en bekijk de commit geschiedenis met het commando <code>git log</code>. Scroll door de commit messages met spatie.</li> <li>Zoek via https://initialcommit.com/blog/Git-Cheat-Sheet-Beginner het commando om een commit toe te voegen. Wijzig iets in je code en commit via de terminal.</li> <li>Dit waren twee dingen wat met GitHub Desktop ook kon, snuffel op het internet om te zien wat je met Git nog meer kunt.</li> </ol>"},{"location":"github/#branches","title":"Branches","text":"Meer leren <p>Soms wil je je code flink onder handen nemen of iets heel nieuws eraan toevoegen. Terwijl je bezig bent ga je natuurlijk eerst van alles stuk maken voordat je het weer werkend hebt gekregen. Maar ondertussen kan je oude functionaliteit van je code niet gebruiken. Of je bent samen met een vriend aan een package bezig en om de haverklap werkt jouw stukje code niet meer omdat ergens anders de code verbouwd wordt. Dan is het handig dat je vanaf het punt dat je code werkt een zijweg kan inslaan. Daarom zijn branches uitgevonden. Je kunt vanuit Github Desktop, vanuit Visual Studio Code en natuurlijk via de terminal een branch aanmaken.</p> <p>Branches</p> <ul> <li>Open een repository naar keuze en maak een nieuwe branch aan.</li> <li>Maak een aantal wijzigingen en commit.</li> <li>Ga terug naar de main branch.</li> <li>Merge de nieuwe branch in de main branch.</li> </ul> <ol> <li> <p>https://initialcommit.com/blog/How-Did-Git-Get-Its-Name\u00a0\u21a9</p> </li> <li> <p>Een branch is een splitsing in je versiegeschiedenis. Je kunt het gebruiken om over een langere tijd een grote wijziging uit te testen terwijl je af en toe heen en weer springt tussen je main branch en de nieuwe branch. Commits in de nieuwe branch blijven gescheiden. Later kun je ervoor kiezen om de wijzigingen in de nieuwe branch te mergen met je main branch, maar dat hoeft niet.\u00a0\u21a9</p> </li> <li> <p>De Git Ignore zorgt ervoor dat allerlei hulpbestanden van Python niet bewaard worden als commit. Alleen je eigen code wordt dan bewaard\u00a0\u21a9</p> </li> <li> <p>Zie je geen bolletje verschijnen? Kijk of je het bestand zeker weten hebt opgeslagen. Nog steeds geen blauw bolletje? Ga naar GitHub Dekstop en ga verder met stap 5.\u00a0\u21a9</p> </li> <li> <p>Je kunt je commit message opdelen in een titel (of summary) en een beschrijving. In Visual Studio Code, doe je dit door een witregel toe te voegen tussen de titel en de beschrijving.\u00a0\u21a9</p> </li> <li> <p>Als je vergeten bent waar je de repository ook alweer bewaard had kun je met Repository &gt; Show in Finder de folder openen.\u00a0\u21a9</p> </li> <li> <p>Linus Torvalds and others. Git. 2005. URL: https://git-scm.com.\u00a0\u21a9</p> </li> <li> <p>Scott Chacon and Ben Straub. Pro git: Everything you need to know about Git. Apress, second edition, 2014. URL: https://git-scm.com/book/en/v2.\u00a0\u21a9</p> </li> </ol>"},{"location":"gui/","title":"Graphical user interfaces","text":""},{"location":"gui/#grafische-interfaces-met-pyside","title":"Grafische interfaces met PySide","text":"<p>Als je een grafische applicatie schrijft roep je functies aan van het besturingssysteem om vensters, knoppen, menu's e.d. te laten tekenen en te reageren op muisklikken en het toetsenbord. Het lastige daaraan is dat een applicatie voor MacOS heel anders geschreven moet worden dan \u00e9\u00e9n voor Linux of Windows. Om die reden zijn er verschillende cross-platform bibliotheken ontwikkeld die als het ware tussen het besturingssysteem en je applicatie komen te staan. Je kunt dezelfde applicatie maken voor alle besturingssystemen en de bibliotheek kiest welke functies aangeroepen moeten worden om een venster te tekenen. Het voordeel is duidelijk: je hoeft maar \u00e9\u00e9n applicatie te schrijven die overal werkt. Het nadeel is dat je niet \u00e9cht gebruik kunt maken van alle functies en opties die het besturingssysteem biedt. Hier kiezen we voor de voordelen en gaan we gebruik maken van misschien wel de meest populaire optie: Qt.1 De bibliotheek <code>PySide6</code> is de offici\u00eble Pythonbibliotheek.</p> <p>Info</p> <p>Maak voor de oefeningen een nieuw conda environment <code>test-qt</code> met: Terminal<pre><code>conda create -n test-qt python=3.10\nconda activate test-qt\npip install pyside6 pyqtgraph\n</code></pre> Selecteer het nieuwe <code>test-qt</code> conda environment in Visual Studio Code en sluit alle oude terminals met het  -icoon.2</p> <p>Een minimale Qt-applicatie ziet er als volgt uit:</p> <p><pre><code>import sys\nfrom PySide6 import QtWidgets\nclass UserInterface(QtWidgets.QMainWindow):\npass\ndef main():\napp = QtWidgets.QApplication(sys.argv)\nui = UserInterface()\nui.show()\nsys.exit(app.exec())\nif __name__ == \"__main__\":\nmain()  \n</code></pre> Eerst importeren we een paar bibliotheken. Het draait uiteindelijk om de <code>UserInterface</code> class. De naam mag je zelf kiezen, zolang je maar aangeeft dat de class een afgeleide is van <code>QtWidgets.QMainWindow</code>, het hoofdvenster van je applicatie. In het hoofdgedeelte van het programma (gedefinieerd in de functie <code>main()</code>) maak je eerst een instance van <code>QtWidgets.QApplication</code>.3 Ook maken we een instance van onze eigen class en we roepen de <code>show()</code> method aan. Die hebben we niet zelf geprogrammeerd; die zit in de parent class <code>QMainWindow</code>. Als laatste roepen we de <code>exec()</code> method aan van onze <code>QApplication</code> en de uitvoer daarvan (een exit code) geven we mee aan de functie <code>sys.exit()</code>. Dat betekent dat als het programma afsluit met een foutmelding, dat een foutcode wordt meegegeven aan het besturingssysteem. Iemand anders die een script schrijft kan die code afvangen en daar iets mee doen.</p> <p>Een aantal elementen uit dit programma (<code>sys.argv</code>, <code>sys.exit()</code>) zijn strikt genomen niet noodzakelijk, maar wel good practice. Ook het schrijven van een <code>main()</code> functie is niet strikt noodzakelijk, maar het maakt het wel makkelijk om straks een zogeheten entry point te hebben als we weer een applicatie willen schrijven. In de <code>pyproject.toml</code> geven we dan aan dat we de <code>main()</code> functie willen aanroepen. Dat komt later.</p> <p>Minimale GUI</p> <ol> <li>Maak een nieuw bestand <code>example-gui.py</code>.</li> <li>Neem de pythoncode van de minimale Qt-applicatie over en test het in de <code>test-qt</code> conda environment.</li> </ol> <p>Elke keer als je een nieuwe Qt applicatie gaat schrijven kun je bovenstaand stukje code copy/pasten. Als we dit programma draaien hebben we echter een klein leeg venster op het scherm, zonder elementen. Die elementen kunnen we op twee manieren toevoegen: door ze te programmeren of door het gebruik van een visueel ontwerp met Qt Designer. Beide zullen in de volgende secties toegelicht worden.</p>"},{"location":"gui/#de-interface-programmeren","title":"De interface programmeren","text":"<p>We gaan de eenvoudige interface programmeren die hieronder is weergegeven:</p> <p></p> <p>We doen dat door de class <code>UserInterface</code> uit te breiden met widgets uit de <code>QtWidgets</code> bibliotheek.</p> <p>Het defini\u00ebren van layouts gebeurt in veruit de meeste opmaaksystemen met rechthoeken (Engels: boxes) die op verschillende manieren gestapeld worden \u2014 naast elkaar, boven elkaar, of op een rechthoekig grid bijvoorbeeld. Zulke systemen zijn ook hi\u00ebrarchisch: je stopt boxes in andere boxes.</p> <p>De layout van bovenstaande screenshot is als volgt opgebouwd. Het hoofdelement van de grafische interface is de <code>central widget</code>:</p> <p></p> <p>De <code>central widget</code> krijgt een verticale layout die we <code>vbox</code> noemen:</p> <p></p> <p>In de verticale layout plaatsen we een <code>textbox</code> en een horizontale layout die we <code>hbox</code> noemen:</p> <p></p> <p>In de horizontale layout plaatsen we twee <code>button</code>s:</p> <p></p> <p>Het stuk programma om bovenstaande layout op te bouwen geven we hieronder weer. We bespreken straks de code regel voor regel.</p> <p><pre><code>from PySide6.QtCore import Slot\nclass UserInterface(QtWidgets.QMainWindow):\ndef __init__(self):\n# roep de __init__() aan van de parent class\nsuper().__init__()\n# elk QMainWindow moet een central widget hebben\n# hierbinnen maak je een layout en hang je andere widgets\ncentral_widget = QtWidgets.QWidget()\nself.setCentralWidget(central_widget)\n# voeg geneste layouts en widgets toe\nvbox = QtWidgets.QVBoxLayout(central_widget)\nself.textedit = QtWidgets.QTextEdit()\nvbox.addWidget(self.textedit)\nhbox = QtWidgets.QHBoxLayout()\nvbox.addLayout(hbox)\nclear_button = QtWidgets.QPushButton(\"Clear\")\nhbox.addWidget(clear_button)\nadd_text_button = QtWidgets.QPushButton(\"Add text\")\nhbox.addWidget(add_text_button)\n# Slots and signals\nclear_button.clicked.connect(self.textedit.clear)\nadd_text_button.clicked.connect(self.add_text_button_clicked)\n@Slot()\ndef add_text_button_clicked(self):\nself.textedit.append(\"You clicked me.\")\n</code></pre> Allereerst defini\u00ebren we een <code>__init__()</code>. Helaas gaat dat niet zomaar. We schrijven namelijk niet helemaal zelf een nieuwe class (<code>class UserInterface</code>), maar breiden de <code>QMainWindow</code>-class uit (<code>class UserInterface(QtWidgets.QMainWindow)</code>). Door dat te doen zijn er heel veel methods al voor ons gedefinieerd. Daar hoeven we verder niet over na te denken, onze interface werkt gewoon. Het gaat mis als wij zelf nieuwe methods gaan schrijven die dezelfde naam hebben. Stel dat de parent class <code>QMainWindow</code> een method <code>click_this_button()</code> heeft. Als onze class ook een method <code>click_this_button()</code> heeft, dan zal die worden aangeroepen in plaats van de method uit de parent class. Dat is handig als je de parent method wilt vervangen maar niet zo handig als je de parent method wilt aanvullen, zoals nodig is bij <code>__init__()</code>. Immers, we willen onze eigen class initialiseren, maar we willen ook dat de parent class volledig wordt ge\u00efnitialiseerd.</p> <p>De oplossing is gelukkig vrij eenvoudig: we kunnen de <code>__init__()</code> van de parent class gewoon aanroepen en daarna ons eigen ding doen. De Pythonfunctie <code>super()</code> verwijst altijd naar de parent class, dus met <code>super().__init__()</code> wordt de parent class volledig ge\u00efnitialiseerd. Dat is dus het eerste dat we doen in regel 7.</p> <p>In de volgende opdrachten ga je zelf de hele applicatie opbouwen, zodat je precies weet wat in de code hierboven staat. </p> <p>Parent class initialiseren</p> <ol> <li>Breid het script <code>example-gui.py</code> van opdracht minimale GUI uit met een <code>__init__</code>-method. Deze hoeft verder nog niets te doen.</li> <li>Zorg dat de parent class volledig ge\u00efnitialiseerd wordt.</li> <li>Test of <code>example-gui.py</code> nog steeds werkt.</li> </ol> <p>Verder heeft iedere applicatie een centrale widget nodig. Niet-centrale widgets zijn bijvoorbeeld een menubalk, knoppenbalk of statusbalk.</p> <p>Central widget toevoegen</p> <ol> <li>Breid <code>example-gui.py</code> uit met een centrale widget.</li> <li>Geef aan dat dit het centrale widget gaat zijn (regels 11-12).</li> <li>Test of <code>example-gui.py</code> nog steeds werkt.</li> </ol> <p>Daarna gaan we layouts en widgets toevoegen. Layouts zorgen ervoor dat elementen netjes uitgelijnd worden. We willen het tekstvenster en de knoppen onder elkaar zetten en maken dus eerst een verticale layout. Aan die layout voegen we een textbox toe.</p> <p>Verticale layout toevoegen</p> <ol> <li>Breid <code>example-gui.py</code> uit met een verticale layout (regel 15).</li> <li>Maak een textbox (regel 16).</li> <li>Voeg de textbox toe aan de verticale layout (regel 17).</li> <li>Test of <code>example-gui.py</code> nog steeds werkt en of je tekst kan schrijven in de textbox.</li> </ol> <p>De knoppen zelf plaatsen we straks in een horizontale layout, dus die voegen we ook toe aan de <code>vbox</code>. En we maken de layout compleet door knoppen toe te voegen aan de <code>hbox</code>.</p> <p>Horizontale layout toevoegen</p> <ol> <li>Breid <code>example-gui.py</code> uit met een horizontale layout (regel 18).</li> <li>Voeg de horizontale layout toe aan de verticale layout (regel 19).</li> <li>Maak een clear button en voeg deze toe aan de horizontale layout (regels 21-22).</li> <li>Maak ook een add button en voeg deze toe aan de horizontale layout (regel 23-24).</li> <li>Test of <code>example-gui.py</code> nog steeds werkt.4</li> </ol> <p>Info</p> <p>Widgets zoals knoppen voeg je toe met <code>addWidget()</code>. Layouts voeg je toe aan andere layouts met <code>addLayout()</code>.</p> <p>De horizontale layout (voor de knoppen) moeten we expliciet toevoegen aan de verticale layout zodat hij netjes verticaal onder het tekstvenster verschijnt. Merk op dat de verticale layout <code>vbox</code> niet expliciet wordt toegevoegd (aan de centrale widget). De centrale widget (en alleen de centrale widget) krijgt een layout door bij het aanmaken van de layout de parent <code>central_widget</code> op te geven, dus: <code>QtWidgets.QVBoxLayout(central_widget)</code>. Alle andere widgets en layouts worden expliciet toegevoegd en daarvoor hoef je dus geen parent op te geven.</p> <p>Als laatste verbinden we de knoppen aan functies. Zodra je op een knop drukt wordt er een zogeheten signal afgegeven. Die kun je verbinden met een slot. Er zijn ook verschillende soorten signalen. Het drukken op een knop zorgt voor een clicked signal, het veranderen van een getal in een keuzevenster geeft een changed signal. Wij verbinden \u00e9\u00e9n knop direct met een al bestaande method van het tekstvenster <code>clear()</code> en de andere knop met een eigen method <code>add_button_clicked()</code>. De naam is geheel vrij te kiezen, maar boven de functiedefinitie moet je wel de <code>@Slot()</code>-decorator gebruiken. PySide kan dan net wat effici\u00ebnter werken.</p> <p>Slots en signals toevoegen</p> <ol> <li>Breid <code>example-gui.py</code> uit met slots en signals.</li> <li>Verbind de <code>Clear</code>-knop met de clear functie (regel 27).</li> <li>Definieer een <code>add_button_clicked()</code> functie (regels 30-32) en verbind deze aan de <code>Add text</code>-knop (regel 28).</li> <li>Test of <code>example-gui.py</code> nog steeds werkt en of de knoppen doen wat je verwacht.</li> </ol> <p>Er zijn veel verschillende widgets met eigen methods en signals. Je vindt de lijst in de Qt for Python-documentatie. Qt6 zelf bestaat uit C++ code en PySide6 vertaalt alle methods e.d. letterlijk naar Python. Vandaar ook de methodnaam <code>addWidget()</code> in plaats van <code>add_widget()</code>. In C++ en Java is het wel gebruikelijk om functies <code>CamelCase</code> namen te geven als <code>kijkDitIsEenMooieFunctie()</code>, maar in Python zijn we <code>snake_case</code> gewend, als in <code>kijk_dit_is_een_mooie_functie()</code>.</p> Volgorde layout aanpassen <p>De volgorde waarin je layout en widgets toevoegt bepaalt het uiterlijk van de grafische interface. Verander de code om de layout aan te passen (zet bijvoorbeeld de knoppen boven de textbox of zet de knoppen onder elkaar en naast de textbox).</p> <p>Hello world-knop toevoegen</p> <p>Probeer het volgende in <code>example-gui.py</code>:</p> <ol> <li>Voeg een derde knop <code>Hello, world</code> toe die de tekst Hello, world toevoegt aan het venster.</li> <li>Zet een hekje voor de <code>super()</code>-aanroep of haal de regel weg. Wat gebeurt er als je de code opstart? (Zet de regel weer terug!)</li> <li>Voeg onder de andere knoppen een <code>Quit</code>-knop toe. Als je daar op klikt moet de method <code>self.close()</code> aangeroepen worden. Daarmee sluit je het programma af. Denk erom dat als je het <code>clicked</code>-signaal verbind met <code>clicked.connect()</code> dat je de functie die je meegeeft nog niet moet aanroepen maar alleen moet meegeven zodat die later kan worden aangeroepen. Concreet betekent dit dat je de haakjes weglaat. Zie ook regel 27 en 28 van bovenstaande code.</li> </ol>"},{"location":"gui/#de-interface-ontwerpen-met-qt-designer","title":"De interface ontwerpen met Qt Designer","text":"<p>Info</p> <p>Qt Designer wordt ge\u00efnstalleerd met het <code>qt</code> package, dat standaard aanwezig is in Anaconda \u00e9n ge\u00efnstalleerd wordt als je <code>PySide6</code> installeert. Je start hem het makkelijkst op vanuit een terminal. Activeer je <code>test-qt</code> conda environment als dat nog nodig is en type <code>pyside6-designer</code>.</p> <p>Zodra interfaces wat ingewikkelder worden is het een hoop werk om ze te programmeren. Daarom kun je met Qt Designer de interface ook visueel ontwerpen. Je bewaart dat als een <code>.ui</code>-bestand. Vervolgens vertaal je het <code>.ui</code>-bestand naar een Pythonbestand dat je importeert in je eigen programma. De volledige class van het vorige voorbeeld kan dan vervangen worden door:</p> <p><pre><code>from ui_simple_app import Ui_MainWindow\nclass UserInterface(QtWidgets.QMainWindow):\ndef __init__(self):\nsuper().__init__()\nself.ui = Ui_MainWindow()\nself.ui.setupUi(self)\nself.ui.clear_button.clicked.connect(self.ui.textedit.clear)\nself.ui.add_button.clicked.connect(self.add_button_clicked)\nself.show()\n@Slot()\ndef add_button_clicked(self):\nself.ui.textedit.append(\"You clicked me.\")\n</code></pre> Waarbij de gebruikersinterface geladen wordt uit het bestand en we alleen nog maar de signals aan de slots hoeven te koppelen. In deze code defini\u00ebren we niet <code>self.ui.clear_button</code> of <code>self.ui.add_button</code>; die namen geven we aan de knoppen die we maken in Designer. De namen van alle objecten in Designer zijn daarna beschikbaar in onze code om bijvoorbeeld de signalen te koppelen. Merk op dat we nu niet meer <code>self.clear_button</code> gebruiken maar <code>self.ui.clear_button</code>. Alle widgets komen op deze manier onder een <code>.ui</code>-object te hangen.</p> <p>Designer gebruiken</p> <ol> <li>Open Designer en kies bij templates/forms voor <code>MainWindow</code>. Klik dan op Create. Ontwerp de user interface van het screenshot en gebruik dezelfde namen voor de widgets als het voorbeeld. Dus een <code>add_button</code> knop, een <code>clear_button</code> knop en een <code>textedit</code> tekstveld. Het is niet erg als je venster niet dezelfde grootte heeft. Qt Designer kiest een andere standaardafmeting.</li> <li>Bewaar het bestand als <code>simple_app.ui</code>.</li> <li>In een terminal in Visual Studio Code, navigeer naar dezelfde map waarin je je script uit de vorige opdracht hebt staan5 en type in:         Terminal<pre><code>pyside6-uic simple_app.ui -o ui_simple_app.py  \n</code></pre>         Deze stap moet je doen elke keer als je in Designer iets wijzigt. Gebruik de Up-toets om oude commando's terug te halen. Dat scheelt typewerk. Later, met Poetry, zullen we dit eenvoudiger maken.</li> <li>Copy/paste nu de voorbeeldcode in een nieuw script, fix eventuele importerrors en test de applicatie.</li> </ol>"},{"location":"gui/#functieplotter","title":"Functieplotter","text":"<p>Je hebt nu twee manieren gezien om een interface te bouwen: programmeren of Designer gebruiken. Let er wel op dat er dus een subtiel verschil is in het benaderen van de widgets. Je kunt bij zelf programmeren bijvoorbeeld <code>self.add_button</code> gebruiken, maar als je Designer gebruikt moet dat <code>self.ui.add_button</code> zijn.</p> <p>In de eindopracht willen we data weergeven op een scherm. We zullen dus nog moeten plotten. In de volgende opdrachten gaan we daarmee aan de slag.</p> <p>Je bent bekend met matplotlib en dat kan ook ingebouwd worden in Qt-applicaties. Helaas is matplotlib voor het gebruik in interactieve interfaces nogal traag zodra we te maken krijgen met meer data. We kiezen daarom voor een populair alternatief: PyQtGraph. E\u00e9n nadeel: de documentatie is niet fantastisch. Het geeft dus niets als je ergens niet uitkomt en je hebt hulp nodig van de assistent of een staflid.</p>"},{"location":"gui/#de-plotter-als-script","title":"De plotter als script","text":"<p>Om PyQtGraph te importeren en globale opties in te stellen moeten we bovenaan ons programma het volgende schrijven:</p> <p><pre><code>import pyqtgraph as pg\n# PyQtGraph global options\npg.setConfigOption(\"background\", \"w\")\npg.setConfigOption(\"foreground\", \"k\")\n</code></pre> Dit geeft zwarte letters op een witte achtergrond. Je kunt de opties weglaten en dan krijg je de standaardinstelling: grijze letters op een zwarte achtergrond. Het is maar wat je fijn vindt.</p> <p>Info</p> <p>Als je je GUI het liefst programmeert, gebruik dan de volgende regel om een plot widget te krijgen in de <code>__init__()</code>: <pre><code>self.plot_widget = pg.PlotWidget()\n</code></pre> Als je je GUI het liefst ontwerpt met Designer voegen we als volgt een plot widget toe:</p> <ol> <li>Voeg aan je interface een Graphics View toe;</li> <li>Klik er op om hem te selecteren en klik daarna op de rechtermuistoets;</li> <li>Kies voor Promote To ...;</li> <li>Bij Promoted class name vul je in <code>PlotWidget</code> en bij Header file vul je in <code>pyqtgraph</code> (zonder <code>.h</code> aan het eind);</li> <li>Dan klik je op Add en vervolgens op Promote.</li> </ol> <p>De stappen zijn weergegeven in onderstaand screenshot. Bij de rode pijl vind je Graphics View en in het rode kader staat wat je moet invullen om te promoten:</p> <p></p> <p>Nu je dit een keer gedaan hebt kun je voortaan op een Graphics View meteen kiezen voor Promote to &gt; PlotWidget en hoef je niets meer in te typen. Vergeet niet je widget nog even een handige naam te geven, bijvoorbeeld <code>plot_widget</code>.</p> <p>Handige widgets</p> <p>In onderstaande tabel zie je een lijst van zeer handige widgets die je vrijwel zeker nodig hebt. Als je nog meer widgets wilt gebruiken, kijk dan in de lijst van Designer en/of op https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/index.html#list-of-classes.</p> Naam class Naam Designer Beschrijving <code>QHBoxLayout</code> Horizontal layout Plaats widgets naast elkaar in deze container. <code>QVBoxLayout</code> Vertical Layout Plaats widgets onder elkaar in deze container <code>QFormLayout</code> Form Layout Een layout met twee kolommen: links tekstlabels en rechts widgets <code>QGroupBox</code> Group Box Verzamel widgets in een rechthoekig kader met linksbovenin een tekstlabel <code>QPushButton</code> Push Button Een drukknop met tekstlabel. Signals: <code>clicked</code>. <code>QLabel</code> Label Een tekstlabel <code>QComboBox</code> Combo Box Een knop voor een keuzemenu. Methods: <code>addItem, addItems</code>. Signals: <code>currentIndexChanged, currentTextChanged</code>. <code>QSpinBox</code> Spin Box Kies een geheel getal (intypen of met pijltjes selecteren). Signals: <code>valueChanged</code>. <code>QDoubleSpinBox</code> Double Spin Box Kies een kommagetal (intypen of met pijltjes selecteren). Signals: <code>valueChanged</code>. <p>Om daadwerkelijk een functie te plotten kun je deze code gebruiken:</p> <p><pre><code>import numpy as np\nclass UserInterface(QtWidgets.QMainWindow):\n...\ndef plot(self):\nx = np.linspace(-pi, pi, 100)\nself.plot_widget.plot(x, np.sin(x), symbol=None, pen={\"color\": \"k\", \"width\": 5})\nself.plot_widget.setLabel(\"left\", \"sin(x)\")\nself.plot_widget.setLabel(\"bottom\", \"x [radians]\")\n</code></pre> Je kunt uiteraard spelen met de instellingen zoals <code>symbol</code> en <code>pen</code> om te zien wat ze doen. Leeg maken kan met <code>self.plot_widget.clear()</code>.</p> <p>Functieplotter: plot</p> <p>Schrijf een script en ontwerp een (eenvoudige!) grafische interface waarmee je de functie $\\sin(x)$ plot in het domein $(0, 2\\pi)$. De applicatie hoeft verder niets te kunnen.</p> <p>Functieplotter: knoppen</p> <p>Voeg knoppen toe om het domein aan te passen. Maak bijvoorbeeld een <code>start</code>, een <code>stop</code> en een <code>numpoints</code> om het aantal punten te kiezen. Kies daarvoor ook een handige standaardwaarde. Zorg ervoor dat als je de waardes aanpast dat de functie automatisch opnieuw wordt geplot.</p> Functieplotter: functie kiezen drop-down menu <p>Gebruik een <code>QComboBox</code> om de functie te kunnen kiezen. Je moet hem leeg toevoegen aan je interface en vult hem vanuit je programma. Zoek de widget op in de documentatie om uit te zoeken welke functie je moet gebruiken om keuzemogelijkheden toe te voegen en welk signaal je moet koppelen om te zorgen dat de plot opnieuw wordt uitgevoerd als je de functie aanpast. Geef de gebruiker de keuzes $\\sin(x)$, $\\cos(x)$, $\\tan(x)$ en $\\exp(x)$.</p> Functieplotter: meer functies <p>Voeg aan de functiekiezer de functies $x$, $x^2$, $x^3$, en $\\frac{1}{x}$ toe. Je kunt daarvoor lambda functions gebruiken, maar dat is niet per se nodig.</p> Functieplotter: functies typen <p>Vervang de functiekiezer door een tekstveld waarin de gebruiker zelf functies kan typen zoals <code>x ** 2</code>, <code>sin(x)</code> of <code>1 / sqrt(x + 1)</code>. Gebruik daarvoor het <code>asteval</code> package.12 Documentatie vind je op https://newville.github.io/asteval/.</p> <p>Waarschuwing</p> <p>Gebruik nooit zomaar <code>eval()</code> op een string die iemand anders aanlevert. Anders kan iemand met typen in een tekstveld of het inlezen van een tekstbestand je computer wissen bijvoorbeeld, of malware installeren. Als je <code>eval()</code> wilt gebruiken, lees dan de sectie Minimizing the Security Issues of eval() in Python eval(): Evaluate Expressions Dynamically.13 Maar veel makkelijker is om <code>asteval</code> te gebruiken.</p>"},{"location":"gui/#een-grafische-interface-voor-ons-experiment","title":"Een grafische interface voor ons experiment","text":"<p>In het vorige hoofdstuk hebben we een tekst-interface geschreven voor ons experiment. We gaan nu een grafische interface schrijven voor hetzelfde experiment.</p> <p>We hebben tot nu toe veel moeite gedaan om onze code te splitsen volgens het MVC-model: werken in laagjes, goed nadenken over wat waar hoort. Als dat netjes gelukt is kunnen we relatief makkelijk \u00e9\u00e9n van die laagjes vervangen. We kunnen de <code>ArduinoVISADevice</code> vervangen door een <code>RaspberryPiDevice</code> of een <code>PicoScopeDevice</code>. Ook kunnen we een nieuwe applicatie schrijven voor ons bestaande experiment. We hoeven dan alleen een extra view te schrijven (de interface met de gebruiker) en de rest kunnen we hergebruiken. Misschien dat we hier en daar iets willen aanpassen maar zorg er dan voor dat je oude applicatie nog steeds werkt!</p> <p>We gaan nu \u2014 in stapjes \u2014 een grafische applicatie schrijven voor ons experiment.</p> <p>Info</p> <p>Je mag zelf kiezen of je de grafische interface gaat ontwerpen met Designer of dat je hem volledig programmeert.</p> <p>Info</p> <p>Als je Designer gaat gebruiken voor de grafische interface dan is het lastig dat je steeds <code>pyside-uic</code> moet aanroepen en moet zorgen dat je in de goede directory staat. We kunnen met Poetry taken aanmaken die je met een eenvoudig commando kunt laten uitvoeren. Die taken zijn alleen beschikbaar tijdens het ontwikkelen van je applicatie. Doe dit als volgt:</p> <ol> <li>Installeer Poe the Poet \u2014 een zogeheten task runner \u2014 als development dependency met:     Terminal<pre><code>poetry add --group dev poethepoet\n</code></pre>     We geven hiermee aan dat we dit package nodig hebben voor de ontwikkeling van onze applicatie, maar dat deze niet meegeleverd hoeft te worden als we de applicatie gaan delen met anderen.</li> <li>Voeg aan je <code>pyproject.toml</code> het volgende toe \u2014 uitgaande van de mappenstructuur in de <code>pythondaq</code> package en <code>mainwindow.ui</code> als naam van je <code>.ui</code>-bestand:     <pre><code>[tool.poe.tasks.compile]\nshell = \"\"\"\npyside6-uic src/pythondaq/mainwindow.ui -o src/pythondaq/ui_mainwindow.py\n\"\"\"\ninterpreter = [\"posix\", \"powershell\"]\n</code></pre>     Je kunt binnen de driedubbele aanhalingstekens meerdere regels toevoegen als je meerdere <code>.ui</code>-bestanden hebt \u2014 voor ieder bestand een regel.</li> <li>In bovenstaande regels is de naam na <code>tool.poe.tasks</code> de naam van de taak \u2014 in dit geval dus <code>compile</code>. Je kunt die naam zelf kiezen en vervolgens gebruiken om de taak uit te voeren in de terminal:     Terminal<pre><code>poe compile\n</code></pre>     En dat gaat een stuk sneller dan die lange <code>pyside-uic</code>-regel onthouden en intypen!</li> </ol> <p>Pythondaq: leeg venster</p> <p>Maak een nieuwe applicatie aan de hand van de code aan het begin van het hoofdstuk (minimale Qt-applicatie). De applicatie doet dus nog niets anders dan het tonen van een leeg venster.</p> <p>Pythondaq: plot scan</p> <p>Voeg aan je applicatie een <code>PlotWidget</code> toe \u2014 geprogrammeerd of met Designer. Laat je applicatie een scan uitvoeren (door het model te openen en aan te roepen) en laat het resultaat zien in een grafiek. Voor deze opdracht mag je nog gewoon de poortnaam in je code schrijven, net als start- en stop waardes e.d. De gebruiker hoeft nog niets te kunnen instellen. Dat komt straks.</p> <p>Foutenvlaggen plotten<p>Foutenvlaggen toevoegen aan een pyqtgraph is helaas iets minder intuitief dan bij matplotlib. Met breedte en hoogte geef je aan hoe groot de vlaggen zijn, de vlag is 2 keer zo hoog of breed als de onzekerheid. Samen met de $x$ en $y$ data maak je dan een <code>ErrorBarItem</code> aan die je expliciet toevoegt aan de plot.</p> </p> <pre><code>def plot(self):\n\"\"\"Clear the plot widget and display experimental data.\"\"\"\n# Genereer wat data als demo\nx = np.linspace(0, 2 * np.pi, 20)\ny = np.sin(x)\nx_err = 0.1\ny_err = np.random.normal(0, 0.2, size=len(x))\n# Maak eerst een scatterplot\nself.plot_widget.plot(x, y, symbol=\"o\", symbolSize=5, pen=None)\n# nu de foutvlaggen, met 'breedte' en 'hoogte' in plaats van x errors en y\n# errors let op: als je x_errors *lijsten* zijn, dan kun je niet gewoon 2 *\n# doen, maar wel als je eerst een NumPy array maakt:\n#\n# width = 2 * np.array(x_err)\n#\n# (we maken er voor de zekerheid eerst een array van)\nerror_bars = pg.ErrorBarItem(x=x, y=y, width=2 * x_err, height=2 * y_err)\n# we moeten de error_bars expliciet toevoegen aan de plot\nself.plot_widget.addItem(error_bars)\n</code></pre> <p>Pythondaq: knoppen</p> <p>Maak nu in je grafische interface widgets om de start- en stopwaardes, aantal metingen e.d. te kunnen instellen. Maak ook een startknop. Als je op de startknop drukt moet je applicatie een nieuwe meting uitvoeren.</p>"},{"location":"gui/#van-script-naar-applicatie","title":"Van script naar applicatie","text":"<p>Pythondaq: app</p> <p>Het is weer mogelijk om van het script een applicatie te maken die je aan kunt roepen vanaf de command line. Daar moeten we het volgende voor doen:</p> <ol> <li>Voeg een nieuw item toe voor je applicatie in de sectie <code>[tool.poetry.scripts]</code> in de <code>pyproject.toml</code> zoals je dat ook gedaan hebt voor je command-line-applicatie.</li> <li>Installeer je package opnieuw met:     <pre><code>poetry install\n</code></pre></li> </ol> <p>Test je applicatie.</p>"},{"location":"gui/#bewaren-van-meetgegevens","title":"Bewaren van meetgegevens","text":"<p>Je zou na iedere meting de gegevens automatisch kunnen wegschrijven naar bestanden zonder dat de gebruiker nog iets kan kiezen, maar je kunt ook gebruik maken van een <code>Save</code>-knop en dialoogvensters. Je kunt de knop koppelen aan een method <code>save_data()</code> en daarin de volgende regel opnemen:</p> <pre><code>filename, _ = QtWidgets.QFileDialog.getSaveFileName(filter=\"CSV files (*.csv)\")\n</code></pre> <p>De functie <code>getSaveFileName()</code> opent een dialoogvenster om een bestand op te slaan. Vanwege het filter argument geeft het venster (op sommige besturingssystemen) alleen CSV-bestanden weer. In elk geval geldt op alle besturingssystemen dat als de gebruiker als naam <code>metingen</code> intypt, dat het filterargument ervoor zorgt dat er automatisch <code>.csv</code> achter geplakt wordt.7 De functie geeft twee variabelen terug: <code>filename</code> en <code>filter</code>, die je zelf hebt meegegeven in bovenstaande aanroep. Die laatste kenden we dus al en gooien we weg met behulp van de weggooivariabele <code>_</code>.</p> <p>Het enige dat het dialoogvenster doet is de gebruiker laten kiezen waar en onder welke naam het bestand moet worden opgeslagen. Je krijgt echt alleen een pad en bestandsnaam terug, de data is niet opgeslagen en het bestand is niet aangemaakt. De variabele <code>filename</code> is echt niets anders dan een bestandsnaam, bijvoorbeeld: <code>/Users/david/LED-rood.csv</code>. Nadat je die bestandsnaam gekregen hebt moet je dus zelf nog code schrijven zodat het CSV-bestand wordt opgeslagen onder die naam.</p> <p>Pythondaq: save</p> <p>Voeg een <code>Save</code>-knop toe aan je interface om je metingen op te slaan als CSV-bestand. Controleer dat de gegevens ook inderdaad bewaard zijn.</p>"},{"location":"gui/#menus-taak-en-statusbalken","title":"Menu's, taak- en statusbalken","text":"Meer leren <p>Je kunt je grafische applicatie volledig optuigen met menu's of taakbalken. Ook kun je onderin je applicatie met een statusbalk weergeven wat de status is: gereed, aan het meten, foutcode, etc. Dat valt buiten het bestek van deze cursus, maar een mooie referentie is Python and PyQt: Creating Menus, Toolbars, and Status Bars.14 Als je vaker grafische applicaties wilt gaan maken dan moet je dat zeker eens doornemen!</p> <p>Pythondaq: statusbalk</p> <p>Maak een statusbalk die aangeeft wat de identificatiestring is van het device dat geselecteerd is. Maak ook een menu waarmee je een CSV-bestand kunt opslaan en een nieuwe meting kunt starten. Let op: je hebt dan een menu-item \u00e9n een knop die dezelfde method aanroepen. Je hoeft geen dubbele code te schrijven, maar moet de <code>save_data()</code>-method wel twee keer verbinden.</p>"},{"location":"gui/#selecteer-de-arduino","title":"Selecteer de Arduino","text":"<p>Je hebt nu waarschijnlijk nog de poortnaam van de Arduino in je code gedefinieerd als vaste waarde. Dat betekent dat als je de code deelt met iemand anders \u2014 bijvoorbeeld wanneer je de code inlevert op Canvas of wanneer je je experiment op een labcomputer wilt draaien \u2014 je het risico loopt dat je applicatie crasht omdat de Arduino aan een andere poort hangt. Zeker bij de overstap van Windows naar MacOS of Linux, of andersom! Je kunt dit op twee manieren oplossen:</p> <ol> <li>Je maakt een keuzemenu waarmee de gebruiker de Arduino kan selecteren;</li> <li>Je probeert de Arduino te detecteren op \u00e9\u00e9n van de poorten. De gebruiker hoeft dan niet te weten welke poort dat zou kunnen zijn. Het werkt dan vanzelf!</li> </ol> <p>Je kunt je voorstellen dat mogelijkheid 2 de voorkeur heeft! Helaas is dit moeilijker dan gedacht. Zodra je andere devices gaat openen en commando's gaat sturen om te ontdekken wat voor apparaat het is kunnen er gekke dingen gebeuren. Onder MacOS bijvoorbeeld kunnen Bluetooth luidsprekers en koptelefoons opeens ontkoppelen. We gaan dus toch voor keuze 1. Bijkomend voordeel van deze keuze is dat je meerdere Arduino's aan je computer kunt hangen en kunt schakelen \u2014 vooral handig als je meerdere experimenten vanaf \u00e9\u00e9n computer wilt aansturen.</p> <p>Pythondaq: selecteer Arduino</p> <p>Maak een keuzemenu (<code>QComboBox</code>) zodat je de Arduino kunt selecteren. Je zult in de <code>__init__()</code> eerst een lijst van devices moeten maken en die toe moeten voegen aan de widget. Zie ook de lijst met handige widgets en de documentatie. Het kan daarbij handig zijn om de device pas te openen als je een scan uitvoert en hem te sluiten (schrijf een soort <code>device.close()</code>) als de scan is afgelopen. In de controller werk je met een <code>pyvisa</code> device en die heeft al een <code>close()</code>-method.</p>"},{"location":"gui/#meerdere-dingen-tegelijkertijd-threads","title":"Meerdere dingen tegelijkertijd: threads","text":"meer-leren <p>Afhankelijk van de instellingen die we gekozen hebben kan een meting best lang duren. In ieder geval moeten we even wachten tot de meting afgelopen is en pas daarna krijgen we de resultaten te zien in een plot. Als een meting langer duurt dan een paar seconden kan het besturingssysteem zelfs aangeven dat onze applicatie niet meer reageert. En inderdaad, als we ondertussen op knoppen proberen te drukken dan reageert hij nergens op. Onze applicatie kan helaas niet twee dingen tegelijk. Kon hij dat wel, dan zouden we zien hoe de grafiek langzaam opbouwt tot het eindresultaat.</p> <p>De manier waarop besturingssystemen meerdere dingen tegelijk doen is gebaseerd op processes en threads. Een process is, eenvoudig gezegd, een programma. Als je meerdere applicaties opstart zijn dat allemaal processen. Besturingssystemen regelen dat ieder proces een stuk geheugen krijgt en tijd van de processor krijgt toegewezen om zijn werk te doen. Processen zijn mooi gescheiden en kunnen dus eenvoudig naast elkaar draaien. Het wordt iets lastiger als een proces meerdere dingen tegelijk wil doen. Dat kan wel, met threads. Het besturingssysteem zorgt dat meerdere threads naast elkaar draaien.8</p> <p>Threads geven vaak problemen omdat ze in zekere zin onvoorspelbaar zijn. Je weet niet precies hoe snel een thread draait, dus je weet niet zeker wat er in welke volgorde gebeurt. Dit kan leiden tot problemen waarvan de oorzaak maar lastig te vinden is. Google maar eens op <code>thread problems in programming</code>. We moeten dus voorzichtig zijn! Ook is het ombouwen van code zonder threads naar code met threads een klus waar makkelijk iets fout gaat. Het is dus belangrijk dat je in kleine stapjes je code aanpast en vaak test of het nog werkt.</p> <p>Info</p> <p>We gaan in het volgende stuk een kleine applicatie ombouwen van no-threads naar threads. We raden je ten zeerste aan om de code te copy/pasten en dan stapje voor stapje aan te passen zoals in de handleiding gebeurt. Probeer alle stappen dus zelf! Pas na stap 4 ga je aan de slag om je eigen code om te bouwen. Samenvattend: doorloop dit stuk handleiding twee keer. De eerste keer doe je de opdrachten met het demoscript, de tweede keer met je eigen code voor <code>pythondaq</code>.</p> view.pymodel.py <pre><code>import sys\nimport numpy as np\nfrom PySide6 import QtWidgets\nimport pyqtgraph as pg\nfrom model import Experiment\nclass UserInterface(QtWidgets.QMainWindow):\ndef __init__(self):\nsuper().__init__()\ncentral_widget = QtWidgets.QWidget()\nself.setCentralWidget(central_widget)\nvbox = QtWidgets.QVBoxLayout(central_widget)\nself.plot_widget = pg.PlotWidget()\nvbox.addWidget(self.plot_widget)\nstart_button = QtWidgets.QPushButton(\"Start\")\nvbox.addWidget(start_button)\nstart_button.clicked.connect(self.plot)\n# Maak een instance aan van Experiment\nself.experiment = Experiment()\ndef plot(self):\n\"\"\" Clear the plot widget and display experimental data. \"\"\"\nself.plot_widget.clear()\nx, y = self.experiment.scan(0, np.pi, 50)\nself.plot_widget.plot(x, y, symbol=\"o\", symbolSize=5, pen=None)\ndef main():\napp = QtWidgets.QApplication(sys.argv)\nui = UserInterface()\nui.show()\nsys.exit(app.exec())\nif __name__ == \"__main__\":\nmain()   \n</code></pre> <pre><code>import time\nimport numpy as np\nclass Experiment:\ndef scan(self, start, stop, steps):\n\"\"\" Perform a scan over a range with specified steps and return the scanned values. \"\"\"\nx = np.linspace(start, stop, steps)\ny = []\nfor u in x:\ny.append(np.sin(u))\ntime.sleep(0.1)\nreturn x, y\n</code></pre> <p>In regels 15--24 bouwen we een kleine user interface op met een plot widget en een startknop. We koppelen die knop aan de <code>plot()</code>-method. In regel 27 maken we ons experiment (het model) aan en bewaren die. In regels 30--34 maken we de plot schoon, voeren we een scan uit en plotten het resultaat. <code>model.py</code> vormt ons experiment. Eerst wordt een rij $x$-waardes klaargezet en dan, in een loop, wordt punt voor punt de sinus uitgerekend en toegevoegd aan een lijst met $y$-waardes. De <code>time.sleep(.1)</code> wacht steeds 0.1 s en zorgt hiermee voor de simulatie van trage metingen. En inderdaad, als we deze code draaien dan moeten we zo'n vijf seconden wachten voordat de plot verschijnt.</p> <p>In de volgende opdrachten gaan we de code stap voor stap ombouwen naar threads. Als we daarmee klaar zijn worden de metingen gedaan binnen de <code>scan()</code>-method van de <code>Experiment()</code>-class en verversen we ondertussen af en toe de plot. De <code>plot()</code>-method van onze user interface wordt regelmatig aangeroepen terwijl de meting nog loopt en moet dus de hele tijd de huidige metingen uit kunnen lezen. Dat kan, als de metingen worden bewaard in instance attributes.9</p> <p>Threads 0</p> <p>Neem <code>view.py</code> en <code>model.py</code> over en test de applicatie.</p> <ol> <li> <p>Uitspraak: het Engelse cute.\u00a0\u21a9</p> </li> <li> <p>Of in \u00e9\u00e9n keer met View &gt; Command Palette &gt; Terminal: Kill All Terminals \u21a9</p> </li> <li> <p>Die kun je eventuele command-line arguments meegeven die door Python in <code>sys.argv</code> bewaard worden. Meestal zijn die leeg, maar we geven ze gewoon door aan Qt.\u00a0\u21a9</p> </li> <li> <p>Waarom doen de knoppen niets als je er op klikt?\u00a0\u21a9</p> </li> <li> <p>Overleg met elkaar of met de assistent als je niet weet hoe dat moet.\u00a0\u21a9</p> </li> <li> <p>Je moet dan wel eerst nieuwe controllers schrijven (of krijgen van een collega) om deze nieuwe instrumenten aan te sturen. Maar als je die hebt kun je vrij eenvoudig wisselen.\u00a0\u21a9</p> </li> <li> <p>Het eerste deel van het argument (<code>CSV files</code>) is vrij te kiezen en geeft alleen informatie aan de gebruiker. Het deel tussen haakjes (<code>*.csv</code>) is het gedeelte dat echt van belang is. Het geeft de extensie die achter alle bestandsnamen geplakt wordt.\u00a0\u21a9</p> </li> <li> <p>Er is een subtiliteit. In Python draaien threads niet tegelijk, maar om de beurt. In de praktijk merk je daar niet veel van: threads worden z\u00f3 vaak per seconde gewisseld dat het lijkt alsof ze tegelijk draaien. Terwijl de ene thread steeds even tijd krijgt voor een meting kan de andere thread steeds even de plot verversen. In het geval van zwaar rekenwerk schiet het alleen niet op. Er draait maar \u00e9\u00e9n berekening tegelijkertijd dus threads of niet, het is even snel. Wil je echt parallel rekenen, dan moet je kijken naar de <code>multiprocessing</code> module om meerdere processen te starten in plaats van threads.\u00a0\u21a9</p> </li> <li> <p>Variabelen die we in een class defini\u00ebren door ze aan te maken met <code>self.</code> ervoor zijn instance attributes.\u00a0\u21a9</p> </li> <li> <p>Hier zie je een probleem met threads. Het k\u00e1n \u2014 in uitzonderlijke situaties \u2014 voorkomen dat de plot-functie n\u00e9t wil gaan plotten als de $x$-waardes al langer gemaakt zijn, maar de $y$-waardes nog niet. Die kans is heel klein en wij accepteren het risico. Schrijf je software voor een complex experiment dat drie dagen draait, dan is dit iets waar je echt rekening mee moet houden. Je moet dan gebruik gaan maken van zogeheten locks of semaphores maar dat valt buiten het bestek van deze cursus.\u00a0\u21a9</p> </li> <li> <p>Door een beetje ons best te doen kunnen we ervoor zorgen dat zowel de command-line interface als de grafische interface allebei gebruikt kunnen worden.\u00a0\u21a9</p> </li> <li> <p>Matt Newville. Asteval: minimal python ast evaluator. URL: https://newville.github.io/asteval.\u00a0\u21a9</p> </li> <li> <p>Leodanis Pozo Ramos. Python eval(): evaluate expressions dynamically. 2020. URL: https://realpython.com/python-eval-function/.\u00a0\u21a9</p> </li> <li> <p>Leodanis Pozo Ramos. Python and pyqt: creating menus, toolbars, and status bars. 2020. URL: https://realpython.com/python-menus-toolbars/.\u00a0\u21a9</p> </li> </ol>"},{"location":"gui/#stap-1-de-meetgegevens-altijd-beschikbaar-maken","title":"Stap 1: de meetgegevens altijd beschikbaar maken","text":"<p>We maken in de <code>scan()</code>-method lege lijsten <code>self.x</code> en <code>self.y</code>. Hier komen de meetgegevens in en die staan dus los van de lijst met $x$-waardes die je klaarzet. Met andere woorden: de variabele <code>x</code> is niet hetzelfde als de variabele <code>self.x</code>:</p> model.py <pre><code>class Experiment:\ndef scan(self, start, stop, steps):\nx = np.linspace(start, stop, steps)\nself.x = []\nself.y = []\nfor u in x:\nself.x.append(u)\nself.y.append(np.sin(u))\ntime.sleep(0.1)\nreturn self.x, self.y\n</code></pre> <p>We zorgen er zo voor dat de lijst met meetgegevens voor zowel de $x$- als de $y$-waardes steeds even lang zijn. Dit is nodig voor het plotten: hij kan geen grafiek maken van 50 $x$-waardes en maar 10 $y$-waardes.10 Ook moeten we er voor zorgen dat er altijd (lege) meetgegevens beschikbaar zijn \u2014 ook als de meting nog niet gestart is. Anders krijgen we voordat we een meting hebben kunnen doen een foutmelding dat <code>self.x</code> niet bestaat. We doen dat in de <code>__init__()</code>:</p> model.py <pre><code>class Experiment:\ndef __init__(self):\nself.x = []\nself.y = []\n...\n</code></pre> <p>We laten <code>self.x = []</code> (en idem voor <code>self.y</code>) ook staan in de <code>scan()</code>-methode zodat bij iedere nieuwe scan de oude meetgegevens worden leeggemaakt.</p> <p>Threads I</p> <p>Pas de code aan zodat de meetgegevens altijd beschikbaar zijn. Test je code, de applicatie moet nog steeds werken.</p>"},{"location":"gui/#stap-2-plot-de-meetgegevens-vanuit-het-experiment","title":"Stap 2: plot de meetgegevens vanuit het experiment","text":"<p>Nu we de meetgegevens bewaren als instance attributes van de <code>Experiment</code>-class kunnen we die ook plotten. We geven ze nog steeds terug als return value vanuit de <code>scan()</code>-method voor ouderwetse code,11 maar wij gaan nu de nieuwerwetse instance attributes gebruiken:</p> view.py <pre><code>class UserInterface(QtWidgets.QMainWindow):\n...\ndef plot(self):\n\"\"\" Clear the plot widget and display experimental data. \"\"\"\nself.plot_widget.clear()\nself.experiment.scan(0, np.pi, 50)\nself.plot_widget.plot(\nself.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n)\n</code></pre> <p>De code wordt hier niet sneller van \u2014 hij maakt nog steeds pas een grafiek als de meting helemaal is afgelopen \u2014 maar we bereiden de code wel voor op het gebruik van de instance attributes.</p> <p>Threads II</p> <p>Pas de code aan zodat je instance attributes gebruikt voor het plotten. Test je code, het moet nog steeds werken als vanouds.</p>"},{"location":"gui/#stap-3-threads","title":"Stap 3: threads","text":"<p>We gaan nu met threads werken. Je importeert daarvoor de <code>threading</code> module en maakt voor iedere thread een <code>threading.Thread()</code> instance. Deze heeft twee belangrijke parameters: <code>target</code> waarmee je de functie (of method) aangeeft die in de thread moet worden uitgevoerd, en <code>args</code> waarmee je argumenten meegeeft voor die functie of method. We maken een nieuwe method <code>start_scan()</code> waarmee we een nieuwe thread starten om een scan uit te voeren. We doen dit als volgt:</p> model.py <pre><code>import threading\nclass Experiment:\ndef start_scan(self, start, stop, steps):\n\"\"\"Start a new thread to execute a scan.\"\"\"\nself._scan_thread = threading.Thread(\ntarget=self.scan, args=(start, stop, steps)\n)\nself._scan_thread.start()\ndef scan(self, start, stop, steps):\n\"\"\" Perform a scan over a range with specified steps and return the scanned values. \"\"\"\nx = np.linspace(start, stop, steps)\nself.x = []\nself.y = []\nfor u in x:\nself.x.append(u)\nself.y.append(np.sin(u))\ntime.sleep(0.1)\nreturn self.x, self.y\n</code></pre> <p>In plaats van dat onze plotfunctie de <code>scan()</code>-method aanroept, moeten we nu de <code>start_scan()</code>-method aanroepen. Maar: die method start een scan en sluit meteen af, terwijl de daadwerkelijke meting op de achtergrond wordt uitgevoerd. De plotfunctie moet \u2014 in deze stap nog even \u2014 wachten tot de scan klaar is. Er is een manier om op een thread te wachten. Je moet daartoe de <code>join()</code> method van de thread aanroepen. In bovenstaande code hebben we de thread bewaard in de variabele <code>_scan_thread</code>, dus hij is voor ons beschikbaar:</p> view.py <pre><code>class UserInterface(QtWidgets.QMainWindow):\n...\ndef plot(self):\n\"\"\" Clear the plot widget and display experimental data. \"\"\"\nself.plot_widget.clear()\nself.experiment.start_scan(0, np.pi, 50)\nself.experiment._scan_thread.join()\nself.plot_widget.plot(\nself.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n)\n</code></pre> <p>Threads III</p> <ul> <li>Pas de code aan zodat je een thread opstart om de scan op de achtergrond uit te voeren. Roep in je plotfunctie de goede method aan en wacht tot de thread klaar is. Test je code. Wederom moet het werken als vanouds. </li> <li>Kijk ook eens wat er gebeurt als je niet wacht tot de metingen klaar zijn door de regel <code>self.experiment._scan_thread.join()</code> uit te commentari\u00ebren (hekje ervoor). Niet vergeten het hekje weer weg te halen.</li> </ul>"},{"location":"gui/#stap-4-plotten-op-de-achtergrond","title":"Stap 4: plotten op de achtergrond","text":"<p>We zijn er nu bijna. We gebruiken threads om de metingen op de achtergrond uit te voeren maar we wachten nog steeds tot de metingen klaar zijn voordat we \u2014 eenmalig \u2014 de grafiek plotten. In deze laatste stap doen we dat niet meer. Als je straks op de startknop drukt dan start de meting op de achtergrond. Ondertussen wordt er regelmatig geplot. Je ziet dan tijdens de metingen de plot opbouwen. We doen dat door het scannen en plotten van elkaar los te koppelen \u2014 niet meer samen in \u00e9\u00e9n functie \u2014 en door met een <code>QTimer</code> de plotfunctie periodiek aan te roepen. Kijk de code goed door.</p> view.py <pre><code>from PySide6 import QtWidgets, QtCore\nclass UserInterface(QtWidgets.QMainWindow):\ndef __init__(self):\nsuper().__init__()\n...\nstart_button.clicked.connect(self.start_scan)\n...            \n# Plot timer\nself.plot_timer = QtCore.QTimer()\n# Roep iedere 100 ms de plotfunctie aan\nself.plot_timer.timeout.connect(self.plot)\nself.plot_timer.start(100)\ndef start_scan(self):\n\"\"\"Starts a scanning process with specified parameters.\"\"\"\nself.experiment.start_scan(0, np.pi, 50)\ndef plot(self):\n\"\"\" Clear the plot widget and display experimental data. \"\"\"\nself.plot_widget.clear()\n# Twee regels code zijn verwijderd\nself.plot_widget.plot(\nself.experiment.x, self.experiment.y, symbol=\"o\", symbolSize=5, pen=None\n)\n</code></pre> <p>Hiermee zijn we klaar met de implementatie van threads. De gebruiker hoeft niet langer in spanning te wachten maar krijgt onmiddelijke feedback.</p> <p>Threads IV</p> <p>Pas de code op dezelfde manier aan zodat de metingen op de achergrond worden uitgevoerd terwijl je de plot ziet opbouwen. De code werkt nu niet als vanouds, en voelt veel sneller!</p> <p>Pythondaq: threads in je eigen code</p> <p>Doorloop nu opnieuw stappen 1 t/m 4 maar dan voor je eigen <code>pythondaq</code>-applicatie.</p>"},{"location":"gui/#stap-5-puntjes-op-de-i-events","title":"Stap 5: puntjes op de i: events","text":"Meer leren <p>Wanneer je op de startknop drukt, even wacht en dan w\u00e9\u00e9r op de startknop drukt, dan kun je zien dat er twee metingen tegelijk worden uitgevoerd op de achtergrond. Dat wil je voorkomen. Ook is het wel aardig om metingen tussentijds te kunnen stoppen. Dat is vooral handig als je merkt dat een meting veel te lang gaat duren. Verder is het ook nog zo dat we er nu met onze timer voor gezorgd hebben dat de plotfunctie meerdere keren per seconde wordt uitgevoerd \u2014 of er nu een meting loopt of niet.</p> <p>Je kunt dit oplossen met <code>threading.Event()</code> objecten. Dit zijn objecten met <code>set()</code>, <code>clear()</code> en <code>wait()</code> methods om gebeurtenissen aan te geven of er op te wachten. Zo kun je een event <code>is_scanning</code> aanmaken die je <code>set()</code> zodra een meting begint en <code>clear()</code> zodra de meting is afgelopen. Je controleert bij de start van de meting dan bijvoorbeeld eerst of de meting al loopt met <code>is_scanning.is_set()</code> en start alleen een meting als dat nog niet zo is.</p> <p>Ook kun je in de grafische interface na het starten van een meting de startknop onbeschikbaar maken met <code>start_button.setEnabled(False)</code> en weer beschikbaar maken met <code>start_button.setEnabled(True)</code>. De knop wordt dan tussendoor grijs. Dat kan handig zijn om duidelijk te maken dat een meting al loopt en dat je niet nogmaals op de startknop kunt drukken.</p> <p>Vergrendelen<p>Pas je code aan zodat je niet meerdere metingen tegelijk kunt starten. Zorg er ook voor dat de grafiek alleen geplot wordt tijdens de metingen (of tot kort daarna), maar niet de hele tijd.</p> </p>"},{"location":"kleurcodes/","title":"Kleurcodes voor weerstanden","text":"Kleur Cijferwaarde Vermenigvuldigingsfactor Tolerantie (%) Zilver --- 10-2 10 Goud --- 10-1 5 Zwart 0 100 --- Bruin 1 101 1 Rood 2 102 2 Oranje 3 103 0.05 Geel 4 104 0.02 Groen 5 105 0.5 Blauw 6 106 0.25 Paars 7 107 0.1 Grijs 8 108 0.01 Wit 9 109 --- <p>Helaas is het niet altijd mogelijk om de linkerkant van de weerstand van de rechterkant te onderscheiden. In dat geval moet je de weerstand beide kanten oplezen en vergelijken met je materialenlijst of de overige weerstanden om zeker te weten dat je de goede hebt gevonden. Bovenstaande weerstand heeft de waarde  220\u22c5100 \u03a9 \u00b1 1 %, en niet de waarde 100\u22c5102 \u03a9 \u00b1 2 %.</p>"},{"location":"mvc/","title":"Model-View-Controller","text":""},{"location":"mvc/#mvc-en-het-gebruik-van-packages","title":"MVC en het gebruik van packages","text":"<p>MVC staat voor Model-View-Controller en is een belangrijk, maar wat diffuus concept in software engineering en is vooral van toepassing op gebruikersinterfaces. Het belangrijkste idee is dat een programma zoveel mogelijk wordt opgesplitst in onderdelen. Het model bevat de onderliggende data en concepten van het programma (een database, meetgegevens, berekeningen, etc.); de controller praat met de fysieke omgeving en reageert bijvoorbeeld op invoer van een gebruiker en past het model aan; de view is een weergave van de data uit het model en vormt de gebruikersinterface zelf. Vaak praten alle onderdelen met elkaar, maar een gelaagd model is makkelijker te overzien en dus eenvoudiger te programmeren. In het geval van een natuurkunde-experiment is dit vaak mogelijk. Daarmee krijgt MVC bij ons een andere betekenis dan bijvoorbeeld bij het bouwen van websites. Het gelaagd MVC-model dat wij gaan gebruiken is hieronder weergegeven:</p> <p></p> <p>De controllers communiceren met de apparatuur; het model bevat de meetgegevens, berekeningen en de opzet van het experiment; de view zorgt voor een gebruikersinterface met weergave van de data.</p> <p>Het scheiden van je programma in deze lagen kan enorm helpen om ervoor te zorgen dat je geen spaghetticode schrijft \u2014 ongestructureerde en moeilijk te begrijpen code. Wanneer het drukken op een knop in de code van de grafische omgeving direct commando's stuurt naar de Arduino of dat de code voor het doen van een enkele meting meteen de $x$-as van een grafiek aanpast, sla je lagen over in ons model en knoop je delen van het programma aan elkaar die niet direct iets met elkaar te maken hebben. De knop moet een meting starten, ja, maar hoe dat precies moet is niet de taak van de gebruikersinterface. En de meting zelf moet zich niet bemoeien met welke grafiek er precies getekend wordt. Je zult merken dat het heel lastig wordt om overzicht te houden en later aanpassingen te doen als je alles door elkaar laat lopen. Je zult dan door je hele code moeten zoeken als je \u00f3f de aansturing van de Arduino, \u00f3f de grafische interface wilt aanpassen. En dus gaan we alles netjes structureren.</p> <p>De verschillende onderdelen in het model kunnen we voor ons experiment als volgt beschrijven:</p> View Het startpunt van je applicatie. Geeft de opdracht om een meting te starten en geeft na afloop de resultaten van de meting weer op het scherm. Model De code die het experiment uitvoert door verschillende metingen te doen en instellingen aan te passen, zoals de spanning over de LED. Het model weet hoe het experiment in elkaar zit en dat er bijvoorbeeld een weerstand van 220 \u03a9 aanwezig is. Geeft opdrachten aan de controller. Controller De code die via pyvisa praat met de Arduino. Opdrachten worden omgezet in firmwarecommando's en doorgestuurd naar het apparaat. <p>Het opsplitsen van je programma hoeft niet in \u00e9\u00e9n keer! Dit kan stapsgewijs. Je kunt starten met een eenvoudig script \u2014 zoals we hierboven gedaan hebben \u2014 en dat langzaam uitbreiden. Je begint klein, verdeelt je code in lagen en bouwt vervolgens verder.</p>"},{"location":"mvc/#gebruik-van-classes","title":"Gebruik van classes","text":"<p>Voor een snelle meting is het script dat je geschreven hebt bij opdracht quick 'n dirty meting en opdracht Pythondaq: CSV prima! Maar als de meetapparatuur ingewikkelder wordt (meer verschillende commando's) of je wilt meer aanpassingen doen, dan is het wel lastig dat je op allerlei plekken de commando's opnieuw moet programmeren \u2014 en eerst moet opzoeken. Als je een nieuw script schrijft moet je opnieuw goed opletten dat je de goede terminator characters gebruikt, etc. Het is wat werk, maar toch heel handig, om je code op te splitsen en een class te schrijven.</p> <p>Een class is eigenlijk een groep functies die je bij elkaar pakt en die met elkaar gegevens kunnen delen. Zodra een programma wat complexer wordt merk je dat het fijn kan zijn om variabelen op te sluiten in ge\u00efsoleerde omgevingen. Wanneer je bijvoorbeeld de volgende code schrijft gaat er mogelijk iets mis: <pre><code># find first student in alphabetical sorted list\nnames = [\"Bob\", \"Alice\", \"Charlie\"]\nfirst_name = sorted(names)[0]\n# first_name='Alice'\n...\n# split first and last name based on space character\nfirst_name, last_name = \"Carl Sagan\".split(\" \")\n# first_name='Carl'\n</code></pre> In bovenstaand voorbeeld waren we eerst op zoek naar de eerste naam in een alfabetisch gesorteerde lijst. Later in het programma splitsten we een naam op in een voornaam en een achternaam. Daarmee hebben we een variabele overschreven\u2026 Hoe langer het programma wordt, hoe makkelijker dat gebeurt.</p> <p>Lange programma's worden vaak opgedeeld in functies en dat maakt het al een stuk makkelijker omdat functies hun eigen ruimte voor variabelen hebben. In het volgende geval wordt de variabele <code>first_name</code> niet overschreven:</p> <pre><code>def sort_and_find_first_name(names):\nreturn sorted(names)[0]\ndef find_last_name(name):\nfirst_name, last_name = name.split(\" \")\nreturn last_name\nfirst_name = sort_and_find_first_name([\"Bob\", \"Alice\", \"Charlie\"])\n# first_name='Alice'\n...\nlast_name = find_last_name(\"Carl Sagan\")\n# first_name='Alice'\n# last_name='Sagan'\n</code></pre> <p>Een groot voordeel van functies is natuurlijk ook dat we ze vaker aan kunnen roepen. Ook helpt het de overzichtelijkheid als je goede namen geeft aan je functies. Soms kan het gebruiken van functies ook wat onhandig zijn \u2014 vooral als je gegevens wilt bewaren. Stel dat we voor een webshop code gaan schrijven die een winkelmandje inbouwt. We gaan de functionaliteit handmatig testen en uitbouwen. We beginnen als volgt: <pre><code>cart = []\nitem = \"Dune by Frank Herbert\"\n# ... some code to check that item is still available\n# add item to cart\ncart.append(item)\nitem = \"Eon by Greg Bear\"\n# ... some code to check that item is still available\n# add item to cart\ncart.append(item)\nitem = \"The Hunger Games by Suzanne Collins\"\n# ... some code to check that item is still available\n# add item to cart\ncart.append(item)\n# removing an item\nitem = \"Eon by Greg Bear\"\n# ... some code to check that item is actually in cart\ncart.remove(item)\nfor item in cart:\nprint(item)\n# Dune by Frank Herbert\n# The Hunger Games by Suzanne Collins\n</code></pre></p> <p>Vooral het implementeren van de controles dat producten nog leverbaar zijn is een hoop werk. Je besluit functies te gaan gebruiken zodat je die code maar op \u00e9\u00e9n plek hoeft te gebruiken: <pre><code>def add_to_cart(cart, item):\n# ... some code to check that item is still available\ncart.append(item)\ndef remove_from_cart(cart, item):\n# ... some code to check that item is actually in cart\ncart.remove(item)\ncart = []\nadd_to_cart(cart, \"Dune by Frank Herbert\")\nadd_to_cart(cart, \"Eon by Greg Bear\")\nadd_to_cart(cart, \"The Hunger Games by Suzanne Collins\")\nremove_from_cart(cart, \"Eon by Greg Bear\")\nfor item in cart:\nprint(item)\n# Dune by Frank Herbert\n# The Hunger Games by Suzanne Collins    \n</code></pre></p> <p>De code werkt nog op dezelfde manier, fijn! Het is alleen wel lastig dat je de hele tijd een variabele <code>cart</code> moet meegeven aan de functies. Je bedenkt nog veel meer functies om de levertijd te controleren, om de bestelling op te splitsen in verschillende bezorgmomenten, om de bestelling af te rekenen, etc. Elke keer moet je dezelfde variabele blijven meegeven. Een oplossing is het gebruiken van een class. Je begint met een regel <code>class Cart:</code> en daaronder plaats je de functies die je geschreven hebt \u2014 de zogeheten methods van de class. Iedere method krijgt automatisch een parameter <code>self</code> mee die verwijst naar de gedeelde geheugenopslag. Zo kun je een list <code>self.contents</code> defini\u00ebren waarin we de producten in de bestelling bewaren. Opstarttaken kun je onderbrengen in de speciale method <code>__init__()</code>. Als volgt: <pre><code>class Cart:\ndef __init__(self):\nself.contents = []\ndef add_to_cart(self, item):\n# ... some code to check that item is still available\nself.contents.append(item)\ndef remove_from_cart(self, item):\n# ... some code to check that item is actually in cart\nself.contents.remove(item)\n</code></pre></p> <p>Wanneer we deze class gaan gebruiken hoeven we de parameter <code>self</code> niet mee te geven, dat gaat automatisch. Wel moeten we de class eerst klaarzetten voor gebruik door hem aan te roepen: <pre><code>cart = Cart()\ncart.add_to_cart(\"Dune by Frank Herbert\")\ncart.add_to_cart(\"Eon by Greg Bear\")\ncart.add_to_cart(\"The Hunger Games by Suzanne Collins\")\ncart.remove_from_cart(\"Eon by Greg Bear\")\nfor item in cart.contents:\nprint(item)\n# Dune by Frank Herbert\n# The Hunger Games by Suzanne Collins\n</code></pre> In bovenstaande code hebben we de class <code>Cart</code> en de class instance <code>cart</code>. Je kunt meerdere instances hebben van dezelfde class, bijvoorbeeld wanneer meerdere klanten in de webshop tegelijkertijd winkelmandjes vullen: <pre><code>class Cart:\n...\ncart_alice = Cart()\n...\ncart_bob = Cart()\n...\n</code></pre></p> <p>Je kunt je afvragen wat we hier precies nu mee gewonnen hebben. De code is wat veranderd, maar in plaats van <pre><code>add_to_cart(cart, \"Eon by Greg Bear\")\n</code></pre> hebben we nu <pre><code>cart.add_to_cart(\"Eon by Greg Bear\")\n</code></pre> en dat is even lang. Het grote voordeel ontstaat pas wanneer de class ingewikkelder wordt en meer data gaat bewaren. Ook kun je de class in een ander pythonbestand (bijvoorbeeld <code>my_webshop_backend.py</code> zetten en alle functionaliteit in \u00e9\u00e9n keer importeren met: <pre><code>from my_webshop_backend import Cart\ncart = Cart()\n...\n</code></pre> Op deze manier kun je code ook makkelijker delen en verspreiden. Zodra je een class definieert zal Visual Studio Code tijdens het programmeren je code automatisch aanvullen. Zodra je typt <code>cart.add</code> hoef je alleen maar op Tab te drukken en VS Code vult de rest aan.</p> <p>Opbouw van een class</p> <p>Beschouw de volgende code:  Bespreek met elkaar wat de code precies doet en verplaast de onderdelen naar de juiste plek in de code.</p> <p>Class Particle</p> <p>Maak een class <code>Particle</code> die de naam van het deeltje en de spin van het deeltje bewaard. Een method <code>is_up_or_down()</code> vertelt je of het deeltje spin omhoog (positief) of spin omlaag (negatief) heeft. Maak nog een method <code>flip()</code> die de spin van het deeltje omkeert. De volgende code zou moeten werken: <pre><code>proton = Particle('mooi proton', 0.5)\nproton.is_up_or_down()\n# 'up'\nproton.flip()\nproton.is_up_or_down()\n# 'down'\nprint(proton.spin)\n# -0.5\nprint(proton.name)\n# 'mooi proton'\n</code></pre></p> <p>Class ElectronicLoadMeasurements</p> <p>Schrijf een class <code>ElectronicLoadMeasurements</code> waarmee je spanningsmetingen aan een weerstand (load) kunt bewaren. De class moet voldoen aan deze eisen:</p> <ol> <li>Een method <code>add_measurement(R, U)</code> waarmee je een gekozen weerstandswaarde en een gemeten spanning kunt toevoegen aan de lijst van metingen.</li> <li>Een method <code>get_loads()</code> om de gekozen weerstanden in \u00e9\u00e9n keer terug te vragen.</li> <li>Een method <code>get_voltages()</code> om de gemeten spanningen in \u00e9\u00e9n keer terug te vragen.</li> <li>Een method <code>get_currents()</code> om een lijst stroomsterktes op te vragen, berekend op basis van de metingen.</li> <li>Een method <code>get_powers()</code> om een lijst vermogens op te vragen, berekend op basis van de metingen.</li> <li>Een method <code>clear()</code> waarmee je alle metingen in \u00e9\u00e9n keer kunt wissen.</li> </ol> <p>Test je class uitgebreid, je kunt het volgende scriptje als inspiratie gebruiken: <pre><code>measurements = ElectronicLoadMeasurements()\nmeasurements.add_measurement(R=10, U=.5)\nmeasurements.add_measurement(R=20, U=1.5)\nR = measurements.get_loads()\n# R=[10, 20]\nU = measurements.get_voltages()\n# U=[0.5, 1.5]\nP = measurements.get_powers()\n# P=[0.025, 0.1125]\nI = measurements.get_currents()\n# I=[0.05, 0.075]\n</code></pre></p>"},{"location":"mvc/#implementeren-van-mvc","title":"Implementeren van MVC","text":"<p>Het opsplitsen van het programma in MVC gaan we stapsgewijs doen. We gaan een class maken voor de aansturing van de Arduino, deze class valt in de categorie controller.</p> <p>Pythondaq: controller bouwen</p> <p>Pak je script van opdracht Pythondaq: CSV erbij en schrijf bovenaan \u2014 maar onder de <code>import</code>-statements \u2014 een class <code>ArduinoVISADevice</code>. We gaan de class stap voor stap opbouwen. Je kunt de class testen met de python-code onder elke opdracht. </p> <ol> <li>Maak een <code>__init__()</code> method die het device opent.      <pre><code># de poort moet je mogelijk zelf aanpassen\nport = \"ASRL3::INSTR\"\n# maak een instance van je class aan\ndevice = ArduinoVISADevice(port=port)\n</code></pre></li> <li> <p>Schrijf een method die de identificatiestring terug geeft.      <pre><code># print identification string\nprint(device.get_identification())\n</code></pre></p> </li> <li> <p>Met de controller class willen we de arduino gaan aansturen en uitlezen. Maak een aantal methods zodat alle firmwarecommando's ondergebracht zijn in de class.     <pre><code># set OUTPUT voltage on channel 0, using ADC values (0 - 1023)\ndevice.set_output_value(value=512)\n# get the previously set OUTPUT voltage in ADC values (0 - 1023)\nch0_value = device.get_output_value()\n# measure the voltage on INPUT channel 2 in ADC values (0 - 1023)\nch2_value = device.get_input_value(channel=2)\n# measure the voltage on INPUT channel 2 in volts (0 - 3.3 V)\nch2_voltage = device.get_input_voltage(channel=2)\n</code></pre></p> </li> <li> <p>Wat is het verschil tussen <code>set_output_value()</code> en <code>get_output_value()</code>?</p> </li> <li> <p>Als je een instance van ArduinoVISADevice wilt maken, dan moet je nu de poort meegeven. Daarom is het handig om buiten de klas een functie te hebben waarmee je een lijst krijgt van alle beschikbare poorten.      <pre><code># get available ports\nprint(list_devices())  \n</code></pre></p> </li> </ol> <p>Je hebt nu een werkende controller, maar je gebruikt het nog niet in je experiment. </p> <p>Pythondaq: Controller implementeren</p> <p>Pas je script \u2014 en vooral ook de class! \u2014aan zodat in je experiment-code alleen maar aanroepen naar de class zitten. Controleer dat het schript precies hetzelfde doet als bij opdracht quick 'n dirty meting.</p> <p>Als je de vorige opdracht succesvol hebt afgerond maakt het niet meer uit wat de precieze commando's zijn die je naar de hardware moet sturen. Als je de Arduino in de opstelling vervangt voor een ander meetinstrument moet je de class aanpassen, maar kan alle code die met het experiment zelf te maken heeft hetzelfde blijven.</p> <p>Nu we de controller hebben gemaakt die de Arduino aanstuurt, blijft er nog een stukje code over. Het laatste stuk waar de plot gemaakt kunnen we beschouwen als een view en de rest van de code \u2014 waar de metingen worden uitgevoerd en de stroomsterkte $I$ wordt berekend \u2014 is een model. We gaan de code nog wat verder opsplitsen om dat duidelijk te maken \u00e9n onderbrengen in verschillende bestanden \u2014 dat is uiteindelijk beter voor het overzicht.</p> <p>Pythondaq: Controller afsplitsen</p> <p>Pas het script aan uit opdracht Pythondaq: ArduinoVISADevice. Knip de class uit het bestand en plak die in een nieuw bestand <code>arduino_device.py</code>. Knip en plak ook de functie <code>list_devices()</code>, zodat alle <code>pyvisa</code>-code netjes in \u00e9\u00e9n bestand zit. Je vervangt de functie en de class in het oorspronkelijke script door dit import statement: <pre><code>from arduino_device import ArduinoVISADevice, list_devices\n</code></pre> Controleer dat je code nog steeds hetzelfde werkt \u2014 dat het een meting uitvoert en de resultaten in een grafiek weergeeft. Waarschijnlijk moet je daarvoor nog wat bugs aanpakken (een vergeten import bijvoorbeeld).</p> <p>Pythondaq: Model afsplitsen</p> <p>We gaan nu met ongeveer dezelfde stappen het model afsplitsen van de rest van de code.</p> <ol> <li>Bespreek met elkaar en met de assistent welk deel van het script het model is. Kijk daarvoor nog eens goed naar figuur MVC-model.</li> <li>Maak een class met (bijvoorbeeld) de naam <code>DiodeExperiment</code> en een method <code>scan()</code> die de meting met de for-loop uitvoert. Controleer dat het werkt.</li> <li>Volgens het schema praat alleen het model met de controller. De class <code>DiodeExperiment</code> \u2014 het model \u2014 is dus degene die de class <code>ArduinoVISADevice</code> \u2014 de controller \u2014 moet aanroepen en bewaren. Hoe doe je dat netjes? Overleg met elkaar.</li> <li>Het kan (later) handig zijn om niet altijd te scannen tussen 0 en 1023 maar een ander bereik te kiezen. Pas de <code>scan()</code> method aan zodat deze <code>start</code>- en <code>stop</code>-parameters accepteert.</li> <li>Knip de class eruit en plaats die in het bestand <code>diode_experiment.py</code> en gebruik weer een import-statement. Haal import-statements die je niet meer nodig hebt weg.</li> <li>Hernoem het overgebleven script naar <code>view.py</code>.</li> </ol> <p>Het oorspronkelijke script dat je gebruikte voor je meting is steeds leger geworden. Als het goed is gaat nu (vrijwel) het volledige script alleen maar over het starten van een meting en het weergeven en bewaren van de meetgegevens. In het view script komen verder geen berekeningen voor of details over welk kanaal van de Arduino op welke elektronische component is aangesloten. Ook staat hier niets over welke commando's de Arduino firmware begrijpt. Dit maakt het veel makkelijker om in de vervolghoofdstukken een gebruiksvriendelijke applicatie te ontwikkelen waarmee je snel en eenvoudig metingen kunt doen.</p> <p>Pythondaq: Onzekerheid</p> <p>We zijn al een eind op weg. We pakken nog \u00e9\u00e9n ding aan: onzekerheid. Er staan in onze grafiek nog geen foutenvlaggen. Als je de meting een paar keer herhaalt zie je dat de grafiek steeds iets anders is \u2014 er zit ruis op de metingen. We kunnen die op voorhand schatten, maar met een computergestuurde meting is het makkelijk om een meting een aantal keer te herhalen en op een nauwkeuriger resultaat uit te komen \u00e9n de onzekerheid daarbij te bepalen.</p> <ol> <li>Overleg met je groepje en maak een plan hoe jullie de code gaan aanpassen om onzekerheid in te bouwen. Schrijf nog geen code op je computer maar schrijf de stappen uit met papier en pen. Het is dan veel makkelijker om te overleggen en na te denken. Welke delen van het programma moeten worden aangepast?</li> <li>Gebruik het plan om je eigen code aan te passen en test dat het werkt.</li> </ol>"},{"location":"poetry/","title":"Poetry","text":"<p>In de vorige hoofdstukken heb je gewerkt met een eigen conda environment zodat je jouw pythonomgeving mooi gescheiden kan houden van andere studenten die op dezelfde computer werken. Dit is echt de oplossing voor alle problemen waarbij volledige Pythoninstallaties onbruikbaar kunnen worden \u2014 waarna je alles opnieuw moet installeren.</p> <p>Opnieuw beginnen of nieuwe environments aanmaken heeft wel een nadeel: je moet alle packages die je nodig hebt opnieuw installeren. Welke waren dat ook alweer? Vast <code>numpy</code>, en <code>matplotlib</code>, en\u2026? Niet handig. Als je code gaat delen met elkaar krijg je regelmatig te maken met een <code>ImportError</code> waarna je weer \u00e9\u00e9n of ander package moet installeren.</p> <p>Nu pythondaq netjes is uitgesplitst in een MVC-structuur en de wijzigingen met Git worden bijgehouden, ga je er een package van maken zodat je het ook met anderen kan delen.</p> <p>Packages op PyPI geven altijd hun dependencies op. Dat zijn de packages die verder nog nodig zijn om alles te laten werken. Installeer je <code>matplotlib</code>, dan krijg je er <code>six, python-dateutil, pyparsing, pillow, numpy, kiwisolver, cycler</code> automatisch bij. Maar dat is niet genoeg. Welke versies van <code>numpy</code> werken met de huidige versie van <code>matplotlib</code>? Allemaal zaken die je \u2014 als je een package schrijft \u2014 zelf moet bijhouden. Het voordeel is dat jouw gebruikers alleen maar jouw pakket hoeven te installeren \u2014 de rest gaat vanzelf.</p> <p>En\u2026 hoe test je je package zodat je zeker weet dat hij het bij een ander ook doet? Heel vaak werkt het bij jou wel, maar vergeet je een bestand mee te sturen dat wel echt nodig is.1 Of: bij jou werkt <code>import my_new_cool_app.gui</code> wel, maar bij een ander geeft hij een <code>ImportError</code>. De bestanden zijn er wel, maar worden verkeerd ge\u00efmporteerd.</p> <p>Hoe krijg je eigenlijk je code bij iemand anders? Liefst als \u00e9\u00e9n bestand, of zelfs met <code>pip install my_new_cool_app</code>; dat zou wel mooi zijn.</p> <p>En daar is Poetry.</p> <p>Er zijn meerdere tools ontwikkeld om dezelfde problemen op te lossen. Poetry is heel populair geworden. Het richt zich op het offici\u00eble ecosysteem: standaard Python packages, ofwel PyPI en <code>pip</code>; niet <code>conda</code> (zie meer hierover in paragraaf pip vs conda). Jammer, maar dit zorgt er wel voor dat iedereen m\u00e9t of z\u00f3nder Anaconda je package kan installeren. Dat is dan wel weer fijn. Wij gaan Anaconda gebruiken om een virtual environment met alleen Python te maken. Vervolgens installeren we alles dat we nodig hebben met <code>pip</code>. Dat werkt prima, want we mengen verder geen <code>conda</code> met <code>pip</code> packages. Het maken van conda packages valt daarmee buiten het bestek van deze cursus, al is dat een relatief kleine stap als je je standaard Python package af hebt.</p> <p>Poetry installeren</p> <p>Om Poetry te installeren gaan we gebruik maken van <code>pipx</code>, zie voor meer informatie paragraaf pipx. Eerst moeten we <code>pipx</code> installeren</p> <ol> <li>Open een Anaconda Prompt.</li> <li>Maak een nieuwe environment en installeer pipx via pip     Terminal<pre><code>conda create -n pipx python\nconda activate pipx\npython -m pip install --user pipx\n</code></pre></li> <li>Zorg ervoor dat de map waarin pipx apps opslaat, is opgenomen in je PATH omgevingsvariabele.     Terminal<pre><code>python -m pipx ensurepath\n</code></pre></li> <li>Sluit de Anaconda Prompt en open een nieuwe.</li> <li>Test of pipx nu werkt met:     Terminal<pre><code>conda activate pipx\npipx\n</code></pre></li> </ol> <p>Nu kunnen we <code>Poetry</code> installeren met <code>pipx</code>.</p> <ol> <li>Installeer Poetry met behulp van pipx.      Terminal<pre><code>pipx install poetry\n</code></pre></li> <li>Test of poetry nu werkt met:     Terminal<pre><code>poetry\n</code></pre></li> <li>Activeer een andere environment en test of Poetry ook daar werkt.</li> </ol> <p>We gaan Poetry bedienen door commando's te geven in de terminal van Visual Studio Code. We laten de terminal weten welk programma wij willen gaan besturen, door <code>poetry</code> in te typen. En daarachter wat we willen dat Poetry gaat doen. We kunnen informatie over Poetry opvragen met het commando <code>about</code>.</p> Terminal<pre><code>poetry about\n</code></pre> <p>Poetry about</p> <p>Open een terminal en vraag informatie over Poetry op met het commando <code>poetry about</code>. Lees de tekst die Poetry aan je teruggeeft, waar kan je meer informatie vinden?</p>"},{"location":"poetry/#nieuw-poetry-project","title":"Nieuw Poetry project","text":"<p>Info</p> <p>We gaan werken met modules en packages. Ben je daar nog niet zo bekend mee, zorg dan dat je paragraaf Modules en paragraaf packages gemaakt hebt.</p> <p>Stel je wilt een package schrijven met wat handige functies om veelgebruikte statistische berekeningen makkelijk uit te voeren. Je noemt het <code>easystat</code>. Het doel is eerst om het in al je eigen analyses makkelijk te kunnen gebruiken (<code>import easystat</code>) maar je wilt het ook op GitHub zetten en wie weet vinden anderen het ook handig! Je wilt het dus ook netjes doen. En niet later van anderen horen: leuk, maar bij mij werkt het niet!</p> <p>Poetry project aanmaken</p> <p>Maak een nieuw Poetry project met de naam <code>easystat</code>, als volgt:</p> <ol> <li>Open in Visual Studio Code een geschikte map, bijvoorbeeld <code>Documents/NSP2/ExperimentControlwithPythonCourse</code>, en open een terminal.</li> <li>Dan maken we met Poetry als volgt een nieuw project.2 We maken het daarmee expres iets moeilijker om vanuit een script je package te importeren. Je kunt dat dan alleen nog maar doen door het package zelf ook te installeren (zoals andere gebruikers ook moeten doen) en daardoor loop je zelf tegen eventuele problemen aan. Werkt het uiteindelijk bij jou? Dan werkt het ook bij andere mensen.} <code>easystat</code> aan: Terminal<pre><code>PS&gt; poetry new --src easystat\nCreated package easystat in easystat\n</code></pre></li> </ol> <p>Er is nu de volgende structuur aangemaakt:</p> <pre><code>easystat/\n    src/\n        easystat/\n            __init__.py\n    tests/\n        __init__.py\n        test_easystat.py\n    pyproject.toml\n    README.md\n</code></pre> <p>Allereerst is er een projectmap <code>easystat</code> aangemaakt. Je kunt nu in GitHub Desktop deze map toevoegen als nieuwe repository, zoals we gedaan hebben in opdracht Repository toevoegen.</p> <p>Laten we \u00e9\u00e9n voor \u00e9\u00e9n kijken welke mappen en bestanden Poetry heeft aangemaakt. We zien een <code>README.md</code> in de projectmap staan. Hierin komt een algemene beschrijving van ons project.3</p> <p>Daarna is er een map <code>tests</code>. Goede software wordt getest. In deze map komen bestanden te staan die delen van de code runnen en resultaten vergelijken met verwachte resultaten \u2014 zoals je kunt doen in opdracht Packages.4</p> <p>Dan komt de <code>src</code>-map. Daarin komt ons nieuwe package <code>easystat</code>5 te staan. Er is alvast voor ons een <code>__init__.py</code> aangemaakt. Handig!</p> <p>En als laatste\u2026 een <code>pyproject.toml</code>6 waarin alle informatie over je project wordt bijgehouden. Ook staat er in dit bestand informatie voor de verschillende tools die je kunt gebruiken. De inhoud van het bestand ziet er ongeveer zo uit: <pre><code>[tool.poetry]\nname = \"easystat\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"David Fokkema &lt;davidfokkema@icloud.com&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"easystat\", from = \"src\"}]\n[tool.poetry.dependencies]\npython = \"^3.10\"\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre></p> <p>Het bestand is in het TOML-formaat.15 Tussen de vierkante haken staan de koppen van de verschillende secties in dit configuratiebestand. Overal zie je <code>poetry</code> terugkomen, want dat is de tool die wij gebruiken. In de eerste sectie staat informatie over ons project. Je kunt daar bijvoorbeeld een beschrijving toevoegen of het versienummer aanpassen. De tweede sectie bevat de dependencies. Dit zijn alle Pythonpackages die ons project nodig heeft. Op dit moment is dat alleen maar Python. Ook het versienummer van Python is belangrijk. Hier is dat 3.10 en het dakje geeft aan dat nieuwere versies 3.11, 3.12, enz. ook prima zijn, maar 3.9 (te oud) 4.0 (te nieuw) niet. Dit kan belangrijk zijn. Gebruikers met een iets oudere versie van Python \u2014 bijvoorbeeld versie 3.9 \u2014 kunnen nu het package niet installeren. Als je niet per se de nieuwste snufjes van Python 3.10 nodig hebt kun je aangeven dat een iets oudere versie van Python ook prima is. Op dit moment \u2014 herfst 2023 \u2014 is Python 3.12 de nieuwste versie. Het is dus prima om minimaal 3.10 te vragen \u2014 die versie is inmiddels twee jaar oud.</p>"},{"location":"poetry/#environment-aanmaken","title":"Environment aanmaken","text":"<p>Bij het schrijven van een nieuw package is het z\u00e9ker belangrijk om een environment te gebruiken. Anders loop je het risico dat je package lijkt te werken maar bij iemand anders crasht. Immers, het kan best zijn dat jij NumPy gebruikt en al eerder ge\u00efnstalleerd had. Bij iemand die NumPy nog niet ge\u00efnstalleerd had gaat het dan mis.</p> <p>Environment aanmaken</p> <p>We maken \u2014 speciaal voor <code>easystat</code> \u2014 een environment.</p> <ol> <li>Open in Visual Studio Code de project-map <code>easystat</code></li> <li>Open een terminal en maak een easystat conda environment aan:         Terminal<pre><code>conda create -n easystat python=3.10\n</code></pre></li> <li>Selecteer dit nieuwe conda environment in Visual Studio Code.</li> </ol> <p>Merk op dat we nu niet gebruik hoeven te maken van de <code>conda-forge</code> channel. Python zelf staat in alle kanalen en we gaan verder geen software installeren met conda, dus ook niet uit <code>conda-forge</code>.</p>"},{"location":"poetry/#maken-van-de-easystat-package","title":"Maken van de easystat-package","text":"<p>We starten met ons package. Stel, we berekenen vaak de standaarddeviatie van het gemiddelde en maken daarvoor een handige shortcut.</p> <p>Shortcuts.py aanmaken</p> <p>Maak het bestand <code>src/easystat/shortcuts.py</code>:7 <pre><code># src/easystat/shortcuts.py\nimport numpy as np\ndef stdev_of_mean(values):\n# Calculate the standard deviation of the mean\nreturn np.std(values) / np.sqrt(len(values))    \n</code></pre></p> <p>Nu willen we de package <code>easystat</code> importeren in een ander script zodat we de functie <code>stdev_of_mean</code> daar kunnen gebruiken. We maken een script om onze nieuwe code te testen.8</p> <p>Test script aanmaken</p> <p>Maak het bestand <code>tests/try_shortcuts.py</code>: <pre><code># tests/try_shortcuts.py\nfrom easystat.shortcuts import stdev_of_mean\nprint(f\"{stdev_of_mean([1, 2, 2, 2, 3])=}\")    \n</code></pre></p> <p>In de eerste regel importeren we de functie uit het nieuwe package om uit te proberen. In de laatste regel gebruiken we een handige functie van f-strings.9</p> <p>Script testen</p> <p>Run <code>tests/try_shortcuts.py</code> en kijk of het script het doet.</p> <p>We krijgen de foutmelding: <pre><code>ModuleNotFoundError: No module named 'easystat'\n</code></pre> Dit konden we verwachten. We hebben ons package immers nog niet ge\u00efnstalleerd. Als we ons package gaan delen met andere mensen verwachten wij dat zij ons package ook gaan installeren, door dezelfde stappen te doorlopen als andere gebruikers komen we erachter of alles wel goed werkt.</p>"},{"location":"poetry/#installeren-van-een-package","title":"Installeren van een package","text":"<p>Het installeren van de package kan makkelijk met Poetry: Terminal<pre><code>PS&gt; poetry install\nUpdating dependencies\nResolving dependencies... (0.1s)\nWriting lock file\nInstalling the current project: easystat (0.1.0)\n</code></pre></p> <p>Poetry is even bezig en ons package is ge\u00efnstalleerd.</p> <p>Poetry install</p> <p>We draaien opnieuw de test, als volgt:</p> <ol> <li>Installeer de easystat package met <code>poetry install</code>.</li> <li>Draai <code>tests/try_shortcuts.py</code> en controleer of het nu wel werkt.</li> </ol> <p>Als we het testscript nu draaien krijgen we w\u00e9\u00e9r een foutmelding: <pre><code>ModuleNotFoundError: No module named 'numpy'\n</code></pre> Ons package heeft NumPy nodig en dat hebben we nog niet ge\u00efnstalleerd. Dat kunnen we handmatig doen maar dan hebben andere gebruikers een probleem. Veel beter is het om netjes aan te geven dat ons package NumPy nodig heeft \u2014 als dependency.</p>"},{"location":"poetry/#dependencies-toevoegen","title":"Dependencies toevoegen","text":"<p>Om een dependency aan te geven vertellen we Poetry dat hij deze moet toevoegen met: Terminal<pre><code>PS&gt; poetry add numpy\nUsing version ^1.23.2 for numpy\nUpdating dependencies\nResolving dependencies...\nWriting lock file\nPackage operations: 1 install, 0 updates, 0 removals\n  \u2022 Installing numpy (1.23.2)\n</code></pre></p> <p>Dependencies toevoegen</p> <p>We voegen de dependency toe en runnen opnieuw de test, als volgt:</p> <ol> <li>Voeg numpy als dependency toe met <code>poetry add numpy</code>.</li> <li>Draai <code>tests/try_shortcuts.py</code> en bekijk de uitkomst.</li> </ol> <p>Ditmaal krijgen we: <pre><code>stdev_of_mean([1, 2, 2, 2, 3])=0.282842712474619\n</code></pre> Fijn! Als je nu de <code>pyproject.toml</code> nog eens bekijkt zie je dat NumPy daar als dependency is toegevoegd. Het verwijderen van dependency <code>PACKAGE</code> gaat met <code>poetry remove PACKAGE</code>. Poetry heeft Numpy nu toegevoegd aan de environment <code>easystat</code>.10 Gewone package managers als Pip en Conda zullen geen packages toevoegen aan je Poetry project als je <code>pip/conda install package</code> aanroept. Gebruik daarom altijd <code>poetry add package</code> als je met Poetry aan een package werkt.</p> <p>Info</p> <p>Als we de code in ons package aanpassen dan hoeven we het niet opnieuw te installeren met Poetry, maar als we met de hand iets wijzigen in de <code>pyproject.toml</code> dan moet dat wel. Als je een <code>ImportError</code> krijgt voor je eigen package \u2014 bijvoorbeeld als je nieuwe mappen of bestanden hebt aangemaakt \u2014 probeer dan eerst voor de zekerheid <code>poetry install</code>.</p>"},{"location":"poetry/#poetrylock","title":"Poetry.lock","text":"Meer leren <p>Na het toevoegen van Numpy is er ook een bestand <code>poetry.lock</code> bijgekomen. Hierin staan de exacte versies van alle ge\u00efnstalleerde packages. Vaak wordt dit bestand gecommit zodat collega-ontwikkelaars exact dezelfde versies installeren zodra ze <code>poetry install</code> aanroepen. Om dat te proberen maken we even een schone conda environment:</p> <p>Schone environment</p> <ol> <li>Maak een schone conda environment met <code>PS&gt; conda create -n easystat python=3.10</code></li> <li>Kies voor ja als Conda een waarschuwing geeft dat deze environment al bestaat en vraagt of je het bestaande environment wilt verwijderen.</li> <li>Draai <code>tests/try_shortcuts.py</code> en bekijk de foutmelding.</li> </ol> <p>We krijgen meteen foutmeldingen. Immers, we hebben nog niets ge\u00efnstalleerd.</p> <p>Poetry.lock</p> <ol> <li>Installeer de <code>easystat</code> package met <code>poetry</code>.</li> <li>Waarvoor gebruikt Poetry de lock file (<code>poetry.lock)</code>?</li> <li>Draai <code>tests/try_shortcuts.py</code> en bekijk de uitkomst.</li> </ol>"},{"location":"poetry/#wheels","title":"Wheels","text":"Meer leren <p>Wanneer we klaar zijn om ons package te delen met andere gebruikers gebruiken we het commando <code>build</code> om wheels te bouwen.</p> <p>Bouw een wheel</p> <ol> <li>Bouw het wheel van easystat met <code>poetry build</code>.</li> <li>Bekijk de namen van de bestanden in de nieuwe map <code>easystat/dist</code>, welke extensie hebben ze?</li> </ol> <p>Terminal<pre><code>PS&gt; poetry build  \nBuilding easystat (0.1.0)\n    - Building sdist\n    - Built easystat-0.1.0.tar.gz\n    - Building wheel\n    - Built easystat-0.1.0-py3-none-any.whl\n</code></pre> Een sdist is een source distribution. Een <code>.tar.gz</code>-bestand is een soort zipbestand met daarin de broncode van ons pakket. De tests worden daar niet in meegenomen. Een wheel is een soort bestand dat direct ge\u00efnstalleerd kan worden met <code>pip</code>. Zogenaamde pure-python packages bevatten alleen Pythoncode \u2014 en geen C-code die gecompileerd moet worden voor verschillende besturingssystemen of hardwareplatforms. Je herkent ze aan <code>none-any</code> in de bestandsnaam. None voor niet-OS-specifiek en any voor draait op elk hardwareplatform. We kunnen dit bestand als download neerzetten op een website of aan anderen mailen.</p> <p>Test wheel</p> <p>Laten we het wheel uitproberen. We gaan straks een nieuwe conda environment aanmaken, installeren het wheel en proberen het testscript te runnen \u2014 \u00e9\u00e9n keer v\u00f3\u00f3r het installeren van het wheel en \u00e9\u00e9n keer n\u00e1 het installeren, als volgt:</p> <ol> <li>Maak een nieuwe conda environment aan met de naam <code>test-wheel</code> en activeer deze.         Terminal<pre><code>PS&gt; conda create -n test-wheel python=3.10\n...\nPS&gt; conda activate test-wheel\n</code></pre></li> <li>Draai <code>tests/try_shortcuts.py</code> en bekijk de foutmelding.</li> <li>Installeer het wheel met <code>pip install dist/easystat-0.1.0-py3-none-any.whl</code>.</li> <li>Draai <code>tests/try_shortcuts.py</code> en bekijk de uitkomst.</li> </ol> <p>Het werkt! Je ziet dat <code>pip install</code> niet alleen ons package <code>easystat</code> installeert, maar ook de dependency <code>numpy</code>. Dat is precies wat we willen.</p> <p>Het is belangrijk om de wheels niet in je GitHub repository te committen. Je repository is voor broncode, waarmee wheels gebouwd kunnen worden. Als je de stappen voor het aanmaken van de repository netjes gevolgd hebt dan heb je een <code>.gitignore</code> toegevoegd met Python-specifieke bestandsnamen en directories die genegeerd worden door Git en GitHub.</p>"},{"location":"poetry/#poetry-gebruiken-voor-een-bestaand-project","title":"Poetry gebruiken voor een bestaand project","text":"<p>Met <code>poetry new</code> start je een nieuw project en maakt Poetry voor jou bestanden en mappen aan waarmee je aan de slag kunt. Maar vaak ben je al bezig met een project en wil je dat niet overschrijven. Ook is het een gedoe om een nieuw project te maken en daar je bestaande code in te kopie\u00ebren. Gelukkig kun je Poetry ook vertellen dat je al bezig bent en dat Poetry alleen een <code>pyproject.toml</code>-bestand moet aanmaken. Dat doe je met: Terminal<pre><code>poetry init --no-interaction\n</code></pre> Je geeft met <code>poetry init</code> de opdracht om Poetry alleen te initialiseren en <code>--no-interaction</code> voorkomt je dat je eerst honderd vragen krijgt over je project. Meestal kies je toch de standaardantwoorden.11</p> <p>Info</p> <p>Als je al bezig bent met een project dan werk je als het goed is al in een conda environment. Daar heb je dan met <code>conda install</code> al packages ge\u00efnstalleerd die je nodig hebt. Het gebeurt dan makkelijk dat je vergeet om dat aan te geven met <code>poetry add</code>. Dat betekent alleen dat als iemand anders je package installeert dat er dependencies missen en dat jouw code dus niet werkt! Dit is makkelijk op te lossen. Zodra je Poetry gaat gebruiken wis dan je environment en maak een nieuwe aan met alleen Python. Dat gaat het makkelijkst als volgt. Stel dat je bezig bent in het environment <code>pythondaq</code>. We maken dan een nieuw environment met dezelfde naam: Terminal<pre><code>conda create -n pythondaq python=3.10\nWARNING: A conda environment already exists at '/Users/david/opt/anaconda3/envs/pythondaq'\nRemove existing environment (y/[n])? y\n...\n</code></pre> Je overschrijft dus je huidige environment met een nieuwe, lege. Je kunt daarna met <code>poetry add</code> packages toevoegen net zo lang tot je geen <code>ImportError</code> meer krijgt.</p> <p>Poetry knipperlicht</p> <p>We gaan nu poetry gebruiken om van het script met de knipperende lichtjes uit opdracht KnipperLED een package te maken \u00e9n om ons environment te beheren. Voer de volgende stappen uit:</p> <ol> <li>Maak in GitHub Desktop een nieuwe repository <code>flasher</code>.</li> <li>Maak een map <code>src</code> met daarin een map <code>flasher</code>.</li> <li>Kopieer uit de <code>Oefenopdrachten</code> die je bij opdracht Repository toevoegen hebt aangemaakt het scriptje uit opdracht KnipperLED naar <code>src/flasher</code>.</li> <li>Open <code>flasher</code> in Visual Studio Code.</li> <li>Commit alles dat je tot nu toe gedaan hebt.</li> <li>Open een terminal. Maak een nieuwe conda environment met alleen python 3.10:     Terminal<pre><code>conda create -n flasher python=3.10\n</code></pre>     en maak dat actief in Visual Studio Code.</li> <li>Voer dan het volgende commando uit:     Terminal<pre><code>poetry init --no-interaction\n</code></pre>     om een <code>pyproject.toml</code> aan te maken.</li> <li>Gebruik <code>poetry add</code> om de dependencies van je script toe te voegen (welke Pythonpackages gebruik je?).12</li> <li>Installeer je <code>flasher</code> package met <code>poetry install</code>.</li> <li>Test het scriptje, werkt het allemaal nog?</li> </ol>"},{"location":"poetry/#poetry-gebruiken-voor-pythondaq","title":"Poetry gebruiken voor pythondaq","text":"<p>Natuurlijk willen we Poetry ook gaan gebruiken bij <code>pythondaq</code>. Daarvoor moeten we twee dingen doen. Als eerste gaan we de <code>pythondaq</code> repository in een <code>src</code>-structuur zetten en daarna gaan we Poetry initialiseren.</p> <p>Info</p> <p>Vergeet niet \u2014 waar nodig \u2014 de <code>__init__.py</code> bestanden toe te voegen aan de packages.</p> <p>Pythondaq: package</p> <p>Zet <code>pythondaq</code> om in een src-structuur, als volgt, en vergeet niet na elke stap te committen:</p> <ol> <li>Maak in <code>pythondaq</code> een map <code>src</code> met daarin een map <code>pythondaq</code>.</li> <li> <p>Zet de model, view, controller scripts in de <code>pythondaq</code> package zodat je onderstaande structuur krijgt:</p> <pre><code>pythondaq/\n    src/\n        pythondaq/\n            __init__.py\n            arduino_device.py\n            diode_experiment.py\n            view.py\n    README.md\n</code></pre> </li> <li> <p>Test je <code>view.py</code> script.    </p> </li> </ol> <p>Pythondaq: poetry</p> <p>Gebruik Poetry om <code>pythondaq</code> als package te installeren, als volgt:</p> <ol> <li>Ga in Visual Studio Code naar <code>pythondaq</code>. Open een terminal.</li> <li>Overschrijf je conda environment zodat hij weer leeg is (met alleen <code>python=3.10</code>).</li> <li>Initialiseer Poetry, zodat een <code>pyproject.toml</code> wordt aangemaakt.</li> <li>Installeer je package.</li> <li>Test je <code>view.py</code> script, terwijl je dependencies toevoegt die je in je scripts nodig hebt.</li> <li> <p>Vergelijkbaar met opdracht Packages is het verstandig om het importeren van onderdelen van het package te testen voordat we het verder gaan uitbouwen. Maak een <code>tests</code>-map met <code>__init__.py</code> aan in hoofdmap van de repository zodat je onderstaande structuur krijgt:</p> <pre><code>pythondaq/\n    src/\n        ...\n    tests/\n        __init__.py\n    README.md\n    pyproject.toml\n</code></pre> </li> <li> <p>Maak een script <code>tests/test_imports.py</code> met de regel:         <pre><code>import pythondaq.view\n</code></pre>         en run het script. Overleg met elkaar hoe je de import-errors op moet lossen zodat alles werkt. Als dat gelukt is dan werkt je package ook als je het aanroept van buiten de map met broncode.</p> </li> </ol> <p>Je <code>pythondaq</code>-repository is nu een volledig project dat je met andere gebruikers van Python kunt delen, bijvoorbeeld via een wheel. We gaan pythondaq in de komende hoofdstukken steeds verder uitbouwen.</p> Model, view, controller packages <p>In grotere projecten is het gebruikelijk om model, view, controller niet alleen uit te splitsen in verschillende scripts, maar ook in aparte packages te zetten.</p> <ol> <li>Maak 3 extra packages in de <code>pythondaq</code> package. <code>models</code>, <code>views</code> en <code>controllers</code>.</li> <li>Zet de modules in de juiste packages.</li> <li>Test je code zodat alle imports weer werken.</li> </ol>"},{"location":"poetry/#van-script-naar-applicatie","title":"Van script naar applicatie","text":"<p>Om onze python code te testen heb je tot nu toe waarschijnlijk op de <code>run</code>-knop in Visual Studio Code gedrukt. Of je hebt in de terminal aan python gevraagd om het <code>script.py</code> te runnen: Terminal<pre><code>python script.py\n</code></pre> Je moet dan wel de juiste map geopend hebben zodat python het bestand kan vinden. En als je de <code>run</code>-knop gebruikt moet wel het bestandje open hebben staan dat je wilt runnen. Kortom, best een beetje gedoe. Maar als we programma's zoals Poetry, Conda of Python willen gebruiken hoeven we helemaal niet het juiste bestandje op te zoeken en te runnen. We hoeven alleen maar een commando in de terminal te geven \u2014 bijvoorbeeld <code>python</code> of <code>conda</code> \u2014 en de computer start automatisch het juiste programma op.</p> <p>Dat willen wij ook voor onze programma's! En omdat we Poetry gebruiken kunnen we dat heel eenvoudig doen. We gaan een commando toevoegen om de module uit te voeren waarvan je de code in paragraaf Modules kunt vinden. De twee bestanden <code>square.py</code> en <code>count_count.py</code> hebben we voor jullie netjes in een package geplaats in de repository <code>AnneliesVlaar/just_count</code> met de volgende structuur:</p> <pre><code>just_count/\n    src/\n        just_count/\n            __init__.py\n            square.py\n            count_count.py\n    tests/\n        __init__.py\n    pyproject.toml\n    README.md\n</code></pre> <p>De bestanden <code>square.py</code> en <code>count_count.py</code> zien er hetzelfde uit als in paragraaf Modules:</p> square.pycount_count.py <pre><code>def square(x):\nreturn x**2\nif __name__ == \"__main__\":\nprint(f\"The square of 4 is {square(4)}\")\n</code></pre> <pre><code>import square\nprint(f\"The square of 5 is {square.square(5)}\")\n</code></pre> <p>We kunnen Poetry niet vragen om een script te runnen, maar wel om een functie uit te voeren.</p> <p>Main functie toevoegen</p> <ol> <li>Ga naar <code>AnneliesVlaar/just_count</code> en open de repository in GitHub desktop en daarna in Visual Studio Code.</li> <li>Maak een nieuwe conda environment met python 3.10, activeer deze en installeer de <code>just_count</code> package.</li> <li>Open <code>src/just_count/count_count.py</code> en voeg een functie <code>def main()</code> toe die het kwadraat van 5 print. count_count.py<pre><code>import square\ndef main():\nprint(f\"The square of 5 is {square.square(5)}\")\n</code></pre> We zetten daarmee de body van de module in een functie. </li> <li>Als je het script nu runt doet hij niets meer, want hij roept de functie <code>main()</code> niet aan. </li> <li>Voeg een <code>if __name__ == '__main__'</code>-statement toe waarin je de functie <code>main()</code> aanroept. </li> <li>Als je het script runt, doet hij het weer.</li> </ol> <p>In <code>pyproject.toml</code> kunnen we nu het commando toe gaan voegen. Met de <code>scripts</code>-tool van Poetry kunnen we aangeven met welk commando een functie uit een script wordt uitgevoerd. Om een commando toe te voegen ga je naar <code>pyproject.toml</code> en voeg je een extra kopje toe: <pre><code>[tool.poetry.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre> Om de wijzigingen aan <code>pyproject.toml</code> door te voeren moet je de package opnieuw installeren.</p> <p>commando toevoegen</p> <p>Voor de volgende stappen uit:</p> <ol> <li>Open <code>pyproject.toml</code> en voeg het kopje <code>[tool.poetry.scripts]</code> toe.</li> <li>Als naam voor het commando kiezen we <code>count</code>.</li> <li>Voor het gemak vullen we de rechterkant van het =-teken van rechts naar links in. Achter de dubbele punt komt de naam van de functie die uitgevoerd moet worden, dat is in ons geval <code>main</code>.</li> <li>De functie <code>main</code> staat in module <code>count_count.py</code>. De module hebben we ondergebracht in de package <code>just_count</code>.         <pre><code>[tool.poetry.scripts]\ncount = \"just_count.count_count:main\"\n</code></pre></li> <li>Omdat we handmatig de toml-file hebben aangepast installeren we de package <code>just_count</code> opnieuw met <code>poetry install</code>.</li> </ol> <p>Commando testen</p> <ol> <li>Type in de terminal het commando <code>count</code>.</li> <li>Je krijgt nu een <code>ModuleNotFoundError</code> voor de module square. Poetry zoekt vanuit de <code>src</code>-map naar de packages en modules. Pas het importstatement in <code>count_count.py</code> aan zodat het count commando werkt.   </li> <li>Activeer een andere conda environment en probeer meteen het commando opnieuw; waarom werkt dit niet?</li> <li>Navigeer naar de bovenliggende map met <code>cd..</code>. Zorg dat het conda environment waar je <code>just_count</code> hebt ge\u00efnstalleerd is geactiveerd en test het commando. </li> </ol> <p>Het maakt nu dus niet meer uit waar je bent, als je de juiste conda environment hebt geactiveerd kun je altijd je applicatie starten!</p> Error analysis <p>Als extra oefening gaan we met Poetry een commando maken om een ander script uit te laten voeren. De package is al aangemaakt, maar werkt nog niet naar behoren. Los in de volgende opdrachten de errors op om het script <code>data_analysis.py</code> te laten runnen.</p> <ol> <li>Ga naar GitHub en open <code>AnneliesVlaar/erroranalysis</code> in GitHub Desktop en Visual Studio Code.</li> <li>Natuurlijk maak je gelijk een nieuwe Conda environment aan, voordat we dit package gaan testen.</li> <li>Snuffel door de bestanden en mappen, en open <code>src/erroranalysis/data_analysis.py</code>. Dit is het script wat moet kunnen runnen.</li> <li>Run het script <code>data_analysis.py</code> en los de errors \u00e9\u00e9n voor \u00e9\u00e9n op.</li> </ol> <p>Om erachter te komen of de problemen die we hierboven hadden \u00e9cht zijn opgelost maak je een nieuwe Conda environment aan, installeer je het package en run je het script. Werkt alles? Mooi! Dan gaan we nu een commando aanmaken om de functie <code>table()</code> aan te roepen.</p> <ol> <li>Open <code>pyproject.toml</code> en voeg een kopje toe voor scripts.         <pre><code>[tool.poetry.scripts]\nnaam_commando = \"package.module:naam_functie\"\n</code></pre>         pas de regel aan zodat jouw commando de functie <code>table()</code> aanroept in <code>src/erroranalysis/data_analysis.py</code>. Je mag de naam van het commando zelf kiezen.</li> <li>Ga naar de terminal en kijk of het werkt!         Terminal<pre><code>PS&gt; naam_commando\nArea of the kitchen table is: 1.8386 \u00b1 0.0049 m\n</code></pre></li> </ol> <p>Pythondaq: applicatie</p> <p>We gaan nu een commando maken voor <code>pythondaq</code>:</p> <ol> <li>Schrijf een functie in <code>view.py</code> die je wilt uitvoeren als je het commando gaat aanroepen. Je kunt hierin de hele body van je script plaatsen.</li> <li>Voeg een commando aan <code>pyproject.toml</code> toe.</li> <li>Installeer het Poetry project en test het commando. Los eventuele errors op totdat het werkt.</li> <li>Open \u2014 buiten Visual Studio Code \u2014 een <code>Anaconda prompt</code> en test of jouw commando dan nog steeds werkt.13</li> </ol> <p>Wat een feest! Je hebt nu een applicatie geschreven die een Arduino aanstuurt om een ledje te laten branden. En je kunt je applicatie gewoon vanuit de terminal aanroepen!</p> <ol> <li> <p>Echt gebeurd: meerdere studenten leverden hun grafische applicatie in voor een beoordeling. We konden het niet draaien, want er misten bestanden. Bij de student werkte het wel, maar bij ons echt niet.\u00a0\u21a9</p> </li> <li> <p>We gaan het package opbouwen in de zogenaamde src-layout14 \u21a9</p> </li> <li> <p>Wanneer de repository op GitHub wordt geplaatst wordt deze README automatisch op de hoofdpagina van de repository getoond, onder de code.\u00a0\u21a9</p> </li> <li> <p>Python heeft een ingebouwde module <code>unittest</code> die deze tests kan vinden, kan runnen en daarna een handige weergave geeft van welke tests geslaagd zijn en welke faalden. Ook het package <code>pytest</code> is erg bekend. Op deze manier weet je altijd zeker dat wanneer je aanpassingen doet in je code, dat de rest van de code nog steeds is blijven werken \u2014 z\u00f3nder dat je zelf uitvoerig alles hebt hoeven uitproberen. Je draait gewoon even snel alle tests. Helaas, helaas \u2014 in deze cursus is te weinig tijd om het schrijven van tests te behandelen.\u00a0\u21a9</p> </li> <li> <p>Ja er is een map <code>easystat</code> met daarin een map <code>src</code> met daarin weer een map <code>easystat</code> \u2014 dat kan nog wel eens verwarrend zijn. Het is conventie om de projectmap dezelfde naam te geven als je package. Het pad is dus eigenlijk <code>project/src/package</code> en dat wordt dan, in ons geval, <code>easystat/src/easystat</code>.\u00a0\u21a9</p> </li> <li> <p>Vroeger was er een <code>setup.py</code> maar Python schakelt nu langzaam over naar dit nieuwe bestand.\u00a0\u21a9</p> </li> <li> <p>Misschien is het je al opgevallen dat VS Code een oranje kringeltje onder <code>numpy</code> zet in de eerste regel. Als je daar je muiscursor op plaatst krijg je een popup met de melding <code>Import numpy could not be resolved</code>. Daar moeten we misschien wat mee en dat gaan we straks ook doen.\u00a0\u21a9</p> </li> <li> <p>Niet formeel. Dus hoewel we een script gaan plaatsen in de <code>tests</code>-folder is het hier niet een test die automatisch gerunt kan worden.\u00a0\u21a9</p> </li> <li> <p>In f-strings kunnen tussen de accolades variabelen of functieaanroepen staan. Voeg daar het <code>=</code>-teken aan toe en je krijgt niet alleen de waarde, maar ook de variabele of aanroep zelf te zien. Bijvoorbeeld: als je definieert <code>name = \"Alice\"</code>, dan geeft <code>print(f\"{name}\")</code> als uitkomst <code>Alice</code>. Maar voeg je het <code>=</code>-teken toe zoals in <code>print(f\"{name=\")}</code> wordt de uitvoer <code>name='Alice'</code>. Je ziet dan dus ook meteen de naam van de variabele en dat kan handig zijn.\u00a0\u21a9</p> </li> <li> <p>De lijst met packages in de active Conda enviornment vraag je in de terminal op met het <code>conda list</code>, kijk maar of numpy daar tussen staat.\u00a0\u21a9</p> </li> <li> <p>Het is eenvoudig om zelf de <code>pyproject.toml</code> te openen en daar wat in aan te passen voor zover nodig.\u00a0\u21a9</p> </li> <li> <p>In ieder geval pyvisa-py, maar wat nog meer? Waarschijnlijk krijg je een foutmelding: No module named 'serial'. Met de vraag om Pyserial te installeren. Het conda package van pyvisa gaf zelf al pyserial op als dependency om te communiceren over USB. Nu we conda niet gebruiken moeten we dat handmatig doen.\u00a0\u21a9</p> </li> <li> <p>Activeer wel eerst de juiste conda environment.\u00a0\u21a9</p> </li> <li> <p>Hynek Schlawack. Testing &amp; packaging. URL: https://hynek.me/articles/testing-packaging/.\u00a0\u21a9</p> </li> <li> <p>Tom Preston-Werner, Pradyun Gedam, and others. Tom's obvious, minimal language. URL: https://github.com/toml-lang/toml.\u00a0\u21a9</p> </li> </ol>"},{"location":"software-tools/","title":"Gereedschap","text":""},{"location":"software-tools/#isolatie-virtual-environments","title":"Isolatie: virtual environments","text":"<p>Je hebt het misschien al gemerkt: Anaconda neemt veel schijfruimte in beslag. Dat is gek, want Python is best klein. Anaconda bevat alleen veel meer dan Python. Anaconda is een Python-distributie en bevat een enorme verzameling aan packages. Je kunt zelf extra packages installeren met <code>conda</code> of <code>pip</code>. Je loopt dan mogelijk wel tegen problemen aan: packages hebben vaak zelf weer andere packages nodig. En regelmatig ook met een bepaalde versie. Dit kan een ingewikkeld netwerk worden waarbij het installeren van een nieuwe package \u00f3f heel lang duurt, \u00f3f niet kan vanwege een conflict,1 \u00f3f blind gedaan wordt waarna sommige dingen niet meer willen werken. Alledrie is op te lossen door virtual environments te gebruiken. Ge\u00efsoleerde omgevingen met een eigen \u2014 veelal kleine \u2014 collectie van packages. Soms zelfs met een eigen versie van Python. Je kunt environments aanmaken voor specifieke projecten bijvoorbeeld: een omgeving voor NSP1, een omgeving voor ECPC en een omgeving voor een hobbyproject. Wellicht heb je bij NSP1 een environment aangemaakt om Jupyter Notebooks en een verzameling packages te installeren voor de data-analyse.</p>"},{"location":"software-tools/#pip-vs-conda","title":"Pip vs Conda","text":"<p>De package manager van Python is <code>pip</code>. Je kunt hiermee alle Python packages installeren die bestaan uit Python code. NumPy bijvoorbeeld bevat echter ook veel code geschreven in C. Die code moet eerst gecompileerd worden. Dat kan <code>pip</code> \u00f3\u00f3k doen, mits er een C compiler op je computer ge\u00efnstalleerd is. Via de Python package index kunnen gelukkig ook zogeheten binary packages verspreid worden waarin de code al is gecompileerd. Er zijn dan losse packages voor Windows, MacOS en Linux. Meestal gaat dit goed, maar helaas niet altijd. Historisch waren NumPy maar vooral ook SciPy een flink probleem. Ook het gebruik van grafische bibliotheken ging vaak moeizaam. Dan was het package wel ge\u00efnstalleerd, maar riep hij dat hij systeembibliotheken niet kon vinden. Heel vervelend.</p> <p>Een ander probleem van <code>pip</code> is dat deze \u2014 tot voor kort \u2014 geen controle deed op de versies van al ge\u00efnstalleerde pakketten. Je kon dus packages installeren die nieuwe versies binnenhaalden van andere packages, waarna al eerder ge\u00efnstalleerde packages soms stopten met werken.</p> <p>Om die reden is <code>conda</code> in het leven geroepen. Conda installeert alleen binary packages, kan naast Python packages ook systeembibliotheken installeren als dat nodig is \u00e9n doet een uitgebreide controle op alle versies van te installeren en al eerder ge\u00efnstalleerde packages zodat alles altijd blijft werken. Nadeel is dat die controle nogal lang kan duren als je al veel ge\u00efnstalleerd hebt. Omdat je met <code>conda</code> dus wel heel makkelijk uitgebreide wetenschappelijke packages kon installeren met een mix van Python-, C-, of zelfs Fortrancode is <code>conda</code> (en Anaconda, de distributie) heel populair geworden in de wetenschappelijke wereld. Omdat jullie bij vorige cursussen al gewerkt hebben met Anaconda zullen we dat deze cursus ook gebruiken, maar we gaan veel met <code>pip</code> werken om packages te schrijven die door alle Pythongebruikers gebruikt kunnen worden.</p>"},{"location":"software-tools/#conda-environments","title":"Conda environments","text":"<p>Er zijn verschillende tools voor het aanmaken van environments voor Python. Allemaal hebben ze hun voor- en nadelen. Langzamerhand blijven de populairste over. De offici\u00eble is <code>venv</code>, maar op dit moment niet de meest populaire. Binnen een groot deel van de wetenschappelijke gemeenschap is <code>conda</code> de standaardkeuze. Het voordeel van <code>conda</code> ten opzichte van veel andere tools is dat je verschillende environments kunt maken met verschillende versies van Python. Ideaal om te testen of je code ook werkt met de allernieuwste Pythonversie of juist met wat oudere versies.</p> <p>Je moet je realiseren dat het aanmaken (en weggooien) van een environment heel makkelijk is. Doe dat regelmatig zodat je scherp houdt welke packages je nu echt nodig hebt voor je analyse of voor de software die je schrijft. Hieronder geven we een overzicht van de meest gebruikte commando's om met conda environments te werken.</p> <p>Info</p> <p>Conda installeert packages vanuit verschillende channels. De <code>defaults</code> channel bevat packages die af en toe door Anaconda worden getest en samengenomen tot een distributie (versie <code>2021.05</code> bijvoorbeeld). Er zijn weinig updates. De <code>conda-forge</code> channel bevat alle nieuwste versies van die packages en bevat ook software die (nog) niet in de <code>defaults</code> channel terecht is gekomen. De conda-forge channel is daarom erg populair, maar er gaat ook regelmatig iets stuk.</p> <p>Hieronder volgen enkele voorbeelden van het gebruik van conda: Terminal<pre><code>Leeg environment aanmaken met naam 'pythondaq' (leeg = zelfs geen Python)\nPS&gt; conda create -n pythondaq\nNieuw environment aanmaken met Python versie 3.10\nPS&gt; conda create -n pythondaq python=3.10\nPackages installeren vanuit de 'conda-forge' channel en nieuwste Python\nAls het environment al bestaat vraagt hij of hij die moet overschrijven met een nieuwe schone versie\nPS&gt; conda create -n pythondaq -c conda-forge python\nEnvironment activeren\nPS&gt; conda activate pythondaq\nEnvironment deactiveren\nPS&gt; conda deactivate\nEnvironment wissen\nPS&gt; conda env remove -n pythondaq\nLijst van environments bekijken\nPS&gt; conda env list\nNieuw pakket installeren vanuit de conda-forge channel in het ACTIEVE environment\nPS&gt; conda install -c conda-forge lmfit\nNieuw environment voor NSP2 met notebooks voor analyse en fits\nPS&gt; conda create -n nsp2 -c conda-forge notebook pandas matplotlib lmfit\nPackage pandas updaten naar nieuwe versie in het ACTIEVE environment\nPS&gt; conda update -c conda-forge pandas\nAlle packages updaten naar nieuwe versie in het ACTIEVE environment\nPS&gt; conda update -c conda-forge --all\n</code></pre></p> <p>Als je scripts schrijft in Visual Studio Code wil je dat ze ook runnen in de omgevingen die je net hebt aangemaakt. Als je in Visual Studio Code een python script opent dan geeft het rechtsonder, in de statusbalk, de huidige Pythonomgeving aan:</p> <p></p> <p>Als je daarop klikt2 kun je door de lijst met Pythonomgevingen scrollen. Kies de omgeving die je wilt gebruiken. Let op: als je het environment net hebt aangemaakt dan staat hij er nog niet tussen. Klik dan rechtsbovenin eerst op het  Refresh Interpeter list-knopje. Bijvoorbeeld:</p> <p></p> <p>Sluit alle oude terminals met het -icoon als je je muis aan de rechterkant over de namen van de terminals beweegt of in \u00e9\u00e9n keer met View &gt; Command Palette &gt; Terminal: Kill All Terminals. Alle nieuwe terminals die je opent zullen de nieuw geselecteerde conda environment actief maken. Wanneer je nu je Pythoncode draait dan is dat binnen deze omgeving. Het kan wel zijn dat hij opeens klaagt over packages die niet ge\u00efnstalleerd zijn omdat je dat \u2014 in die omgeving \u2014 nog niet had gedaan. Geen probleem: installeer ze dan.</p>"},{"location":"software-tools/#pipx","title":"Pipx","text":"<p>Pythonapplicaties, zoals <code>conda</code>, worden ge\u00efnstalleerd als commando dat je kunt aanroepen vanaf de command-line. Maar het is een Pythonapplicatie. En dat betekent dat als je van omgeving wisselt, de applicatie niet meer beschikbaar is. Ook kan het gebeuren dat je packages update of verwijdert waardoor de applicatie niet meer werkt. Met <code>pipx</code> is het mogelijk om dit soort applicaties in een eigen virtual environment te installeren. Je loopt geen risico dat je ze stukmaakt en ze zijn beschikbaar vanuit andere virtual environments. In plaats van: Terminal<pre><code>pip install PACKAGE\n</code></pre> doe je straks Terminal<pre><code>pipx install PACKAGE\n</code></pre> Met <code>pipx list</code> bekijk je dan een lijst van ge\u00efnstalleerde pakketten. Je installeert <code>pipx</code> met: Terminal<pre><code>python -m pip install --user pipx\npython -m pipx ensurepath\n</code></pre> Herstart je terminal en test of het commando <code>pipx</code> werkt. Als je in een terminal in Visual Studio Code werkt moet je dat ook herstarten en als je VS Code gestart hebt vanuit GitHub Desktop moet je \u00f3\u00f3k dat herstarten. Werkt het nog steeds niet, dan zul je volledig uit moeten loggen en weer in moeten loggen om de shellomgeving opnieuw te laden en/of vraag om hulp.</p>"},{"location":"software-tools/#coding-style-black","title":"Coding style: Black","text":"<p>Code wordt veel vaker gelezen dan geschreven, is een veel geciteerd gezegde onder programmeurs. Je schrijft je code en zit vervolgens uren te puzzelen om een fout te vinden of hoe je de code het beste kunt uitbreiden. Je zoekt op internet naar voorbeeldcode, je helpt een medestudent of vraagt die om hulp. Heel vaak dus lees je niet je eigen code, maar die van iemand anders. Is dat relevant? Ja! Want die code ziet er anders uit. Iedereen programmeert toch op zijn eigen manier. Het scheelt enorm als de code er tenminste grotendeels hetzelfde uitziet. Het kost je dan minder energie om te lezen. Daarom ook dat de artikelen in wetenschappelijke tijdschriften bijvoorbeeld er allemaal hetzelfde uitzien en de auteur niet de vrijheid krijgt om z\u00e9lf lettertypes te kiezen. Net zo goed hebben grote organisaties vaak hun eigen coding style ontwikkeld waar alle werknemers zich zoveel mogelijk aan moeten houden.</p> <p>Python heeft een eigen style guide die je vooral eens door moet lezen.3 Google heeft ook een hele mooie, met duidelijke voorbeelden.4</p> <p>Fijn dat je code consistenter wordt, maar het moet nu ook weer niet zo zijn dat je uren kwijt bent met de style guides bestuderen of twijfelen waar je een regel code precies moet afbreken. Wel of niet een enter? Om daar vanaf te zijn zijn er verschillende pakketten die je code automatisch aanpassen aan de standaard. Als je de instelling Editor: Format On Save aan zet (staat standaard uit) dan wordt je code aangepast zodra je je bestand opslaat. Black is zo'n formatter en heeft een `eigen mening'. Als je je daar bij neerlegt hoef je bijna niet meer na te denken over hoe je je code precies vormgeeft. De Black website zegt5:</p> <p>   By using Black, you agree to cede control over minutiae of hand-formatting. In return, Black gives you speed, determinism, and freedom from pycodestyle nagging about formatting. You will save time and mental energy for more important matters. </p> <p>Black is tegenwoordig immens populair en in Visual Studio Code kun je hem gebruiken door de Black Formatter-extensie van Microsoft te installeren. De code in deze handleiding is geformat met Black. In Visual Studio Code, ga naar File en dan naar Preferences &gt; Settings &gt; Editor: Format On Save en vink die aan. De eerste keer dat je je bestand opslaat zal hij vragen of hij Black moet gebruiken, daarna wordt je code altijd netjes gemaakt zodra je je Pythonbestand bewaart.</p> <p>De volgende code:</p> <pre><code>s1 = 'Hello'\ns2 = \"World\"\nvalues = [1,2,3,4,5]\nf = a * x ** 2 + b * x + c\ng = a*x +b\nh = A*np.sin(2*pi*f*t+phi) + A2*np.sin(2*pi*f2*t+phi2) + A3*np.sin(2*pi*f3*t+phi3)\n</code></pre> <p>wordt door Black omgezet in:</p> <pre><code>s1 = \"Hello\"\ns2 = \"World\"\nvalues = [1, 2, 3, 4, 5]\nf = a * x**2 + b * x + c\ng = a * x + b\nh = (\nA * np.sin(2 * pi * f * t + phi)\n+ A2 * np.sin(2 * pi * f2 * t + phi2)\n+ A3 * np.sin(2 * pi * f3 * t + phi3)\n)\n</code></pre> <ol> <li> <p>Stel package A heeft package B nodig met versie &gt;= 1.1, maar package C heeft package B nodig met versie 1.0. Nu kunnen packages A en C dus niet tegelijkertijd ge\u00efnstalleerd worden.\u00a0\u21a9</p> </li> <li> <p>Of: View &gt; Command Palette &gt; Python: Select Interpreter.\u00a0\u21a9</p> </li> <li> <p>Guide van Rossum. Pep 8 \u2013 style guide for python code. URL: https://www.python.org/dev/peps/pep-0008/.\u00a0\u21a9</p> </li> <li> <p>Google. Google python style guide. URL: https://google.github.io/styleguide/pyguide.html.\u00a0\u21a9</p> </li> <li> <p>\u0141ukasz Langa. Black, the uncompromising code formatter. URL: https://black.readthedocs.io/en/stable/.\u00a0\u21a9</p> </li> </ol>"},{"location":"voorkennis/","title":"Python voorkennis; Batteries (not yet) included","text":"<p>Python is een batteries included taal. Dat betekent dat als je 'kaal' Python installeert er al heel veel functionaliteit standaard meegeleverd wordt. Allereerst omdat de taal zelf al behoorlijk krachtig is, maar ook omdat de standaardbibliotheek zeer uitgebreid is. Met een eenvoudig <code>import</code>-statement haal je extra functionaliteit binnen, onder andere op het gebied van datatypes, wiskunde, toegang tot bestanden, een database, datacompressie, cryptografie, netwerktoegang, e-mail, multimedia, etc. Nog veel meer bibliotheken zijn beschikbaar via de Python Package Index18.</p> <p>In dit hoofdstuk behandelen we de kennis die nuttig kan zijn voor de rest van deze cursus. We gaan ervan uit dat iedereen bekend is met recente versies van Python en we gaan niet in op de -- soms ingrijpende -- veranderingen die de taal heeft ondergaan.1 Een deel van wat we hier behandelen kan al bekend zijn uit eerdere cursussen. Een ander deel is nieuw.2</p> <p>In de cursus gaan we bibliotheken (modules, packages) en een applicatie ontwikkelen. Dat betekent dat we verder gaan dan het schrijven van scripts en dat we dus meer gaan doen dan functies schrijven. Uiteindelijk moet het mogelijk zijn de software te verspreiden op een wat meer professionele manier. Dus niet alleen via een zipje met wat Pythonbestanden waar uiteindelijk verschillende versies van rondslingeren en die lastig zijn te updaten. Wat er nodig is voor een goede distributie van software en om het mogelijk te maken met meerdere mensen software te (blijven) ontwikkelen zal in deze cursus aan bod komen.</p> <p>Een punt wat vaak onderschoven blijft is documentatie. Als je software schrijft die gebruikt (en doorontwikkeld) wordt in een onderzoeksgroep, dan is het heel belangrijk dat iedereen kan begrijpen wat je software doet en hoe die uitgebreid kan worden. Het is zonder hulp vaak heel moeilijk om de code van een iemand anders te begrijpen. En in de praktijk blijkt heel vaak dat als je code schrijft en daar een paar weken of maanden later op terugkijkt, jij z\u00e9lf die ander bent. Wat toen blijkbaar heel logisch leek, is dat later toch niet meer. Dus documentatie schrijf je heel vaak ook gewoon voor jezelf.</p> <p>Als je niet zo heel veel in Python geprogrammeerd hebt kan het helpen om de paragraaf over de cursus inleiding programmeren19 door te nemen. Een boek dat zeker bij natuurkundigen in de smaak kan vallen is Effective Computation in Physics20, maar deze is niet gratis verkrijgbaar. Een boek dat zowel op papier te bestellen is als in de vorm van een pdf of webpagina is te lezen is Think Python.21</p>"},{"location":"voorkennis/#zen-of-python","title":"Zen of Python","text":"<p>Python is niet C (of iedere willekeurige andere programmeertaal). Er zit een gedachte achter die op een gegeven moment verwoord is door Tim Peters22.</p> <p>Je kunt het lezen middels een easter egg in Python zelf: <code>import this</code>.</p> <p>zen</p> <p>Open een Python terminal en type in: Terminal<pre><code>import this\n</code></pre></p> <p>Deze tekst kan nog behoorlijk cryptisch overkomen, maar een paar dingen worden snel duidelijk: code moet mooi zijn (regel 1) en duidelijk (regels 2, 3 en 6). Er bestaan prachtige programmeertrucs in \u00e9\u00e9n of twee regels, maar onleesbaar is het wel. Een voorbeeld 23: <pre><code>print('\\n'.join(\"%i bytes = %i bits which has %i possible values.\" %\n(j, j*8, 256**j) for  j in (1 &lt;&lt; i for i in range(4))))\n</code></pre></p> <p>Kun je zien wat de uitvoer van dit programma moet zijn? Misschien als we het op deze manier uitschrijven:</p> <p><pre><code>for num_bytes in [1, 2, 4, 8]:\nnum_bits = 8 * num_bytes\nnum_possible_values = 2 ** num_bits\nprint(\nf\"{num_bytes} bytes = {num_bits} bits which has {num_possible_values} possible values.\"\n)\n</code></pre> De code is langer, met duidelijkere namen van variabelen en zonder bitshifts of joins. De uitvoer zie je hieronder.</p> Terminal<pre><code>1 bytes = 8 bits which has 256 possible values.\n2 bytes = 16 bits which has 65536 possible values.\n4 bytes = 32 bits which has 4294967296 possible values.\n8 bytes = 64 bits which has 18446744073709551616 possible values.\n</code></pre> <p>Moraal van dit verhaal: we worden gelukkiger van code die leesbaar en begrijpelijk is, dan van code die wel heel slim in elkaar zit maar waar bijna niet uit te komen is. Overigens komt het regelmatig voor dat de programmeur z\u00e9lf een paar weken later al niet zo goed meer weet hoe de code nou precies in elkaar zat.</p> <p>Als je samenwerkt aan software kan het andere Pythonprogrammeurs erg helpen om dingen 'op de Python-manier te doen'. Een C-programmeur herken je vaak aan het typische gebruik van lijsten of arrays in <code>for</code>-loops. Als je een lijst hebt: <code>names = ['Alice', 'Bob', 'Carol']</code>, doe dan niet: <pre><code>i = 0\nwhile i &lt; len(names):\nprint(\"Hi,\", names[i])\ni = i + 1\n</code></pre> of: <pre><code>for i in range(len(names)):\nprint(\"Hi,\", names[i])\n</code></pre> waarbij je loopt over een index <code>i</code>. Gebruik liever het feit dat een lijst al een iterator is: <pre><code>for name in names:\nprint(\"Hi,\", name)\n</code></pre> Deze code is bovendien veel korter en gebruikt minder variabelen. Soms is het nodig om de index te hebben, bijvoorbeeld wanneer je een namenlijstje wilt nummeren: Terminal<pre><code>1. Alice\n2. Bob\n3. Carol\n</code></pre></p> <p>Dit kan dan in Python-code het makkelijkst als volgt: <pre><code>for idx, name in enumerate(names, 1):\nprint(f\"{idx}. {name}\")\n</code></pre> Hier maken we gebruik van de <code>enumerate(iterable, start=0)</code>-functie en de (relatief recent ge\u00efntroduceerde) f-strings. Er zijn dus veel manieren om programmeerproblemen op te lossen, maar het helpt om het op de `Pythonmanier' te doen. Andere programmeurs zijn dan veel minder tijd en energie kwijt om jouw code te begrijpen -- \u00e9n andersom wanneer jij zelf op internet zoekt naar antwoorden op problemen. Immers, je herkent dan veel makkelijker en sneller hoe andermans code werkt.</p>"},{"location":"voorkennis/#datatypes","title":"Datatypes","text":"<p>Gehele getallen, kommagetallen, strings: allemaal voorbeelden van datatypes. Veel zullen jullie al wel bekend voorkomen, zoals strings, lists en NumPy arrays. Andere zijn misschien alweer wat weggezakt, zoals dictionaries of booleans. Weer andere zijn misschien wat minder bekend, zoals complexe getallen of sets. En als laatste voegt Python af en toe nieuwe datatypes toe, zoals f-strings in Python 3.6 of data classes sinds Python 3.7.</p> <p>Info</p> <p>De python-standard-library documentatie 24 bevat een mooi overzicht van alle datatypes met een beschrijving van operaties en eigenschappen. Voor uitgebreidere tutorials kun je vaak terecht bij real-python 25. Het kan makkelijk zijn om in een zoekmachine bijvoorbeeld <code>real python dict</code> te typen als je een tutorial zoekt over Python dictionaires.</p> <p>Om nog even te oefenen met de datatypes volgt er een aantal korte opdrachten.</p> <p>list</p> <p>Schrijf een kort scriptje.</p> <ol> <li>Maak een <code>list</code> van de wortels van de getallen 1 tot en met 10. Dus de rij $\\left(\\sqrt{1}, \\sqrt{2}, \\sqrt{3}, \\ldots, \\sqrt{10}\\right)$.</li> <li>Print die rij onder elkaar (\u00e9\u00e9n getal per regel, met drie decimalen).</li> <li>Geef weer of het getal 3 voorkomt in die rij en geef weer of het getal 4 voorkomt in die rij.</li> </ol> <p>np.array</p> <p>Doe hetzelfde als de vorige opdracht, maar nu met NumPy arrays.</p> <p>f-strings</p> <p>Herschrijf het volgende script door f-strings te gebruiken: <pre><code>print(\"Enter your name and press return:\")\nname = input()\nlength_name = len(name)\nprint(\n\"Hi %s, your name has %d letters and the first letter is a %c.\"\n% (name, length_name, name[0])\n)\n</code></pre></p>"},{"location":"voorkennis/#dictionaries-tuples-args-kwargs-and-sets","title":"dictionaries, tuples, * args, ** kwargs and sets","text":"Meer leren <p>Dictionaries zijn een bijzonder handige manier om informatie op te slaan. Een dictionary bestaat uit een of meerder key-value tweetallen. Met een handige gekozen naam voor de key kan je betekenis geven aan een value. </p> <p>dict</p> <p>Schrijf een kort scriptje:</p> <ol> <li>Maak een dictionary <code>constants</code> met de waardes van de (natuur)constantes $\\pi$, de valversnelling $g$, de lichtsnelheid $c$ en het elementaire ladingskwantum $e$.</li> <li>Print de namen -- niet de waardes -- van de constantes die zijn opgeslagen in <code>constants</code>.</li> <li>Bereken de zwaartekracht $F_\\text{z} = mg$ voor een voorwerp met een massa van 14 kg door gebruik te maken van de waarde van $g$ uit de dictionary.</li> <li>Maak een dictionary <code>measurement</code> die de resultaten van een meting bevat: een spanning van 1.5 V bij een stroomsterkte van 75 mA.</li> <li>Bereken de weerstand van de schakeling op basis van de voorgaande meting en bewaar het resultaat in dezelfde dictionary.</li> </ol> <p>In Python zijn <code>tuple</code>'s een soort alleen-lezen <code>list</code>'s. Een tuple is een immutable3 object. Daarom worden ze vaak gebruikt wanneer lijstachtige objecten altijd dezelfde vorm moeten hebben. Bijvoorbeeld een lijst van $(x, y)$-co\u00f6rdinaten zou je zo kunnen defini\u00ebren:</p> <p><pre><code>coords = [(0, 0), (1, 0), (0, 1)]\n</code></pre> Hier is <code>coords[0]</code> gelijk aan <code>(0, 0)</code>. Je kunt nu niet dit co\u00f6rdinaat uitbreiden naar drie dimensies met <code>coords[0].append(1)</code> en dat is waarschijnlijk precies wat je wilt voor een lijst met tweedimensionale co\u00f6rdinaten. Ook is dit object veel compacter dan een <code>dict</code>: <pre><code>coords = [{\"x\": 0, \"y\": 0}, {\"x\": 1, \"y\": 0}, {\"x\": 0, \"y\": 1}]\n</code></pre> Hier zijn tuples dus best handig, al moet je dus wel onthouden in welke volgorde de elementen staan. Dat is voor $(x, y)$-co\u00f6rdinaten niet zo'n probleem maar kan in andere situaties lastiger zijn.4 Tuples ondersteunen tuple unpacking. Je kunt het volgende doen:</p> <p><pre><code>(x, y, z) = (2, 3, 4)\n</code></pre> Na deze operatie geldt $x = 2$, $y = 3$ en $z = 4$. Je mag zelfs de haakjes weglaten voor nog compactere notatie: <pre><code>x, y, z = 2, 3, 4\n</code></pre> Op deze manier kan een functie ook meerdere argumenten teruggeven die je vervolgens uit elkaar plukt: <pre><code>def get_measurement():\n...  # perform measurement\nreturn voltage, current\nvoltage, current = get_measurement()\n</code></pre> Het uit elkaar plukken van argumenten kan zelfs als je een functie aanroept: <pre><code>def power(a, b):\nreturn a ** b\n# regular function call\npower(2, 7)\n# function call with tuple unpacking\nargs = 2, 7\npower(*args)\n</code></pre> Wat zelfs werkt is dictionary unpacking. Je kunt aan functies ook argumenten bij naam meegeven -- de volgorde maakt dan niet uit en je maakt in je programma expliciet duidelijk welke argumenten je meegeeft. Dat werkt zo: <pre><code># regular function call\npower(b=7, a=2)\n# function call with dictionary unpacking\nkwargs = {\"b\": 7, \"a\": 2}\npower(**kwargs)\n</code></pre></p> <p>odds</p> <p>Gegeven de lijst <code>odds = [1, 3, 5, 7, 9]</code>, print de waardes uit deze lijst op \u00e9\u00e9n regel. Je mag er niet vanuit gaan dat de lijst altijd 5 elementen bevat.</p> <p>Als laatste willen we nog de aandacht vestigen op <code>set</code>'s: een unieke verzameling van objecten. Ieder element komt maar \u00e9\u00e9n keer voor in een set: <pre><code>l = [1, 2, 2, 3, 5, 5]\nset(l)\n# {1, 2, 3, 5}\n</code></pre> Je moet even oppassen: de <code>{}</code>-haakjes worden gebruikt voor zowel sets als dictionaries. Omdat een dictionary (key: value) paren heeft en een set losse elementen kan Python het verschil wel zien: <pre><code>is_set = {1, 2, 3, 4}\nis_dict = {1: 1, 2: 4, 3: 9, 4: 16}\n</code></pre> Dat gaat alleen mis als je een lege set wilt maken. Daarvoor zul je expliciet de <code>set()</code>-constructor moeten gebruiken: <pre><code>is_dict = {}\nis_set = set()\n</code></pre> Je kunt elementen toevoegen aan een set met <code>.add()</code> en sets gebruiken om verzamelingen met elkaar te vergelijken. Komen er elementen wel of niet voor in een set? Is de ene set een subset van de andere set? Enzovoorts. Zie daarvoor verder de documentatie.</p>"},{"location":"voorkennis/#arrays-en-comprehensions","title":"Arrays en comprehensions","text":"<p>NumPy arrays zijn vaak handiger dan lists. Als je een array hebt van 20 $x$-waardes in het domein $[0, \\pi]$ kun je in \u00e9\u00e9n keer alle waardes van $\\sin x$ uitrekenen. Bijvoorbeeld: <pre><code># from numpy import pi, linspace, sin\nx = linspace(0, pi, 20)\ny = sin(x)\n</code></pre> NumPy voert de berekeningen uit binnen een C-bibliotheek5 en is daarmee veel sneller dan een berekening in Python zelf:</p> <p><pre><code># x = [list of x-values]\ny = []\nfor u in x:\ny.append(sin(u))\n</code></pre> Niet alleen is NumPy zo'n honderd keer sneller,6 het is ook veel korter op te schrijven. Het nadeel van NumPy arrays is dat je geen elementen kunt toevoegen.7 Python lijsten hebben dus voordelen, zeker als rekentijd geen probleem voor je is.</p> <p>Als je veel functies uit NumPy gebruikt is het handig -- en gebruikelijk -- om je import-statements kort te houden en duidelijk te maken dat je de <code>sin()</code>-functie uit NumPy gebruikt en niet uit de <code>math</code> module. Constantes worden wel vaak los ge\u00efmporteerd: <pre><code>import numpy as np\nfrom numpy import pi\nx = np.linspace(0, pi, 100)\ny = np.sin(x)\n</code></pre></p>"},{"location":"voorkennis/#comprehensions","title":"comprehensions","text":"<p>Door gebruik te maken van een list comprehension kun je de for-loop in \u00e9\u00e9n regel opschrijven: <pre><code># x = [list of x-values]\ny = [sin(u) for u in x]\n</code></pre> Er is in veel gevallen tegenwoordig geen groot verschil met een for-loop qua snelheid. In andere gevallen is de list comprehension net wat sneller. Als je lijsten niet te lang zijn is het makkelijker (en sneller) om een list comprehension te gebruiken in plaats van je lijst \u00e9\u00e9rst naar een array te veranderen en er dan mee verder te rekenen. Als je lijst w\u00e9l lang is of je weet al dat je meerdere berekeningen wilt uitvoeren kan dat wel: <pre><code># from numpy import sin, array\n# x = [list of x-values]\nx = array(x)\ny = sin(x)\n</code></pre></p> <p>Kortom: berekeningen met arrays zijn sneller, maar for-loops (en list comprehensions) zijn veelzijdiger. Het is zelfs mogelijk om een <code>if</code>-statement op te nemen in je list comprehension. Bijvoorbeeld: <pre><code>filenames = [\"test.out\", \"text.pdf\", \"manual.pdf\", \"files.zip\"]\npdfs = [name for name in filenames if name.endswith(\".pdf\")]\n# pdfs=['text.pdf', 'manual.pdf']\n</code></pre> In een for-loop heb je daar meer ruimte voor nodig. Naast list comprehensions heb je ook set comprehensions8 en dict comprehensions.</p> <p>array, for-loops en comprehensions</p> <p>Voer, door een script te schrijven, de volgende opdrachten uit:</p> <ol> <li>Maak een lijst van de getallen 1 tot en met 10.</li> <li>Gebruik een 'gewone' for-loop om een lijst te maken van de derdemachtswortel van de getallen.</li> <li>Maak nogmaals een lijst van de derdemachtswortel van de getallen maar gebruik nu list comprehension.</li> <li>Gebruik tot slot arrays om de lijst met derdemachtswortels van de getallen te maken. </li> </ol>"},{"location":"voorkennis/#lambda-functions","title":"Lambda functions","text":"meer leren <p>In Python zijn functies ook objecten. Je kunt ze bewaren in een lijst of dictionary, of je kunt ze meegeven als parameter aan een andere functie. Dat kan heel handig zijn! Stel je hebt een lijst met verschillende soorten fruit die je wilt sorteren op alfabet: <pre><code>a = [\"kiwi\", \"banana\", \"apple\"]\nsorted(a)\n# ['apple', 'banana', 'kiwi']\n</code></pre> Dat gaat heel makkelijk met de ingebouwde <code>sorted()</code>-functie. Je kunt aan deze functie ook een <code>key</code>-parameter meegeven; een \u00e1ndere functie die gebruikt wordt om te bepalen waarop gesorteerd moet worden. Zo kun je sorteren op de lengte van de fruitnamen door simpelweg de <code>len()</code>-functie als parameter mee te geven: <pre><code>len(\"apple\")\n# 5\nsorted(a, key=len)\n# ['kiwi', 'apple', 'banana']\n</code></pre> Als je wilt sorteren op de tweede letter van de naam -- waarom niet? -- dan kun je zelf een functie defini\u00ebren en gebruiken: <pre><code>def second_letter(value):\nreturn value[1]\nsecond_letter(\"lemon\")\n# e\nsorted(a, key=second_letter)\n# ['banana', 'kiwi', 'apple']\n</code></pre> Lambdafuncties zijn bedacht om je een hoop typewerk te besparen. Je kunt korte functies in \u00e9\u00e9n regel opschrijven en gebruiken, zolang het maar een geldige expression is. G\u00e9\u00e9n if-then-else, maar de meeste andere dingen mogen wel. Bijvoorbeeld: <pre><code>squared = lambda x: x ** 2\nsquared(4)\n# 16\nsecond_letter = lambda x: x[1]\nsorted(a, key=second_letter)\n# ['banana', 'kiwi', 'apple']\n</code></pre> Aangezien de definitie van een lambdafunctie zelf ook een expression is kun je het sorteren op de tweede letter zelfs in \u00e9\u00e9n regel doen: <pre><code>sorted(a, key=lambda x: x[1])\n# ['banana', 'kiwi', 'apple']\n</code></pre></p> <p>Lambdafuncties kom je ook tegen als je wilt fitten aan een bepaald model. Je defini\u00ebert je model dan in \u00e9\u00e9n regel met een lambdafunctie:9</p> <p><pre><code># from lmfit import models\nf = lambda x, a, b: a * x + b\nmodel = models.Model(f)\nfit = model.fit(y, x=x)\n</code></pre> Je kunt de functies ook bewaren in een dictionary voor later gebruik.</p> <p>lambda</p> <p>Maak een dictionary <code>models</code> met functies voor een lineaire functie <code>linear</code> gegeven door $y = ax + b$, een kwadratische functie <code>quadratic</code> gegeven door $y = ax^2 + bx + c$ en een sinusfunctie <code>sine</code> gegeven door $a + b\\sin(cx + d)$. Hierna moet de volgende code werken: <pre><code>f = models['linear']\nf(5, a=2, b=3)\n# 13\n</code></pre> Maak een grafiek van de sinusfunctie op het domein $[0,\\, 2\\pi]$ met parameters $a=1$, $b=2$, $c=2$ en $d=\\frac{\\pi}{2}$.</p>"},{"location":"voorkennis/#generators","title":"Generators","text":"meer leren <p>Als een functie een serie metingen verricht kan het lang duren voordat de functie de resultaten teruggeeft. Laten we die functie even <code>perform_measurements()</code> noemen. Het is soms lastig als de rest van het programma daarop moet wachten voordat een analyse kan worden gedaan, of een melding aan de gebruiker kan worden gegeven. Het kan dan gebeuren dat je je programma draait en je dan afvraagt: doet hij het, of doet hij het niet? Je kunt dit oplossen door <code>print()</code>-statements in je programma op te nemen, maar dit is niet zo netjes. Als je <code>perform_measurements()</code> inbouwt in een tekstinterface die ook stil moet kunnen zijn? Of als je de functie gaat gebruiken vanuit een grafisch programma waarin je geen tekst wilt printen, maar een grafiek wilt opbouwen? Je moet dan steeds <code>perform_measurements()</code> gaan aanpassen. Een ander probleem kan optreden wanneer je langdurige metingen doet die ook veel geheugen innemen. Wachten op de hele meetserie betekent dat het geheugen vol kan lopen. Lastig op te lossen!</p> <p>Of\u2026 je maakt gebruik van een generator function: een functie die tussendoor resultaten teruggeeft. Dat kan door gebruik te maken van <code>yield</code> in plaats van <code>return</code>. De rest gaat automatisch. Maar: je moet wel even weten hoe je omgaat met de generator. Stel, we willen de kwadraten berekenen van een reeks getallen tot een bepaald maximum: <pre><code>def calculate_squares_up_to(max_number):\n\"\"\"Calculate squares of all integers up to a maximum number\"\"\"\nsquares = []\nfor number in range(max_number):\nsquares.append(number ** 2)\nreturn squares\ncalculate_squares_up_to(5)\n# [0, 1, 4, 9, 16]\n</code></pre> De functie berekent eerst alle kwadraten, voegt ze toe aan een lijst en geeft vervolgens de lijst met uitkomsten terug. Een generator definieer je als volgt: <pre><code>def calculate_squares_up_to(max_number):\n\"\"\"Generate squares of all integers up to a maximum number\"\"\"\nfor number in range(max_number):\nyield number ** 2\n</code></pre> Lekker kort, want we hoeven geen lijst bij te houden! Als je de functie aanroept krijg je geen resultaat terug, maar een generator. Als je de waardes wil zien dan gebruik je <code>next()</code>, als volgt: <pre><code>square_generator = calculate_squares_up_to(5)\nnext(square_generator)\n# 0\nnext(square_generator)\n# 1\n...\nnext(square_generator)\n# 16\nnext(square_generator)\n# StopIteration\n</code></pre> Als de generator is uitgeput (de for-loop is afgelopen, de functie sluit af) dan geeft Python een <code>StopIteration</code> exception en crasht het programma -- tenzij je de exception afvangt. Het werkt, maar het is niet helemaal ideaal. Makkelijker is om de generator te gebruiken in een loop: <pre><code>for square in calculate_squares_up_to(5):\nprint(\"Still calculating...\")\nprint(square)\n# Still calculating...\n# 0\n# Still calculating...\n# 1\n# Still calculating...\n# 4\n# Still calculating...\n# 9\n# Still calculating...\n# 16\n</code></pre> Dit kan ook in list comprehensions. En als je toch wilt wachten op alle resultaten, dan kan dat eenvoudig met <code>squares = list(calculate_squares_up_to(5))</code>.</p> <p>generators</p> <p>Schrijf een generator function die het vermoeden van Collatz illustreert. Dat wil zeggen: beginnend bij een getal $n$, genereer het volgende getal als volgt: is het getal even, deel het dan door twee; is het getal oneven, vermenigvuldig het met 3 en tel er 1 bij op. Enzovoorts. Sluit de generator af als de uitkomst gelijk is aan 1. Dat is het vermoeden van Collatz: ongeacht met welk geheel getal je begint, je komt altijd op 1 uit. Als voorbeeld, beginnend bij het getal 3 krijg je de reeks 3, 10, 5, 16, 8, 4, 2, 1.</p>"},{"location":"voorkennis/#dunder-methods","title":"Dunder methods","text":"meer leren <p>Hoe weet Python eigenlijk wat de lengte is van een string? Of hoe je getallen optelt? Voor operatoren als <code>+ - * / **</code> wordt eigenlijk een method aangeroepen. bijvoorbeeld <code>__add__()</code> voor <code>+</code>, en <code>__mul__()</code> voor <code>*</code>. Een ingebouwde functie als <code>len()</code> roept stiekem de method <code>__len__()</code> aan en <code>print()</code> print de uitvoer van <code>__str__()</code>. Zulke methodes worden dunder methods10 of magic methods genoemd. We kunnen zelf bijvoorbeeld een vector introduceren waarbij we de operatoren voor onze eigen doeleinden gebruiken 26. We defini\u00ebren het optellen van vectoren en de absolute waarde (norm) van de vector:</p> <p><pre><code>class Vector:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef __add__(self, other):\nnew_x = self.x + other.x\nnew_y = self.y + other.y\nreturn Vector(new_x, new_y)\ndef __abs__(self):\nreturn (self.x ** 2 + self.y ** 2) ** .5\n</code></pre> De speciale <code>__init__()</code> methode zorgt voor de initialisatie van de klasse en de eerste parameter die alle methodes meekrijgen verwijst naar zichzelf en wordt dus gewoonlijk <code>self</code> genoemd.11 Met de regel <code>self.x = x</code> wordt de parameter <code>x</code> bewaard voor later gebruik. Je kunt de klasse gebruiken op de volgende manier:</p> <p>Terminal<pre><code>&gt;&gt;&gt; v1 = Vector(0, 1)\n&gt;&gt;&gt; v2 = Vector(1, 0)\n&gt;&gt;&gt; abs(v1)\n1.0\n&gt;&gt;&gt; abs(v2)\n1.0\n&gt;&gt;&gt; abs(v1 + v2)\n1.4142135623730951\n&gt;&gt;&gt; (v1 + v2).x, (v1 + v2).y\n(1, 1)\n&gt;&gt;&gt; v1 + v2\n&lt;__main__.Vector object at 0x7fdf80b3ae10&gt;\n&gt;&gt;&gt; print(v1 + v2)\n&lt;__main__.Vector object at 0x7fdf80b45450&gt;\n</code></pre> In de eerste regels maken we twee vectoren v_1 en v_2 en berekenen de lengtes12 ||v_1||, ||v_2|| en ||v_1 + v_2||. Ook kunnen we de co\u00f6rdinaten van de som bekijken. Het gaat mis als we de somvector willen printen of willen kijken wat voor object het is. We krijgen technisch juiste, maar totaal onbruikbare informatie terug. Dit lossen we op met het defini\u00ebren van <code>__str__()</code>, gebruikt door <code>str()</code> en dus ook <code>print()</code>, en <code>__repr__()</code>, gebruikt door <code>repr()</code> en de Python interpreter.13</p> <p><pre><code>class Vector:\n...\ndef __repr__(self):\nreturn f\"Vector: ({self.x}, {self.y})\"\ndef __str__(self):\n# roept __repr__ aan\nreturn repr(self)\n</code></pre> Terminal<pre><code>&gt;&gt;&gt; v1 + v2\nVector: (1, 1)\n&gt;&gt;&gt; print(v1 + v2)\nVector: (1, 1)\n</code></pre> We raden je aan altijd een zinnige <code>__str__</code> en <code>__repr__</code> te defini\u00ebren.</p> <p>Vaak hebben classes geen dunder methods nodig (behalve <code>__repr__</code> en <code>__str__</code>).</p> <p>Je kunt behalve een class ook een subclass aanmaken. Stel dat je een class <code>Animal</code> hebt aangemaakt met handige methods en attributes maar je wilt een nieuwe, iets specifiekere class maken (bijvoorbeeld <code>Cow</code>). Het is duidelijk dat een koe een dier is, maar een dier nog geen koe. Je kunt een subclass maken: <pre><code>class Cow(Animal):\npass\n</code></pre> Het keyword <code>pass</code> doet niets overigens. Met alleen dit statement heeft de class <code>Cow</code> precies alle functionaliteit van de class <code>Animal</code>. Je kunt daarna zelf nog extra methods en attributes defini\u00ebren.</p>"},{"location":"voorkennis/#decorators","title":"Decorators","text":"meer leren <p>Functies zijn ook objecten in Python. Je kunt ze, zoals we eerder gezien hebben, meegeven als argument of bewaren in een dictionary. Ook kun je functies in functies defini\u00ebren en functies defini\u00ebren die functies teruggeven. Vaag14. Ik moet hier altijd weer even over nadenken en daarom mag je dit stukje overslaan. Om decorators te gebruiken, hoef je niet per se te weten hoe ze werken.</p> <p> Decorators worden vaak gebruikt om het gedrag van een functie aan te passen.</p> <p>Stel je hebt een functie die eenvoudig twee getallen vermenigvuldigd. Je wilt deze functie, zonder hem van binnen te veranderen, aanpassen zodat hij altijd het kwadraat van de vermenigvuldiging geeft. Dus niet $a\\cdot b$, maar $(a\\cdot b)^2$. Dat kan als volgt:</p> <p><pre><code>def f(a, b):\nreturn a * b\ndef squared(func, a, b):\nreturn func(a, b) ** 2\nf(3, 4)\n# 12\nsquared(f, 3, 4)\n# 144\n</code></pre> Het werkt, maar we moeten er wel steeds aan denken om <code>squared()</code> aan te roepen en dan \u00f3\u00f3k nog de functie <code>f()</code> als eerste argument mee te geven. Lastig. Maar omdat functies objecten zijn kan dit ook: <pre><code>def squared_func(func):\ndef inner_func(a, b):\nreturn func(a, b) ** 2\nreturn inner_func\ng = squared_func(f)\ng(3, 4)\n# 144\n</code></pre></p> <p>Hier gebeurt iets geks\u2026 Om te begrijpen wat hier gebeurt moeten we een beetje heen en weer springen. In regel 8 roepen we de functie <code>squared_func(f)</code> aan. In regel 5 zien we dat die functie een andere functie teruggeeft -- die niet wordt aangeroepen! In regel 8 wordt die functie bewaard als <code>g</code> en pas in regel 9 roepen we hem aan. De functie <code>g()</code> is dus eigenlijk gelijk aan de functie <code>inner_func()</code> die in regels 2--3 gedefinieerd wordt. De aanroep in regel 9 zorgt er uiteindelijk voor dat in regel 3 de oorspronkelijke functie <code>f(a, b)</code> wordt aangeroepen en dat het antwoord gekwadrateerd wordt. Dit is echt wel even lastig.</p> <p>In deze opzet moet de <code>inner_func(a, b)</code> nog weten dat de oorspronkelijke functie aangeroepen wordt met twee argumenten <code>a</code> en <code>b</code>. Maar ook dat hoeft niet. We hebben immers argument (un)packing met <code>*args</code>: <pre><code>def squared_func(func):\ndef inner_func(*args):\nreturn func(*args) ** 2\nreturn inner_func\n</code></pre> En nu komt het: in Python kun je de decorator syntax gebruiken om je functie te vervangen door een iets aangepaste functie. In plaats van: <pre><code>f = squared_func(f)\n</code></pre> op te nemen in je code kun je de functie meteen `decoraten' als volgt: <pre><code>@squared_func\ndef f(a, b):\nreturn a * b\nf(3, 4)\n# 144\n</code></pre></p> <p>Als je meer wilt weten over hoe decorators werken en hoe je je eigen decorators kunt maken, dan vind je een uitgebreide uitleg in Primer on Python Decorators 27. Deze tutorial heb je niet per se nodig voor de volgende opdracht.</p> <p>&lt;!-- % \\begin{todo} %   Deze opdracht vond ik best lastig, vooral omdat ik er volgens mij nog geen drol van begreep. Misschien is het goed om hier een opzetje te maken. Dus een scriptje met een functie die argumenten nodig heeft een een waarde teruggeeft. %   ``` py %     import datetime</p> <p>%     def log(func): %         def inner():</p> <p>%             return func(a,b)</p> <p>%         return inner</p> <p>%     @log %     def f(a, b): %         return a * b</p> <p>%     print(f(3, 4)) %     print(f(3, b=4)) %     ``` %   En dan in een paar stappen. Zorg eerst dat de logfunctie het zonder poespas gaat doen (oftewel run die handel en los de error op) en dan functionaliteit toevoegen dat de datum enzo wordt geprint. % \\end{todo} --&gt;</p> <p>decorators</p> <p>Schrijf en test een decorator die werkt als een soort logboek. Als je een functie aanroept die gedecoreerd is print dan een regel op het scherm met het tijdstip van de aanroep, de parameters die meegegeven werden \u00e9n de return value van de functie.</p>"},{"location":"voorkennis/#modules","title":"Modules","text":"<p>Als je een nieuw script begint te schrijven staat alle code in \u00e9\u00e9n bestand. Dat is lekker compact, maar heeft ook nadelen. Als je je experiment of programma gaat uitbreiden kan het erg onoverzichtelijk worden. Ook zul je al je wijzigingen steeds in dit bestand moeten doen terwijl je je code van eerdere experimenten misschien wel wilt bewaren. Mogelijk kopieer je steeds je script naar een nieuw bestand, maar dat is niet erg DRY.15 Als je dan bijvoorbeeld een functie of klasse wilt aanpassen, moet dat nog steeds op heel veel plekken. Daarom is het handig om gebruik te maken van modules.</p> <p>Eenvoudig gezegd is een module een stuk Python code dat je kunt importeren en gebruiken. Meestal worden er in een module handige functies en klasses gedefinieerd: Terminal<pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(2)\n1.4142135623730951\n&gt;&gt;&gt; math.pi\n3.141592653589793\n&gt;&gt;&gt; math.sin(.5 * math.pi)\n1.0\n</code></pre> Door de <code>math</code> module te importeren hebben we opeens de beschikking over het getal $\\pi$ en de sinus- en wortelfunties.</p> <p>Je kunt je eigen code ook importeren, maar hier moet je wel even opletten. Stel, we hebben een bestand square.py: square.py<pre><code>def square(x):\nreturn x**2\nprint(f\"The square of 4 is {square(4)}\")\n</code></pre> Als je deze code runt is de uitvoer: Terminal<pre><code>The square of 4 is 16\n</code></pre> Zoals verwacht! Maar nu willen we in een nieuw script, count_count.py, de functie importeren en gebruiken: count_count.py<pre><code>import square\nprint(f\"The square of 5 is {square.square(5)}\")\n</code></pre></p> <p>square.square</p> <p>Waarom staat er in bovenstaande code nu opeens <code>square.square()</code> in plaats van gewoon <code>square()</code>?</p> <p>Maar nu is er een probleem met de uitvoer van dit script: Terminal<pre><code>The square of 4 is 16\nThe square of 5 is 25\n</code></pre> Tijdens het importeren wordt alle code die aanwezig is in square.py ook daadwerkelijk gerunt. Er zijn twee manieren om dit op te lossen:</p> <ol> <li>Alle `extra' code verwijderen uit de module (square.py)</li> <li>De code in de module alleen laten runnen als de module als script wordt aangeroepen, maar niet wanneer de module wordt ge\u00efmporteerd</li> </ol> <p>De eerste oplossing is lang niet altijd wenselijk. Voor de tweede oplossing pas je square.py als volgt aan: square.py<pre><code>def square(x):\nreturn x**2\nif __name__ == \"__main__\":\nprint(f\"The square of 4 is {square(4)}\")\n</code></pre> Wanneer je een python script runt is de speciale variabele <code>__name__</code> gelijk aan de string <code>__main__</code>. Maar als je een module importeert is <code>__name__</code> gelijk aan de naam van de module; in dit geval <code>square</code>. Met bovenstaande constructie wordt de code alleen uitgevoerd wanneer de module direct gerunt wordt:</p> Terminal<pre><code>PS&gt; python square.py\nThe square of 4 is 16\nPS&gt; python count_count.py\nThe square of 5 is 25\n</code></pre> <p>Het <code>if __name__ == '__main__'</code>-statement wordt heel veel gebruikt in Python modules.</p> <p>modules</p> <ul> <li>Maak zelf de bestanden square.py en just_count.py aan en probeer het importeren uit, met en zonder het <code>if __name__ == '__main__'</code>-statement.</li> <li>Voeg <code>print(f\"{__name__ = }\")</code> toe bovenaan square.py. Run square.py en daarna just_count.py. Zie hoe de speciale variabele <code>__name__</code> veranderd. </li> </ul>"},{"location":"voorkennis/#packages","title":"Packages","text":"<p>In Python zijn packages collecties van modules. Ook krijg je automatisch namespaces. Dat wil zeggen, wanneer je functies en modules uit een package importeert zitten ze niet in \u00e9\u00e9n grote vormeloze berg, maar in een soort boomstructuur. Dat betekent dat namen niet uniek hoeven te zijn. Er zijn duizenden bibliotheken beschikbaar voor python (<code>numpy</code>, <code>scipy</code>, <code>matplotlib</code>, etc.) en die mogen allemaal een module <code>test</code> bevatten. Namespaces zorgen ervoor dat je ze uniek kunt benaderen: <pre><code>import numpy.test\nimport scipy.test\n</code></pre> In bovenstaande code zijn <code>numpy</code> en <code>scipy</code> afzonderlijke namespaces. Ook zijn <code>numpy.test</code> en <code>scipy.test</code> afzonderlijke namespaces. De namen van bijvoorbeeld variabelen en functies binnen die modules zullen nooit met elkaar in conflict komen.</p> <p>Wij gaan in deze cursus onze code ook in packages stoppen. Op die manier kun je een softwarebibliotheek opbouwen voor je experiment en die code makkelijker delen met andere onderzoekers. Een pakket is opgebouwd zoals hieronder weergegeven:</p> <ul> <li> my_project_folder<ul> <li> my_pkg<ul> <li> __init__.py</li> <li> pkg1<ul> <li> __init__.py</li> <li> module1.py</li> <li> module2.py</li> </ul> </li> <li> pkg2<ul> <li>__init__.py</li> <li>module3.py</li> </ul> </li> <li>module4.py</li> </ul> </li> </ul> </li> </ul> <p>Iedere package bestaat uit een directory met een __init__.py-bestand.16</p> <p>De verschillende modules uit figuur packagetree kun je als volgt importeren en gebruiken (we gaan er even vanuit dat iedere module een functie <code>some_func()</code> bevat): <pre><code># module direct importeren\nimport my_pkg.pkg1.module1\nmy_pkg.pkg1.module1.some_func()\n# losse module vanuit een package importeren\nfrom my_pkg.pkg1 import module2\nmodule2.some_func()\n# module importeren onder een andere naam\nimport my_pkg.module4 as m4\nm4.some_func()\n</code></pre></p> <p>In deze cursus gaan we ook packages maken. Feitelijk hoeven we een python script dus alleen maar in een map te stoppen en in diezelfde map een lege __init__.py aan te maken.</p> <p>Waarschuwing</p> <p>Let op: als je de __init__.py vergeet dan lijkt alles het alsnog te doen. Maar je maakt nu een implicit namespace package waarbij bepaalde directories toch weer op een grote hoop gegooid worden. Geloof me, echt niet handig.17 Namespace packages kunnen handig zijn voor grote projecten, maar dat is het dan ook wel. Wij gaan hier niet verder op in. Kortom: let op en gebruik altijd een __init__.py.</p> <p>Packages</p> <p>In deze opdracht ga je oefenen met het aanmaken van packages, modules en het importeren en aanroepen daarvan.</p> <ol> <li>Maak een package <code>models</code> met twee modules: <code>polynomials</code> en <code>tests</code>.</li> <li>In de <code>polynomials</code>-module maak je een functie <code>line(x, a, b)</code> die de de vergelijking voor een lijn voor ons berekent: $y = ax + b$.</li> <li> <p>In de <code>tests</code>-module maak je een functie <code>test_line()</code> die het volgende doet:</p> <ol> <li>gebruik de <code>line()</code>-functie uit de <code>polynomials</code>-module om de $y$-waarde uit te rekenen voor een bepaald punt bij een gegeven $a$ en $b$.</li> <li>Vergelijk die berekende waarde met de waarde die het volgens jij moet zijn (met de hand nagerekend).</li> <li>Print <code>TEST PASSED</code> als het klopt, en <code>TEST FAILED</code> als het niet klopt.</li> </ol> </li> <li> <p>Maak een script die:</p> <ol> <li>Een grafiek maakt van jouw lijn. Bepaal zelf het domein en de waardes voor $a$ en $b$.</li> <li>De test uitvoert door de <code>test_line()</code>-functie aan te roepen.</li> <li>Pas je <code>line()</code>-functie eventjes aan om te kijken of je test ook echt werkt. Bijvoorbeeld: bij $y = ax$ zou je <code>TEST FAILED</code> moeten zien.</li> </ol> </li> </ol>"},{"location":"voorkennis/#de-standard-library-en-de-python-package-index","title":"De Standard Library en de Python Package Index","text":"meer leren <p>Voor Python zijn ontzettend veel bibliotheken beschikbaar die het leven een stuk aangenamer maken. Voor een gedeelte daarvan geldt dat ze altijd aanwezig zijn als je Python ge\u00efnstalleerd hebt. Deze set vormt de standard library 24. Om te voorkomen dat je zelf het wiel uitvindt is het goed om af en toe door de lijst te bladeren zodat je een idee krijgt wat er allemaal beschikbaar is. Ziet het er bruikbaar uit? Lees dan vooral de documentatie! Tip: vergeet de built-in functions niet.</p> <p>Verder zijn er nog eindeloos veel packages beschikbaar gesteld door programmeurs, van hobbyist tot multinational. Deze kunnen centraal gepubliceerd worden in de Python Package Index 18. Je kunt daar vaak ook zien hoe populair een package is. Dit is een belangrijke indicatie voor de kwaliteit en bruikbaarheid van een package.</p>"},{"location":"voorkennis/#exceptions","title":"Exceptions","text":"meer leren <p>Exceptions zijn de foutmeldingen van Python. Je krijgt ze als je bijvoorbeeld probeert te delen door nul of wanneer je een typefout maakt in de naam van een method of attribute: Terminal<pre><code>&gt;&gt;&gt; 1 / 0\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n&gt;&gt;&gt; s = \"particle\"\n&gt;&gt;&gt; s.upler()\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'str' object has no attribute 'upler'\n</code></pre> Merk op dat je een exception met traceback meestal van onder naar boven leest. Onderaan staat de foutmelding (exception) en daar boven een traceback: een kruimelpad van w\u00e1\u00e1r in de code het probleem optrad; onderaan de regel waarin het echt fout ging, en naar boven toe alle tussenliggende functies en bibliotheken met bovenaan het hoofdprogramma.</p> <p>Een exception kan vervelend zijn. Het is een beetje jammer als je bijvoorbeeld tijdens een langdurige meting telkens een weerstand aan het uitrekenen bent ($R = \\frac{U}{I}$) en de stroomsterkte $I$ wordt na anderhalf uur heel eventjes nul. Je programma crasht en je metingen zijn weg. Zoek de fout (niet altijd makkelijk!) en probeer het nog eens.</p> <p>Je kunt exceptions afvangen en afhandelen met een <code>try...except</code> blok: <pre><code>def R(U, I):\ntry:\nR = U / I\nexcept ZeroDivisionError:\nR = \"Inf\"\nreturn R\n</code></pre> Terminal<pre><code>&gt;&gt;&gt; R(10, 2)\n5.0\n&gt;&gt;&gt; R(10, 0)\n'Inf'\n</code></pre></p> <p>Ook kun je zelf exceptions maken. Stel je schrijft een programma om een oscilloscoop uit te lezen dat twee kanalen heeft om de spanning te meten. Kanaal 0 en kanaal 1. Het programma moet gebruikt kunnen worden door andere studenten in de onderzoeksgroep dus het kan nu eenmaal gebeuren dat iemand niet op zit te letten -- niet jij, jij let altijd goed op. Een andere student die een programma schrijft en jouw code gebruikt wil een spanning meten op kanaal 2, het was immers een tweekanaals oscilloscoop. Maar kanaal 2 bestaat niet. Sommige oscilloscopen klagen dan niet maar geven een random getal terug. Dit kan leiden tot heel vervelende en lastig te achterhalen fouten in het experiment. Met dat idee in je achterhoofd kun je code schrijven die controleert op het kanaalnummer en een exception geeft: <pre><code># we maken een subclass van de 'standaard' Exception\nclass InvalidChannelException(Exception):\npass\ndef get_voltage(channel):\nif channel not in [0, 1]:\nraise InvalidChannelException(f\"Use channel 0 or 1, not {channel}\")\n...\nreturn voltage\n</code></pre> Met deze uitvoer in het geval dat er iets mis gaat: Terminal<pre><code>&gt;&gt;&gt; get_voltage(1)\n1.0\n&gt;&gt;&gt; get_voltage(2)\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nget_voltage(2)\nFile \"exc_channel.py\", line 6, in get_voltage\nraise InvalidChannelException(f\"Use channel 0 or 1, not {channel}\")\nInvalidChannelException: Use channel 0 or 1, not 2\n</code></pre> Je kunt op deze manier voorkomen dat iemand dagen kwijt is aan het overdoen van achteraf verkeerd gebleken metingen. Ook kun je 'vage' foutmeldingen omzetten in duidelijkere foutmeldingen: <pre><code>class NoCurrentError(Exception):\npass\ndef R(U, I):\ntry:\nR = U / I\nexcept ZeroDivisionError:\nraise NoCurrentError(\"There is no current flowing through the resistor.\")\nreturn R\n</code></pre> In plaats van een <code>ZeroDivisionError</code> krijg je nu een <code>NoCurrentError</code>. Je programma crasht nog steeds (wellicht niet handig) maar de foutmelding is nu wel specifiek voor het probleem en kan in de rest van je programma wellicht beter afgevangen en opgelost worden. Misschien beter dan niet crashen en een mogelijk foute waarde doorgeven. Die afweging zul je zelf moeten maken.</p> Opdrachtuitwerkingen <p>exceptions</p> <p>De volgende code berekent een gemiddelde van een lijst getallen: <pre><code>def average(values):\nreturn sum(values) / len(values)    \n</code></pre> Er is alleen geen foutafhandeling en dat kan leiden tot exceptions. De volgende aanroepen zorgen voor een crash (probeer ze allemaal uit!): <pre><code>average([])\naverage(4)\naverage(\"12345\")\n</code></pre> Pas de functie <code>average()</code> zodanig aan dat bij bovenstaande aanroepen slechts een waarschuwing wordt geprint. Vang daartoe de exceptions netjes af en geef de waarde <code>None</code> terug wanneer een gemiddelde niet berekend kan worden. Dus bovenstaande drie aanroepen krijgen <code>None</code> terug terwijl er een waarschuwing wordt geprint.</p> <pre><code>def average(values):\ntry:\naverage = sum(values) / len(values)\nexcept TypeError:\naverage = None\nprint(\"Input is not correct type\")\nexcept ZeroDivisionError:\naverage = None\nprint(\"Input is empty\")\nreturn average\nprint(average([1, 2, 3]))\naverage([])\n# # gives: ZeroDivisionError: division by zero\naverage(4)\n# # gives: TypeError: 'int' object is not iterable\na = average(\"12345\")\n# # gives: TypeError: unsupported operand type(s) for +: 'int' and 'str'\n# print(a)\n</code></pre>"},{"location":"voorkennis/#inleiding-programmeren-terugblik","title":"Inleiding programmeren; terugblik","text":"<p>Bij de cursus inleiding programmeren heb je de basis van het programmeren in Python geleerd. Bij inleiding programmeren mocht je kiezen om je code in het Nederlands of Engels te schrijven. Omdat wij jullie voorbereiden om in een onderzoeksgroep je bachelor project te gaan doen waar je hoogstwaarschijnlijk internationale collega's gaat treffen vragen we jou om bij ECPC alles in het Engels te schrijven. In deze paragraaf nemen we de hoofdlijnen van inleiding programmeren met je door in een aantal opdrachten. </p> <p>f-strings, variabelen en input</p> <ol> <li>Schrijf een python script waarin je de gebruiker vraagt wat de diameter van de bal is. </li> <li>Bereken de radius van de bal.</li> <li>Print de diameter en radius in een zin en maak gebruik van f-string. Bijvoorbeeld: \"A ball with a diameter of 2.8 m has a radius of 1.4 m.\"</li> <li>Test je script met het getal 2.8. </li> </ol> <p>if-statement en operatoren</p> <p>Met een <code>if</code>-statement kan je een conditie testen door operatoren te gebruiken. </p> <ol> <li>Schrijf de operatoren op voor:<ul> <li>gelijk aan</li> <li>ongelijk aan</li> <li>groter dan</li> <li>groter of gelijk aan</li> <li>kleiner dan</li> <li>kleiner dan of gelijk aan</li> </ul> </li> <li>Vul op de <code>...</code> de juiste condities in door gebruik te maken van <code>and</code>, <code>not</code> en <code>or</code>. <pre><code>rain = False\numbrella = False\nif ... :\nprint(\"Lucky you have your umbrella with you since it's raining.\")\nif ... :\nif ... :\nprint(\"You will get wet without an umbrella since it's raining.\")\nif ... :\nprint(\"you can use your umbrella as a walking stick since it doesn't rain\")\nif ... :\nprint(\"Without an umbrella there is no problem since it's not raining.\")\n</code></pre></li> </ol> <p>For-loop, while-loop en break</p> <ol> <li>Beschouw de volgende code: <pre><code>voltage = 0  # mV\nsteps = 50  # mV\nwhile voltage &lt; 3300:\nvoltage += steps\n</code></pre></li> </ol> <p>Bij het programmeren krijg je vaak errors. Bij het debuggen van een loop zijn twee dingen heel handig <code>print</code> en <code>break</code>.</p> <ol> <li>Gebruik <code>print</code> om het voltage te printen in the while-loop, doe dit handig met f-strings zodat je weet wat je je print bijvoorbeeld: \"The voltage is set to 0 mV.\"</li> <li>Gebruik dan <code>break</code> om de loop maar een keer te laten lopen. </li> <li>Schrijf de code om waarbij je gebruikt maakt van een <code>for</code>-loop. </li> </ol> <p>functies</p> <ol> <li> <p>Maak uit de onderstaande code de functie exponentiation werkend.  <pre><code>def exponentiation():\nsolution =\n...\nnumber_1 = 2\nnumber_2 = 8\nanswer = exponentiation(number_1, number_2)\nprint(f\"{number_1}^{number_2} = {answer}\")\n</code></pre></p> </li> <li> <p>In deze opdracht zijn 4 variabele <code>solution</code>, <code>number_1</code>, <code>number_2</code> en <code>answer</code>. Welk van deze variabele zijn globaal en welke zijn lokaal?</p> </li> <li>Leg uit wat daarvan de consequentie is voor het gebruiken van deze variabelen. </li> </ol> <p>lijsten</p> <ol> <li>Schrijf een python script waarin je een lijst definieerd met de namen van de maanden.</li> <li>Print de negende maand.</li> <li>Voeg een dertiende maand toe aan de lijst.</li> </ol> <p>Bij inleiding programmeren heb je ook geleerd hoe je code netjes opschrijft zodat het leesbaar en begrijpelijk is. Hieronder vind je een samenvatting, die een beetje aangevuld is met ECPC stijl. - Je schrijft je code in het Engels. - <code>def functie_namen_met_doel():</code> Namen van functies mogen lang zijn, maar geven duidelijk weer wat de functie doet. - <code>korte_variabele = 28</code> de namen van variabele houd je kort en duidelijk. Gebruik alleen afkortingen waarneer deze door veel mensen gekend zijn. - Je hoeft de code niet af te drukken dus gebruik liever meer regels dan een hele lange regel waar meer dan 1 ding gebeurd. - Gebruik <code>#commentaar-kopjes</code> om een stukje code samen te vatten, een waarschuwing te geven, uitleg van complexe algoritmen te doen, voor bronvermelding, uitleg van een variabele te geven en zet dit altijd boven het stukje code waar het omgaat.  - Spring in waar nodig, gebruik witregels, zet spaties rondom operatoren.</p> <p>Ook heb je geleerd om functies uit andere (python) modules te importeren, meer hierover vind je in de paragraaf Modules. </p> <p>Grafieken</p> <p>Gebruik matplotlib om een scatterplot te maken van twee lijsten die hieronder zijn weergegeven. Zet de grootheden en eenheden bij beide assen en sla het figuur op als .png-bestand. <pre><code>time = [0, 0.5, 1, 1.5, 2, 2.5, 3] #seconds\ndistance = [0, 15, 50, 100, 200, 300, 400] #meters\n</code></pre></p> <p>txt-bestanden lezen</p> <p>Hieronder vind je een verhaal, kopieer de inhoud naar een .txt-bestand en sla deze op een handige plek op. <pre><code>\"Do you have a favourite\nsaying?\" asked the boy.\n\"Yes\" said the mole\n\"What is it?\"\n\"If at first you don't \nsucceed have some cake.\"\n\"I see, does it work?\"\n\"Every time.\"\nFrom: The Boy, the mole, the fox and the Horse - Charlie Mackesy\n</code></pre></p> <p>Schrijf een script om het .txt-bestand te lezen en regel voor regel te printen.</p> <ol> <li> <p>Python 2 is dood. Leve Python 3!\u00a0\u21a9</p> </li> <li> <p>Tenzij je al veel zelf hebt geprogrammeerd in Python, buiten de cursussen om.\u00a0\u21a9</p> </li> <li> <p>Letterlijk: onveranderbaar.\u00a0\u21a9</p> </li> <li> <p>Daar is bijvoorbeeld de <code>collections.namedtuple()</code> dan weer handig voor.\u00a0\u21a9</p> </li> <li> <p>De programmertaal C ligt dichter bij machinetaal dan Python en is daarmee veel sneller maar ook veel minder geavanceerd.\u00a0\u21a9</p> </li> <li> <p>Echt. De sinus van 2000 $x$-waardes berekenen kostte NumPy in een test 11.6$\\micro$s en de for-loop wel 1357.7$\\micro$s.\u00a0\u21a9</p> </li> <li> <p>Strikt genomen is dit niet helemaal waar. Je kunt een nieuwe array cre\u00ebren door meerdere arrays aan elkaar te plakken. Maar een eenvoudige <code>append()</code>-method bestaat niet voor arrays.\u00a0\u21a9</p> </li> <li> <p>Notatie hetzelfde, maar gebruik nu <code>{</code>}-haakjes.\u00a0\u21a9</p> </li> <li> <p>Het is hierbij wel belangrijk dat <code>lmfit</code> er vanuit gaat dat de eerste variabele in de functiedefinitie de onafhankelijke variabele ($x$-as) is. Dit is verder geen Pythonlimitatie.\u00a0\u21a9</p> </li> <li> <p>Dunder staat voor double underscore, de twee lage streepjes die om de naam heen staan.\u00a0\u21a9</p> </li> <li> <p>Maar dat is niet verplicht, je mag in principe zelf een naam kiezen. Doe dat echter niet.\u00a0\u21a9</p> </li> <li> <p>Absolute waarde of beter, norm, van een vector is eenvoudig gezegd haar lengte.\u00a0\u21a9</p> </li> <li> <p>Het verschil tussen de twee is subtiel. De Pythondocumentatie geeft aan dat de <code>__repr__</code> altijd ondubbelzinnig moet zijn, terwijl de <code>__str__</code> vooral leesbaar moet zijn. Voor eenvoudige objecten zijn ze veelal gelijk.\u00a0\u21a9</p> </li> <li> <p>Calmcode doet een goeie poging om dit rustig uit te leggen, kijk daarvoor op https://calmcode.io/decorators/functions.html \u21a9</p> </li> <li> <p>DRY staat voor Don't Repeat Yourself, een belangrijk principe in software engineering.\u00a0\u21a9</p> </li> <li> <p>Dat bestand is vaak leeg, maar kan code bevatten die gerunt wordt zodra het package wordt ge\u00efmporteerd.\u00a0\u21a9</p> </li> <li> <p>En wat mij betreft: een fout dat zoiets \u00fcberhaupt kan in Python. Zen of Python: explicit is better than implicit. \u21a9</p> </li> <li> <p>Python Software Foundation. Python package index. URL: https://pypi.org.\u00a0\u21a9\u21a9</p> </li> <li> <p>Ivo van Vulpen and Martijn Stegeman. Wetenschappelijk programmeren. 2020. URL: https://progns.proglab.nl/syllabus.\u00a0\u21a9</p> </li> <li> <p>Anthony Scopatz and Kathryn D. Huff. Effective Computation in Physics. O'Reilly Media, Inc., 2015. URL: https://www.oreilly.com/library/view/effective-computation-in/9781491901564/.\u00a0\u21a9</p> </li> <li> <p>Allen Downey. Think Python. Green Tea Press, 2nd edition edition, 2015. URL: https://greenteapress.com/wp/think-python-2e/.\u00a0\u21a9</p> </li> <li> <p>Tim Peters. Zen of python. URL: https://groups.google.com/d/msg/comp.lang.python/B_VxeTBClM0/L8W9KlsiriUJ.\u00a0\u21a9</p> </li> <li> <p>Chaitanya Baweja. Contemplating the zen of python. URL: https://medium.com/better-programming/contemplating-the-zen-of-python-186722b833e5.\u00a0\u21a9</p> </li> <li> <p>Python Software Foundation. The python standard library. URL: https://docs.python.org/3/library/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Real Python. Real python: python tutorials. URL: https://realpython.com.\u00a0\u21a9</p> </li> <li> <p>Malay Agarwal. Operator and function overloading in custom python classes. URL: https://realpython.com/operator-function-overloading/ (visited on 2020-06-25).\u00a0\u21a9</p> </li> <li> <p>Geir Arne Hjelle. Primer on python decorators. 2018. URL: https://realpython.com/primer-on-python-decorators/.\u00a0\u21a9</p> </li> </ol>"},{"location":"zonnecel/","title":"Zonnecel","text":"<p>De toenemende behoefte aan energie heeft het zoeken naar nieuwe energiebronnen belangrijk gemaakt. Zonne-energie is \u00e9\u00e9n van de veelbelovende, niet-conventionele bronnen. Zonne-energie is echter niet meteen bruikbaar en moet eerst omgezet worden naar warmte of elektrische energie. De omzetting van zonne-energie naar een bruikbare vorm van energie kan gedaan worden door een zonneboiler of een zonnecel. In de komende sessies staat de zonnecel centraal. Je gaat allerlei eigenschappen van zonnecellen onderzoeken en proberen te verklaren.</p>"},{"location":"zonnecel/#de-fotovoltaische-zonnecel","title":"De fotovolta\u00efsche zonnecel","text":"<p>Stralingsenergie van de zon is een vorm van energie die niet erg nuttig is voor de meeste toepassingen. Om de energie van de zon nuttig te kunnen gebruiken, moet de straling omgezet worden. Een mogelijkheid daartoe is de fotovolta\u00efsche zonnecel. In de zonnecel maken fotonen uit het zonlicht geladen (elektrische) deeltjes vrij die via metaalcontacten op de zonnecel door een extern circuit kunnen stromen om daar hun elektrische energie af te geven. Zolang er licht valt op de zonnecel gaat het proces van vrijmaken van elektronen door en wordt er een elektrische stroom geproduceerd.</p>"},{"location":"zonnecel/#werking","title":"Werking","text":"<p>Werking van een zonnecel. Een foton met voldoende energie kan een elektron-gat-paar maken. Door de grenslaag tussen het n-type silicium en het p-type-silicium kan het elektron alleen linksom stromen, door het externe circuit, en het gat alleen rechtsom.</p> <p>De werking van de zonnecel is schematisch weergegeven in de figuur hieronder. Een zonnecel bestaat uit twee soorten siliciumkristallen, een bovenlaag van het n-type silicium en een tweede, dikkere laag van het p-type silicium. In het n-type silicium kunnen elektronen gemakkelijk bewegen, terwijl in het p-type silicium de gaten (positieve lading) makkelijk kunnen bewegen. Tussen het p- en n-type silicium ontstaat een grenslaag, welke een barri\u00e8re vormt voor zowel de elektronen als de gaten. Deze zogenoemde pn-junctie is de basis van de huidige elektronica en heeft vele toepassingen, zo ook in de zonnecel.</p> <p></p> <p>In een zonnecel is de n-laag zo dun dat het zonlicht de grenslaag kan bereiken. Als er nu een foton op de grenslaag valt, en het foton heeft voldoende energie, dan maakt dat foton een elektron-gat-paar. Kijkend naar de figuur kunnen de elektronen door de grenslaag niet rechtsom bewegen en de gaten niet linksom.  Het elektron gaat nu linksom stromen en het gat rechtsom. Er ontstaat dus een elektrische stroom. Na doorlopen van het externe circuit recombineert het elektron weer met het gat in het p-type silicium. De maximale stroom die gaat lopen wordt bepaald door het aantal elektron-gat-paren dat gevormd wordt. De maximale spanning die over de zonnecel komt te staan wordt bepaald door de energie die daarvoor nodig is (bedenk dat $[U] = J/C$!).</p> <p>Om een elektron-gat-paar in een silicium zonnecel te maken is een energie nodig van 1.12 eV (elektronvolt). De energie van een foton ($E_f$) is gelijk aan \\begin{equation}   E_f = \\frac{hc}{\\lambda} \\end{equation} waar $h$ staat voor de constante van Planck ($h \\approx 4.136 \\cdot 10^{-15} \\text{ eV} \\cdot \\text{s}$), $c$ staat voor de snelheid waarmee licht zich voortplant ($c \\approx 2.998 \\cdot 10^8$ ms$^{-1}$) en $\\lambda$ staat voor de golflengte van het licht. Dit betekent dat een foton met een golflengte van ongeveer \\begin{equation}   \\lambda = \\frac{(4.136 \\cdot 10^{-15} \\text{ eV} \\cdot \\text{s}) \\cdot (2.998 \\cdot 10^8 \\text{ ms}^{-1})}{1.12 \\text{ eV}}\\approx 1100   {\\rm nm} \\end{equation} in staat is om een elektron-gat-paar te maken. Fotonen met een golflengte groter dan 1100 nm hebben een lagere energie dan 1.12 eV en daarvoor is de zonnecel niet gevoelig. Fotonen met een kortere golflengte dan 1100 nm hebben een hogere energie dan nodig is. Zij maken wel een elektron-gat-paar, maar het overschot aan energie wordt niet omgezet in elektrische energie, deze energie gaat verloren als warmte.</p> <p>Op YouTube staat de volgende video met uitleg over de werking van de zonnecel: How do solar cells work?.</p>"},{"location":"zonnecel/#vereenvoudigde-modelbeschrijving","title":"Vereenvoudigde modelbeschrijving","text":"<p>De werking van een zonnecel hangt sterk samen met de werking van een diode. Een diode heeft de bijzondere eigenschap dat afhankelijk van de polariteit over de diode het \u00f3f geen stroom door laat en dus een oneindige hoge weerstand heeft, \u00f3f alle stroom doorlaat en bij benadering een weerstand van 0 heeft. Preciezer gezegd: voor een diode geldt dat de stroom die doorgelaten wordt, afhangt van de spanning over de diode. De stroom door een diode, $I_d$, wordt (bij benadering) gegeven door</p> <p>\\begin{equation}   I_d = I_0 \\left( {\\rm e}^{\\frac{eU}{kT}} - 1 \\right), \\end{equation} waarbij $e$ de elektronlading is ($e \\approx 1.602 \\cdot 10^{-19}$ C), $U$ de spanning over de diode, $k$ de Boltzmannconstante ($k \\approx {1.381} \\cdot 10^{-23}$ JK$^{-1}$) en $T$ de temperatuur. $I_0$ is de lekstroom van de diode. Als de spanning over de diode negatief is, geldt dat $\\exp \\left( \\frac{eU}{kT} \\right) \\ll 1$ en is $I_d \\approx - I_0 \\approx 5-7 \\; \\mu$A en dus bij benadering 0. Als de spanning over de diode positief is groeit de stroom exponentieel en is de weerstand van de diode bij benadering 0. Dit gedrag wordt ge\u00efllustreerd in de figuur hieronder.</p> <p></p> <p>Links het symbool waarmee een diode weergegeven wordt in een schakeling en rechts een $IU$-karakteristiek van een diode.</p> <p></p> <p>Een vereenvoudigde voorstelling van een zonnecel met daarop aangesloten een belastingsweerstand $R_b$. $I_L$ is de stroom opgewekt door elektron-gat-paren, $I_d$ is de stroom die door de diode loopt en $I$ is de stroom die door belastingsweerstand $R_b$ loopt, die aangesloten is op de zonnecel.</p> <p>Voor een eerste benadering kun je een zonnecel voorstellen als een speciale stroombron, zoals weergegeven is in bovenstaande figuur. In deze schakeling is ook de belastingsweerstand $R_b$ over de zonnecel getekend. De stroom die geleverd wordt door de zonnecel, $I$, hangt af van de stroom ten gevolge van het aantal elektron-gat-paren dat gemaakt wordt door het zonlicht, $I_{L}$, en de stroom door de diode, $I_d$. Dus: \\begin{equation}   I = I_L - I_d. \\end{equation} Met behulp van de diodevergelijking kun je bovenstaande vergelijking verder uitschrijven. In de exponent voor de diode komt er echter nog een factor $n$ bij die samenhangt met de materiaaleigenschappen van de zonnecel. Waarden van $n$ liggen typisch tussen 1 en 5, afhankelijk van het type zonnecel. Voor het type zonnecel waarmee je in dit experiment zult werken is $n$ ongeveer 10-15. De stroom die de zonnecel levert wordt nu bij benadering gegeven door</p> <p>\\begin{equation}   I = I_{L} - I_d = I_{L} - I_0 \\left( {\\rm e}^{ \\frac{e U}{nkT}} - 1 \\right). \\end{equation}</p>"},{"location":"zonnecel/#iu-karakteristiek","title":"I,U-karakteristiek","text":"<p>In de praktijk zul je altijd metingen doen aan zonnepanelen, waarbij zonnecellen in het paneel samengebracht zijn. De spanning die over een zonnepaneel staat hangt onder andere af van het aantal zonnecellen dat in serie geschakeld is. De stroom dat een zonnepaneel kan leveren wordt bepaald door het aantal elektron-gat-paren dat gemaakt wordt of, anders gezegd, door het aantal fotonen dat geabsorbeerd wordt. Het is echter niet zo dat je zonder meer kunt stellen dat wanneer er zonlicht op een zonnepaneel valt er een maximale spanning over het paneel staat en dat de stroom toeneemt als de lichtintensiteit toeneemt.</p> <p>Het is daarom zinvol om, voordat je aan een experiment begint, het gedrag van een zonnepaneel te onderzoeken. In eerste instantie doe je dit door te kijken naar de $I,U$-karakteristiek van het zonnepaneel. Zo'n karakteristiek is weergegeven in onderstaand figuur:</p> <p></p> <p>Als je naar de $I,U$-karakteristiek kijkt, zie je dat het zonnepaneel zich bij lage spanningen gedraagt als een niet-ideale stroombron. Als je rond de maximale spanning kijkt, zie je dat het zonnepaneel zich daar vrijwel gedraagt als een niet-ideale spanningsbron.</p> <p>De stroom die geleverd kan worden door een zonnecel uitgezet tegen de spanning $U_\\text{PV}$ geleverd door de zonnecel. Hier staat PV voor PhotoVoltaic cell.</p>"},{"location":"zonnecel/#prb-karakteristiek","title":"P,Rb-karakteristiek","text":"<p>Het is bij zonnepanelen natuurlijk interessant om naar het elektrisch vermogen te kijken dat een zonnepaneel kan leveren. Het geleverd vermogen door een zonnepaneel hangt af van de materiaaleigenschappen van het paneel. Om een zo hoog mogelijk vermogen te kunnen leveren moet het zonnepaneel een zo hoog mogelijke stroom en spanning leveren. Belangrijk ook is dat het vermogen afhangt van de belasting door het circuit. Met andere woorden: bij verschillende weerstandswaardes wordt een ander vermogen geleverd. Ook is er een optimale weerstand waarbij het vermogen maximaal is:</p> <p></p> <p>Het vermogen dat geleverd kan worden door een zonnecel uitgezet tegen de belasting (weerstand) van het circuit. Er is duidelijk een maximum in het vermogen bij een optimale weerstand.</p>"},{"location":"zonnecel/#fill-factor","title":"Fill factor","text":"<p>De kwaliteit van een zonnecel/-paneel wordt experimenteel vaak aangeduid met de fill factor $FF$. De fill factor wordt gegeven door \\begin{equation}   FF = \\frac{P_{max}}{P_{T_{max}}} = \\frac{I_{Pmax} \\cdot U_{Pmax}}{I_{sc} \\cdot U_{oc}}, \\end{equation} waarbij $P_{max}$ het maximaal vermogen is wat een zonnecel/-paneel levert en $P_{T_{max}}$ het theoretisch maximaal vermogen is. $I_{sc}$ is de kortsluitstroom (bij een belastingsweerstand $R_b$ gelijk aan 0) en $U_{oc}$ de open klemspanning (wanneer het zonnepaneel niet belast wordt). $I_{Pmax}$ en $U_{Pmax}$ zijn de waarden voor respectievelijk de stroom en spanning waarbij het geleverd vermogen maximaal is.</p>"},{"location":"zonnecel/#maximum-power-point-tracking","title":"Maximum power point tracking","text":"<p>De optimale weerstand waarbij het vermogen dat geleverd wordt door een zonnecel maximaal is, is helaas geen constante. Deze weerstandswaarde is afhankelijk van verschillende condities waarbij de belangrijkste de lichtintensiteit op de zonnecel is. Dat betekent dat, zonder aanpassingen, het vermogen dat geleverd wordt door de zonnecel meestal veel lager is dan je zou wensen.</p> <p>Voor zonnepanelen die elektriciteit leveren aan het lichtnet is dit een groot probleem. Allereerst wil je je investering zo snel mogelijk terugverdienen en ook daarna wil je dat de opbrengst maximaal is. Ten tweede is het zo dat de weerstand van het lichtnet bijzonder klein is. Het vermogen dat daardoor geleverd wordt is ook heel klein. Dit wordt opgelost door \u2014 envoudig gezegd \u2014 de verbinding tussen het zonnepaneel en het lichtnet vele malen per seconde aan en uit te schakelen. Hierdoor voelt het zonnepaneel als het ware een weerstand. Deze weerstand is afhankelijk van de hoeveelheid tijd dat het paneel niet aan het lichtnet is geschakeld. Door slim te schakelen kan de weerstand z\u00f3 gekozen worden dat het geleverde vermogen maximaal is. Als de lichtintensiteit wijzigt kan ook de weerstand worden aangepast. Dit heet maximum power point tracking.</p>"}]}